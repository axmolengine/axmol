// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSPARSEBINARY_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CSPARSEBINARY_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace flatbuffers {

struct CSParseBinary;
struct CSParseBinaryBuilder;

struct NodeTree;
struct NodeTreeBuilder;

struct Options;
struct OptionsBuilder;

struct WidgetOptions;
struct WidgetOptionsBuilder;

struct LayoutComponentTable;
struct LayoutComponentTableBuilder;

struct SingleNodeOptions;
struct SingleNodeOptionsBuilder;

struct SpriteOptions;
struct SpriteOptionsBuilder;

struct ParticleSystemOptions;
struct ParticleSystemOptionsBuilder;

struct SpineSkeletonOptions;
struct SpineSkeletonOptionsBuilder;

struct ControlSwitchOptions;
struct ControlSwitchOptionsBuilder;

struct LayerColorOptions;
struct LayerColorOptionsBuilder;

struct GameMapOptions;
struct GameMapOptionsBuilder;

struct ButtonOptions;
struct ButtonOptionsBuilder;

struct CheckBoxOptions;
struct CheckBoxOptionsBuilder;

struct RadioButtonOptions;
struct RadioButtonOptionsBuilder;

struct RadioButtonGroupOptions;
struct RadioButtonGroupOptionsBuilder;

struct ImageViewOptions;
struct ImageViewOptionsBuilder;

struct TextAtlasOptions;
struct TextAtlasOptionsBuilder;

struct TextBMFontOptions;
struct TextBMFontOptionsBuilder;

struct TextOptions;
struct TextOptionsBuilder;

struct RichTextOptions;
struct RichTextOptionsBuilder;

struct TextFieldOptions;
struct TextFieldOptionsBuilder;

struct LoadingBarOptions;
struct LoadingBarOptionsBuilder;

struct SliderOptions;
struct SliderOptionsBuilder;

struct PanelOptions;
struct PanelOptionsBuilder;

struct ScrollViewOptions;
struct ScrollViewOptionsBuilder;

struct PageViewOptions;
struct PageViewOptionsBuilder;

struct ListViewOptions;
struct ListViewOptionsBuilder;

struct TextFieldExOptions;
struct TextFieldExOptionsBuilder;

struct ProjectNodeOptions;
struct ProjectNodeOptionsBuilder;

struct ComponentOptions;
struct ComponentOptionsBuilder;

struct ComAudioOptions;
struct ComAudioOptionsBuilder;

struct AnimationInfo;
struct AnimationInfoBuilder;

struct NodeAction;
struct NodeActionBuilder;

struct TimeLine;
struct TimeLineBuilder;

struct Frame;
struct FrameBuilder;

struct PointFrame;
struct PointFrameBuilder;

struct ScaleFrame;
struct ScaleFrameBuilder;

struct ColorFrame;
struct ColorFrameBuilder;

struct TextureFrame;
struct TextureFrameBuilder;

struct EventFrame;
struct EventFrameBuilder;

struct IntFrame;
struct IntFrameBuilder;

struct BoolFrame;
struct BoolFrameBuilder;

struct InnerActionFrame;
struct InnerActionFrameBuilder;

struct EasingData;
struct EasingDataBuilder;

struct FVec2;

struct FVec3;

struct FColor;

struct FlatSize;

struct CapInsets;

struct BlendFunc;

struct ResourceData;
struct ResourceDataBuilder;

struct BlendFrame;
struct BlendFrameBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FVec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  FVec2()
      : x_(0),
        y_(0) {
  }
  FVec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(FVec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FVec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  FVec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  FVec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(FVec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) FColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t a_;
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  FColor()
      : a_(0),
        r_(0),
        g_(0),
        b_(0) {
  }
  FColor(uint8_t _a, uint8_t _r, uint8_t _g, uint8_t _b)
      : a_(::flatbuffers::EndianScalar(_a)),
        r_(::flatbuffers::EndianScalar(_r)),
        g_(::flatbuffers::EndianScalar(_g)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  uint8_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  uint8_t r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return ::flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(FColor, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FlatSize FLATBUFFERS_FINAL_CLASS {
 private:
  float width_;
  float height_;

 public:
  FlatSize()
      : width_(0),
        height_(0) {
  }
  FlatSize(float _width, float _height)
      : width_(::flatbuffers::EndianScalar(_width)),
        height_(::flatbuffers::EndianScalar(_height)) {
  }
  float width() const {
    return ::flatbuffers::EndianScalar(width_);
  }
  float height() const {
    return ::flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(FlatSize, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CapInsets FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float width_;
  float height_;

 public:
  CapInsets()
      : x_(0),
        y_(0),
        width_(0),
        height_(0) {
  }
  CapInsets(float _x, float _y, float _width, float _height)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        width_(::flatbuffers::EndianScalar(_width)),
        height_(::flatbuffers::EndianScalar(_height)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float width() const {
    return ::flatbuffers::EndianScalar(width_);
  }
  float height() const {
    return ::flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(CapInsets, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BlendFunc FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t src_;
  int32_t dst_;

 public:
  BlendFunc()
      : src_(0),
        dst_(0) {
  }
  BlendFunc(int32_t _src, int32_t _dst)
      : src_(::flatbuffers::EndianScalar(_src)),
        dst_(::flatbuffers::EndianScalar(_dst)) {
  }
  int32_t src() const {
    return ::flatbuffers::EndianScalar(src_);
  }
  int32_t dst() const {
    return ::flatbuffers::EndianScalar(dst_);
  }
};
FLATBUFFERS_STRUCT_END(BlendFunc, 8);

struct CSParseBinary FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CSParseBinaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TEXTURES = 6,
    VT_TEXTUREPNGS = 8,
    VT_NODETREE = 10,
    VT_ACTION = 12,
    VT_ANIMATIONLIST = 14
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *textures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TEXTURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *texturePngs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TEXTUREPNGS);
  }
  const flatbuffers::NodeTree *nodeTree() const {
    return GetPointer<const flatbuffers::NodeTree *>(VT_NODETREE);
  }
  const flatbuffers::NodeAction *action() const {
    return GetPointer<const flatbuffers::NodeAction *>(VT_ACTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::AnimationInfo>> *animationList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::AnimationInfo>> *>(VT_ANIMATIONLIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfStrings(textures()) &&
           VerifyOffset(verifier, VT_TEXTUREPNGS) &&
           verifier.VerifyVector(texturePngs()) &&
           verifier.VerifyVectorOfStrings(texturePngs()) &&
           VerifyOffset(verifier, VT_NODETREE) &&
           verifier.VerifyTable(nodeTree()) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyTable(action()) &&
           VerifyOffset(verifier, VT_ANIMATIONLIST) &&
           verifier.VerifyVector(animationList()) &&
           verifier.VerifyVectorOfTables(animationList()) &&
           verifier.EndTable();
  }
};

struct CSParseBinaryBuilder {
  typedef CSParseBinary Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(CSParseBinary::VT_VERSION, version);
  }
  void add_textures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> textures) {
    fbb_.AddOffset(CSParseBinary::VT_TEXTURES, textures);
  }
  void add_texturePngs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> texturePngs) {
    fbb_.AddOffset(CSParseBinary::VT_TEXTUREPNGS, texturePngs);
  }
  void add_nodeTree(::flatbuffers::Offset<flatbuffers::NodeTree> nodeTree) {
    fbb_.AddOffset(CSParseBinary::VT_NODETREE, nodeTree);
  }
  void add_action(::flatbuffers::Offset<flatbuffers::NodeAction> action) {
    fbb_.AddOffset(CSParseBinary::VT_ACTION, action);
  }
  void add_animationList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::AnimationInfo>>> animationList) {
    fbb_.AddOffset(CSParseBinary::VT_ANIMATIONLIST, animationList);
  }
  explicit CSParseBinaryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CSParseBinary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CSParseBinary>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CSParseBinary> CreateCSParseBinary(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> textures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> texturePngs = 0,
    ::flatbuffers::Offset<flatbuffers::NodeTree> nodeTree = 0,
    ::flatbuffers::Offset<flatbuffers::NodeAction> action = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::AnimationInfo>>> animationList = 0) {
  CSParseBinaryBuilder builder_(_fbb);
  builder_.add_animationList(animationList);
  builder_.add_action(action);
  builder_.add_nodeTree(nodeTree);
  builder_.add_texturePngs(texturePngs);
  builder_.add_textures(textures);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CSParseBinary> CreateCSParseBinaryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *textures = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *texturePngs = nullptr,
    ::flatbuffers::Offset<flatbuffers::NodeTree> nodeTree = 0,
    ::flatbuffers::Offset<flatbuffers::NodeAction> action = 0,
    const std::vector<::flatbuffers::Offset<flatbuffers::AnimationInfo>> *animationList = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto textures__ = textures ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*textures) : 0;
  auto texturePngs__ = texturePngs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*texturePngs) : 0;
  auto animationList__ = animationList ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::AnimationInfo>>(*animationList) : 0;
  return flatbuffers::CreateCSParseBinary(
      _fbb,
      version__,
      textures__,
      texturePngs__,
      nodeTree,
      action,
      animationList__);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeTreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSNAME = 4,
    VT_CHILDREN = 6,
    VT_OPTIONS = 8,
    VT_CUSTOMCLASSNAME = 10
  };
  const ::flatbuffers::String *classname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSNAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::NodeTree>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::NodeTree>> *>(VT_CHILDREN);
  }
  const flatbuffers::Options *options() const {
    return GetPointer<const flatbuffers::Options *>(VT_OPTIONS);
  }
  const ::flatbuffers::String *customClassName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOMCLASSNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASSNAME) &&
           verifier.VerifyString(classname()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           VerifyOffset(verifier, VT_CUSTOMCLASSNAME) &&
           verifier.VerifyString(customClassName()) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  typedef NodeTree Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_classname(::flatbuffers::Offset<::flatbuffers::String> classname) {
    fbb_.AddOffset(NodeTree::VT_CLASSNAME, classname);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::NodeTree>>> children) {
    fbb_.AddOffset(NodeTree::VT_CHILDREN, children);
  }
  void add_options(::flatbuffers::Offset<flatbuffers::Options> options) {
    fbb_.AddOffset(NodeTree::VT_OPTIONS, options);
  }
  void add_customClassName(::flatbuffers::Offset<::flatbuffers::String> customClassName) {
    fbb_.AddOffset(NodeTree::VT_CUSTOMCLASSNAME, customClassName);
  }
  explicit NodeTreeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeTree>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeTree> CreateNodeTree(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> classname = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::NodeTree>>> children = 0,
    ::flatbuffers::Offset<flatbuffers::Options> options = 0,
    ::flatbuffers::Offset<::flatbuffers::String> customClassName = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_customClassName(customClassName);
  builder_.add_options(options);
  builder_.add_children(children);
  builder_.add_classname(classname);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *classname = nullptr,
    const std::vector<::flatbuffers::Offset<flatbuffers::NodeTree>> *children = nullptr,
    ::flatbuffers::Offset<flatbuffers::Options> options = 0,
    const char *customClassName = nullptr) {
  auto classname__ = classname ? _fbb.CreateString(classname) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::NodeTree>>(*children) : 0;
  auto customClassName__ = customClassName ? _fbb.CreateString(customClassName) : 0;
  return flatbuffers::CreateNodeTree(
      _fbb,
      classname__,
      children__,
      options,
      customClassName__);
}

struct Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::WidgetOptions *data() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct OptionsBuilder {
  typedef Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<flatbuffers::WidgetOptions> data) {
    fbb_.AddOffset(Options::VT_DATA, data);
  }
  explicit OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Options> CreateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> data = 0) {
  OptionsBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct WidgetOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WidgetOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ACTIONTAG = 6,
    VT_ROTATIONSKEW = 8,
    VT_ZORDER = 10,
    VT_VISIBLE = 12,
    VT_ALPHA = 14,
    VT_TAG = 16,
    VT_POSITION = 18,
    VT_SCALE = 20,
    VT_ANCHORPOINT = 22,
    VT_COLOR = 24,
    VT_SIZE = 26,
    VT_FLIPX = 28,
    VT_FLIPY = 30,
    VT_IGNORESIZE = 32,
    VT_TOUCHENABLED = 34,
    VT_FRAMEEVENT = 36,
    VT_CUSTOMPROPERTY = 38,
    VT_CALLBACKTYPE = 40,
    VT_CALLBACKNAME = 42,
    VT_LAYOUTCOMPONENT = 44,
    VT_CASCADECOLORENABLED = 46,
    VT_CASCADEOPACITYENABLED = 48
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t actionTag() const {
    return GetField<int32_t>(VT_ACTIONTAG, 0);
  }
  const flatbuffers::FVec2 *rotationSkew() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_ROTATIONSKEW);
  }
  int32_t zOrder() const {
    return GetField<int32_t>(VT_ZORDER, 0);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 1) != 0;
  }
  uint8_t alpha() const {
    return GetField<uint8_t>(VT_ALPHA, 255);
  }
  int32_t tag() const {
    return GetField<int32_t>(VT_TAG, 0);
  }
  const flatbuffers::FVec2 *position() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_POSITION);
  }
  const flatbuffers::FVec2 *scale() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_SCALE);
  }
  const flatbuffers::FVec2 *anchorPoint() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_ANCHORPOINT);
  }
  const flatbuffers::FColor *color() const {
    return GetStruct<const flatbuffers::FColor *>(VT_COLOR);
  }
  const flatbuffers::FlatSize *size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SIZE);
  }
  bool flipX() const {
    return GetField<uint8_t>(VT_FLIPX, 0) != 0;
  }
  bool flipY() const {
    return GetField<uint8_t>(VT_FLIPY, 0) != 0;
  }
  bool ignoreSize() const {
    return GetField<uint8_t>(VT_IGNORESIZE, 0) != 0;
  }
  bool touchEnabled() const {
    return GetField<uint8_t>(VT_TOUCHENABLED, 0) != 0;
  }
  const ::flatbuffers::String *frameEvent() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAMEEVENT);
  }
  const ::flatbuffers::String *customProperty() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOMPROPERTY);
  }
  const ::flatbuffers::String *callBackType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLBACKTYPE);
  }
  const ::flatbuffers::String *callBackName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLBACKNAME);
  }
  const flatbuffers::LayoutComponentTable *layoutComponent() const {
    return GetPointer<const flatbuffers::LayoutComponentTable *>(VT_LAYOUTCOMPONENT);
  }
  bool cascadeColorEnabled() const {
    return GetField<uint8_t>(VT_CASCADECOLORENABLED, 0) != 0;
  }
  bool cascadeOpacityEnabled() const {
    return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_ACTIONTAG, 4) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_ROTATIONSKEW, 4) &&
           VerifyField<int32_t>(verifier, VT_ZORDER, 4) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALPHA, 1) &&
           VerifyField<int32_t>(verifier, VT_TAG, 4) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_POSITION, 4) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_SCALE, 4) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_ANCHORPOINT, 4) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_COLOR, 1) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FLIPX, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLIPY, 1) &&
           VerifyField<uint8_t>(verifier, VT_IGNORESIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TOUCHENABLED, 1) &&
           VerifyOffset(verifier, VT_FRAMEEVENT) &&
           verifier.VerifyString(frameEvent()) &&
           VerifyOffset(verifier, VT_CUSTOMPROPERTY) &&
           verifier.VerifyString(customProperty()) &&
           VerifyOffset(verifier, VT_CALLBACKTYPE) &&
           verifier.VerifyString(callBackType()) &&
           VerifyOffset(verifier, VT_CALLBACKNAME) &&
           verifier.VerifyString(callBackName()) &&
           VerifyOffset(verifier, VT_LAYOUTCOMPONENT) &&
           verifier.VerifyTable(layoutComponent()) &&
           VerifyField<uint8_t>(verifier, VT_CASCADECOLORENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED, 1) &&
           verifier.EndTable();
  }
};

struct WidgetOptionsBuilder {
  typedef WidgetOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(WidgetOptions::VT_NAME, name);
  }
  void add_actionTag(int32_t actionTag) {
    fbb_.AddElement<int32_t>(WidgetOptions::VT_ACTIONTAG, actionTag, 0);
  }
  void add_rotationSkew(const flatbuffers::FVec2 *rotationSkew) {
    fbb_.AddStruct(WidgetOptions::VT_ROTATIONSKEW, rotationSkew);
  }
  void add_zOrder(int32_t zOrder) {
    fbb_.AddElement<int32_t>(WidgetOptions::VT_ZORDER, zOrder, 0);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_VISIBLE, static_cast<uint8_t>(visible), 1);
  }
  void add_alpha(uint8_t alpha) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_ALPHA, alpha, 255);
  }
  void add_tag(int32_t tag) {
    fbb_.AddElement<int32_t>(WidgetOptions::VT_TAG, tag, 0);
  }
  void add_position(const flatbuffers::FVec2 *position) {
    fbb_.AddStruct(WidgetOptions::VT_POSITION, position);
  }
  void add_scale(const flatbuffers::FVec2 *scale) {
    fbb_.AddStruct(WidgetOptions::VT_SCALE, scale);
  }
  void add_anchorPoint(const flatbuffers::FVec2 *anchorPoint) {
    fbb_.AddStruct(WidgetOptions::VT_ANCHORPOINT, anchorPoint);
  }
  void add_color(const flatbuffers::FColor *color) {
    fbb_.AddStruct(WidgetOptions::VT_COLOR, color);
  }
  void add_size(const flatbuffers::FlatSize *size) {
    fbb_.AddStruct(WidgetOptions::VT_SIZE, size);
  }
  void add_flipX(bool flipX) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_FLIPX, static_cast<uint8_t>(flipX), 0);
  }
  void add_flipY(bool flipY) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_FLIPY, static_cast<uint8_t>(flipY), 0);
  }
  void add_ignoreSize(bool ignoreSize) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_IGNORESIZE, static_cast<uint8_t>(ignoreSize), 0);
  }
  void add_touchEnabled(bool touchEnabled) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_TOUCHENABLED, static_cast<uint8_t>(touchEnabled), 0);
  }
  void add_frameEvent(::flatbuffers::Offset<::flatbuffers::String> frameEvent) {
    fbb_.AddOffset(WidgetOptions::VT_FRAMEEVENT, frameEvent);
  }
  void add_customProperty(::flatbuffers::Offset<::flatbuffers::String> customProperty) {
    fbb_.AddOffset(WidgetOptions::VT_CUSTOMPROPERTY, customProperty);
  }
  void add_callBackType(::flatbuffers::Offset<::flatbuffers::String> callBackType) {
    fbb_.AddOffset(WidgetOptions::VT_CALLBACKTYPE, callBackType);
  }
  void add_callBackName(::flatbuffers::Offset<::flatbuffers::String> callBackName) {
    fbb_.AddOffset(WidgetOptions::VT_CALLBACKNAME, callBackName);
  }
  void add_layoutComponent(::flatbuffers::Offset<flatbuffers::LayoutComponentTable> layoutComponent) {
    fbb_.AddOffset(WidgetOptions::VT_LAYOUTCOMPONENT, layoutComponent);
  }
  void add_cascadeColorEnabled(bool cascadeColorEnabled) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_CASCADECOLORENABLED, static_cast<uint8_t>(cascadeColorEnabled), 0);
  }
  void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled) {
    fbb_.AddElement<uint8_t>(WidgetOptions::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 0);
  }
  explicit WidgetOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WidgetOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WidgetOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WidgetOptions> CreateWidgetOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t actionTag = 0,
    const flatbuffers::FVec2 *rotationSkew = nullptr,
    int32_t zOrder = 0,
    bool visible = true,
    uint8_t alpha = 255,
    int32_t tag = 0,
    const flatbuffers::FVec2 *position = nullptr,
    const flatbuffers::FVec2 *scale = nullptr,
    const flatbuffers::FVec2 *anchorPoint = nullptr,
    const flatbuffers::FColor *color = nullptr,
    const flatbuffers::FlatSize *size = nullptr,
    bool flipX = false,
    bool flipY = false,
    bool ignoreSize = false,
    bool touchEnabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> frameEvent = 0,
    ::flatbuffers::Offset<::flatbuffers::String> customProperty = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callBackType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callBackName = 0,
    ::flatbuffers::Offset<flatbuffers::LayoutComponentTable> layoutComponent = 0,
    bool cascadeColorEnabled = false,
    bool cascadeOpacityEnabled = false) {
  WidgetOptionsBuilder builder_(_fbb);
  builder_.add_layoutComponent(layoutComponent);
  builder_.add_callBackName(callBackName);
  builder_.add_callBackType(callBackType);
  builder_.add_customProperty(customProperty);
  builder_.add_frameEvent(frameEvent);
  builder_.add_size(size);
  builder_.add_color(color);
  builder_.add_anchorPoint(anchorPoint);
  builder_.add_scale(scale);
  builder_.add_position(position);
  builder_.add_tag(tag);
  builder_.add_zOrder(zOrder);
  builder_.add_rotationSkew(rotationSkew);
  builder_.add_actionTag(actionTag);
  builder_.add_name(name);
  builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
  builder_.add_cascadeColorEnabled(cascadeColorEnabled);
  builder_.add_touchEnabled(touchEnabled);
  builder_.add_ignoreSize(ignoreSize);
  builder_.add_flipY(flipY);
  builder_.add_flipX(flipX);
  builder_.add_alpha(alpha);
  builder_.add_visible(visible);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WidgetOptions> CreateWidgetOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t actionTag = 0,
    const flatbuffers::FVec2 *rotationSkew = nullptr,
    int32_t zOrder = 0,
    bool visible = true,
    uint8_t alpha = 255,
    int32_t tag = 0,
    const flatbuffers::FVec2 *position = nullptr,
    const flatbuffers::FVec2 *scale = nullptr,
    const flatbuffers::FVec2 *anchorPoint = nullptr,
    const flatbuffers::FColor *color = nullptr,
    const flatbuffers::FlatSize *size = nullptr,
    bool flipX = false,
    bool flipY = false,
    bool ignoreSize = false,
    bool touchEnabled = false,
    const char *frameEvent = nullptr,
    const char *customProperty = nullptr,
    const char *callBackType = nullptr,
    const char *callBackName = nullptr,
    ::flatbuffers::Offset<flatbuffers::LayoutComponentTable> layoutComponent = 0,
    bool cascadeColorEnabled = false,
    bool cascadeOpacityEnabled = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto frameEvent__ = frameEvent ? _fbb.CreateString(frameEvent) : 0;
  auto customProperty__ = customProperty ? _fbb.CreateString(customProperty) : 0;
  auto callBackType__ = callBackType ? _fbb.CreateString(callBackType) : 0;
  auto callBackName__ = callBackName ? _fbb.CreateString(callBackName) : 0;
  return flatbuffers::CreateWidgetOptions(
      _fbb,
      name__,
      actionTag,
      rotationSkew,
      zOrder,
      visible,
      alpha,
      tag,
      position,
      scale,
      anchorPoint,
      color,
      size,
      flipX,
      flipY,
      ignoreSize,
      touchEnabled,
      frameEvent__,
      customProperty__,
      callBackType__,
      callBackName__,
      layoutComponent,
      cascadeColorEnabled,
      cascadeOpacityEnabled);
}

struct LayoutComponentTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayoutComponentTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONXPERCENTENABLED = 4,
    VT_POSITIONYPERCENTENABLED = 6,
    VT_POSITIONXPERCENT = 8,
    VT_POSITIONYPERCENT = 10,
    VT_SIZEXPERCENTENABLE = 12,
    VT_SIZEYPERCENTENABLE = 14,
    VT_SIZEXPERCENT = 16,
    VT_SIZEYPERCENT = 18,
    VT_STRETCHHORIZONTALENABLED = 20,
    VT_STRETCHVERTICALENABLED = 22,
    VT_HORIZONTALEDGE = 24,
    VT_VERTICALEDGE = 26,
    VT_LEFTMARGIN = 28,
    VT_RIGHTMARGIN = 30,
    VT_TOPMARGIN = 32,
    VT_BOTTOMMARGIN = 34
  };
  bool positionXPercentEnabled() const {
    return GetField<uint8_t>(VT_POSITIONXPERCENTENABLED, 0) != 0;
  }
  bool positionYPercentEnabled() const {
    return GetField<uint8_t>(VT_POSITIONYPERCENTENABLED, 0) != 0;
  }
  float positionXPercent() const {
    return GetField<float>(VT_POSITIONXPERCENT, 0.0f);
  }
  float positionYPercent() const {
    return GetField<float>(VT_POSITIONYPERCENT, 0.0f);
  }
  bool sizeXPercentEnable() const {
    return GetField<uint8_t>(VT_SIZEXPERCENTENABLE, 0) != 0;
  }
  bool sizeYPercentEnable() const {
    return GetField<uint8_t>(VT_SIZEYPERCENTENABLE, 0) != 0;
  }
  float sizeXPercent() const {
    return GetField<float>(VT_SIZEXPERCENT, 0.0f);
  }
  float sizeYPercent() const {
    return GetField<float>(VT_SIZEYPERCENT, 0.0f);
  }
  bool stretchHorizontalEnabled() const {
    return GetField<uint8_t>(VT_STRETCHHORIZONTALENABLED, 0) != 0;
  }
  bool stretchVerticalEnabled() const {
    return GetField<uint8_t>(VT_STRETCHVERTICALENABLED, 0) != 0;
  }
  const ::flatbuffers::String *horizontalEdge() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HORIZONTALEDGE);
  }
  const ::flatbuffers::String *verticalEdge() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERTICALEDGE);
  }
  float leftMargin() const {
    return GetField<float>(VT_LEFTMARGIN, 0.0f);
  }
  float rightMargin() const {
    return GetField<float>(VT_RIGHTMARGIN, 0.0f);
  }
  float topMargin() const {
    return GetField<float>(VT_TOPMARGIN, 0.0f);
  }
  float bottomMargin() const {
    return GetField<float>(VT_BOTTOMMARGIN, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POSITIONXPERCENTENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITIONYPERCENTENABLED, 1) &&
           VerifyField<float>(verifier, VT_POSITIONXPERCENT, 4) &&
           VerifyField<float>(verifier, VT_POSITIONYPERCENT, 4) &&
           VerifyField<uint8_t>(verifier, VT_SIZEXPERCENTENABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SIZEYPERCENTENABLE, 1) &&
           VerifyField<float>(verifier, VT_SIZEXPERCENT, 4) &&
           VerifyField<float>(verifier, VT_SIZEYPERCENT, 4) &&
           VerifyField<uint8_t>(verifier, VT_STRETCHHORIZONTALENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_STRETCHVERTICALENABLED, 1) &&
           VerifyOffset(verifier, VT_HORIZONTALEDGE) &&
           verifier.VerifyString(horizontalEdge()) &&
           VerifyOffset(verifier, VT_VERTICALEDGE) &&
           verifier.VerifyString(verticalEdge()) &&
           VerifyField<float>(verifier, VT_LEFTMARGIN, 4) &&
           VerifyField<float>(verifier, VT_RIGHTMARGIN, 4) &&
           VerifyField<float>(verifier, VT_TOPMARGIN, 4) &&
           VerifyField<float>(verifier, VT_BOTTOMMARGIN, 4) &&
           verifier.EndTable();
  }
};

struct LayoutComponentTableBuilder {
  typedef LayoutComponentTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_positionXPercentEnabled(bool positionXPercentEnabled) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_POSITIONXPERCENTENABLED, static_cast<uint8_t>(positionXPercentEnabled), 0);
  }
  void add_positionYPercentEnabled(bool positionYPercentEnabled) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_POSITIONYPERCENTENABLED, static_cast<uint8_t>(positionYPercentEnabled), 0);
  }
  void add_positionXPercent(float positionXPercent) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_POSITIONXPERCENT, positionXPercent, 0.0f);
  }
  void add_positionYPercent(float positionYPercent) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_POSITIONYPERCENT, positionYPercent, 0.0f);
  }
  void add_sizeXPercentEnable(bool sizeXPercentEnable) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_SIZEXPERCENTENABLE, static_cast<uint8_t>(sizeXPercentEnable), 0);
  }
  void add_sizeYPercentEnable(bool sizeYPercentEnable) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_SIZEYPERCENTENABLE, static_cast<uint8_t>(sizeYPercentEnable), 0);
  }
  void add_sizeXPercent(float sizeXPercent) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_SIZEXPERCENT, sizeXPercent, 0.0f);
  }
  void add_sizeYPercent(float sizeYPercent) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_SIZEYPERCENT, sizeYPercent, 0.0f);
  }
  void add_stretchHorizontalEnabled(bool stretchHorizontalEnabled) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_STRETCHHORIZONTALENABLED, static_cast<uint8_t>(stretchHorizontalEnabled), 0);
  }
  void add_stretchVerticalEnabled(bool stretchVerticalEnabled) {
    fbb_.AddElement<uint8_t>(LayoutComponentTable::VT_STRETCHVERTICALENABLED, static_cast<uint8_t>(stretchVerticalEnabled), 0);
  }
  void add_horizontalEdge(::flatbuffers::Offset<::flatbuffers::String> horizontalEdge) {
    fbb_.AddOffset(LayoutComponentTable::VT_HORIZONTALEDGE, horizontalEdge);
  }
  void add_verticalEdge(::flatbuffers::Offset<::flatbuffers::String> verticalEdge) {
    fbb_.AddOffset(LayoutComponentTable::VT_VERTICALEDGE, verticalEdge);
  }
  void add_leftMargin(float leftMargin) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_LEFTMARGIN, leftMargin, 0.0f);
  }
  void add_rightMargin(float rightMargin) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_RIGHTMARGIN, rightMargin, 0.0f);
  }
  void add_topMargin(float topMargin) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_TOPMARGIN, topMargin, 0.0f);
  }
  void add_bottomMargin(float bottomMargin) {
    fbb_.AddElement<float>(LayoutComponentTable::VT_BOTTOMMARGIN, bottomMargin, 0.0f);
  }
  explicit LayoutComponentTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayoutComponentTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayoutComponentTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayoutComponentTable> CreateLayoutComponentTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool positionXPercentEnabled = false,
    bool positionYPercentEnabled = false,
    float positionXPercent = 0.0f,
    float positionYPercent = 0.0f,
    bool sizeXPercentEnable = false,
    bool sizeYPercentEnable = false,
    float sizeXPercent = 0.0f,
    float sizeYPercent = 0.0f,
    bool stretchHorizontalEnabled = false,
    bool stretchVerticalEnabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> horizontalEdge = 0,
    ::flatbuffers::Offset<::flatbuffers::String> verticalEdge = 0,
    float leftMargin = 0.0f,
    float rightMargin = 0.0f,
    float topMargin = 0.0f,
    float bottomMargin = 0.0f) {
  LayoutComponentTableBuilder builder_(_fbb);
  builder_.add_bottomMargin(bottomMargin);
  builder_.add_topMargin(topMargin);
  builder_.add_rightMargin(rightMargin);
  builder_.add_leftMargin(leftMargin);
  builder_.add_verticalEdge(verticalEdge);
  builder_.add_horizontalEdge(horizontalEdge);
  builder_.add_sizeYPercent(sizeYPercent);
  builder_.add_sizeXPercent(sizeXPercent);
  builder_.add_positionYPercent(positionYPercent);
  builder_.add_positionXPercent(positionXPercent);
  builder_.add_stretchVerticalEnabled(stretchVerticalEnabled);
  builder_.add_stretchHorizontalEnabled(stretchHorizontalEnabled);
  builder_.add_sizeYPercentEnable(sizeYPercentEnable);
  builder_.add_sizeXPercentEnable(sizeXPercentEnable);
  builder_.add_positionYPercentEnabled(positionYPercentEnabled);
  builder_.add_positionXPercentEnabled(positionXPercentEnabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LayoutComponentTable> CreateLayoutComponentTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool positionXPercentEnabled = false,
    bool positionYPercentEnabled = false,
    float positionXPercent = 0.0f,
    float positionYPercent = 0.0f,
    bool sizeXPercentEnable = false,
    bool sizeYPercentEnable = false,
    float sizeXPercent = 0.0f,
    float sizeYPercent = 0.0f,
    bool stretchHorizontalEnabled = false,
    bool stretchVerticalEnabled = false,
    const char *horizontalEdge = nullptr,
    const char *verticalEdge = nullptr,
    float leftMargin = 0.0f,
    float rightMargin = 0.0f,
    float topMargin = 0.0f,
    float bottomMargin = 0.0f) {
  auto horizontalEdge__ = horizontalEdge ? _fbb.CreateString(horizontalEdge) : 0;
  auto verticalEdge__ = verticalEdge ? _fbb.CreateString(verticalEdge) : 0;
  return flatbuffers::CreateLayoutComponentTable(
      _fbb,
      positionXPercentEnabled,
      positionYPercentEnabled,
      positionXPercent,
      positionYPercent,
      sizeXPercentEnable,
      sizeYPercentEnable,
      sizeXPercent,
      sizeYPercent,
      stretchHorizontalEnabled,
      stretchVerticalEnabled,
      horizontalEdge__,
      verticalEdge__,
      leftMargin,
      rightMargin,
      topMargin,
      bottomMargin);
}

struct SingleNodeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SingleNodeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           verifier.EndTable();
  }
};

struct SingleNodeOptionsBuilder {
  typedef SingleNodeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(SingleNodeOptions::VT_NODEOPTIONS, nodeOptions);
  }
  explicit SingleNodeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SingleNodeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SingleNodeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SingleNodeOptions> CreateSingleNodeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0) {
  SingleNodeOptionsBuilder builder_(_fbb);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

struct SpriteOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpriteOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_FILENAMEDATA = 6,
    VT_BLENDFUNC = 8,
    VT_INTELLISHADINGENABLED = 10,
    VT_HSV = 12,
    VT_FILTER = 14
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  const flatbuffers::BlendFunc *blendFunc() const {
    return GetStruct<const flatbuffers::BlendFunc *>(VT_BLENDFUNC);
  }
  bool intelliShadingEnabled() const {
    return GetField<uint8_t>(VT_INTELLISHADINGENABLED, 0) != 0;
  }
  const flatbuffers::FVec3 *hsv() const {
    return GetStruct<const flatbuffers::FVec3 *>(VT_HSV);
  }
  const flatbuffers::FVec3 *filter() const {
    return GetStruct<const flatbuffers::FVec3 *>(VT_FILTER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           VerifyField<flatbuffers::BlendFunc>(verifier, VT_BLENDFUNC, 4) &&
           VerifyField<uint8_t>(verifier, VT_INTELLISHADINGENABLED, 1) &&
           VerifyField<flatbuffers::FVec3>(verifier, VT_HSV, 4) &&
           VerifyField<flatbuffers::FVec3>(verifier, VT_FILTER, 4) &&
           verifier.EndTable();
  }
};

struct SpriteOptionsBuilder {
  typedef SpriteOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(SpriteOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(SpriteOptions::VT_FILENAMEDATA, fileNameData);
  }
  void add_blendFunc(const flatbuffers::BlendFunc *blendFunc) {
    fbb_.AddStruct(SpriteOptions::VT_BLENDFUNC, blendFunc);
  }
  void add_intelliShadingEnabled(bool intelliShadingEnabled) {
    fbb_.AddElement<uint8_t>(SpriteOptions::VT_INTELLISHADINGENABLED, static_cast<uint8_t>(intelliShadingEnabled), 0);
  }
  void add_hsv(const flatbuffers::FVec3 *hsv) {
    fbb_.AddStruct(SpriteOptions::VT_HSV, hsv);
  }
  void add_filter(const flatbuffers::FVec3 *filter) {
    fbb_.AddStruct(SpriteOptions::VT_FILTER, filter);
  }
  explicit SpriteOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpriteOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpriteOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpriteOptions> CreateSpriteOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0,
    const flatbuffers::BlendFunc *blendFunc = nullptr,
    bool intelliShadingEnabled = false,
    const flatbuffers::FVec3 *hsv = nullptr,
    const flatbuffers::FVec3 *filter = nullptr) {
  SpriteOptionsBuilder builder_(_fbb);
  builder_.add_filter(filter);
  builder_.add_hsv(hsv);
  builder_.add_blendFunc(blendFunc);
  builder_.add_fileNameData(fileNameData);
  builder_.add_nodeOptions(nodeOptions);
  builder_.add_intelliShadingEnabled(intelliShadingEnabled);
  return builder_.Finish();
}

struct ParticleSystemOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParticleSystemOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_FILENAMEDATA = 6,
    VT_BLENDFUNC = 8
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  const flatbuffers::BlendFunc *blendFunc() const {
    return GetStruct<const flatbuffers::BlendFunc *>(VT_BLENDFUNC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           VerifyField<flatbuffers::BlendFunc>(verifier, VT_BLENDFUNC, 4) &&
           verifier.EndTable();
  }
};

struct ParticleSystemOptionsBuilder {
  typedef ParticleSystemOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(ParticleSystemOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(ParticleSystemOptions::VT_FILENAMEDATA, fileNameData);
  }
  void add_blendFunc(const flatbuffers::BlendFunc *blendFunc) {
    fbb_.AddStruct(ParticleSystemOptions::VT_BLENDFUNC, blendFunc);
  }
  explicit ParticleSystemOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParticleSystemOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParticleSystemOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParticleSystemOptions> CreateParticleSystemOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0,
    const flatbuffers::BlendFunc *blendFunc = nullptr) {
  ParticleSystemOptionsBuilder builder_(_fbb);
  builder_.add_blendFunc(blendFunc);
  builder_.add_fileNameData(fileNameData);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

struct SpineSkeletonOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpineSkeletonOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_DATAFILE = 6,
    VT_ATLASFILE = 8,
    VT_ANIMATION = 10,
    VT_SKIN = 12,
    VT_LOOP = 14,
    VT_TIMESCALE = 16
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const ::flatbuffers::String *dataFile() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATAFILE);
  }
  const ::flatbuffers::String *atlasFile() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATLASFILE);
  }
  const ::flatbuffers::String *animation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANIMATION);
  }
  const ::flatbuffers::String *skin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SKIN);
  }
  bool loop() const {
    return GetField<uint8_t>(VT_LOOP, 0) != 0;
  }
  float timeScale() const {
    return GetField<float>(VT_TIMESCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_DATAFILE) &&
           verifier.VerifyString(dataFile()) &&
           VerifyOffset(verifier, VT_ATLASFILE) &&
           verifier.VerifyString(atlasFile()) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyString(animation()) &&
           VerifyOffset(verifier, VT_SKIN) &&
           verifier.VerifyString(skin()) &&
           VerifyField<uint8_t>(verifier, VT_LOOP, 1) &&
           VerifyField<float>(verifier, VT_TIMESCALE, 4) &&
           verifier.EndTable();
  }
};

struct SpineSkeletonOptionsBuilder {
  typedef SpineSkeletonOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(SpineSkeletonOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_dataFile(::flatbuffers::Offset<::flatbuffers::String> dataFile) {
    fbb_.AddOffset(SpineSkeletonOptions::VT_DATAFILE, dataFile);
  }
  void add_atlasFile(::flatbuffers::Offset<::flatbuffers::String> atlasFile) {
    fbb_.AddOffset(SpineSkeletonOptions::VT_ATLASFILE, atlasFile);
  }
  void add_animation(::flatbuffers::Offset<::flatbuffers::String> animation) {
    fbb_.AddOffset(SpineSkeletonOptions::VT_ANIMATION, animation);
  }
  void add_skin(::flatbuffers::Offset<::flatbuffers::String> skin) {
    fbb_.AddOffset(SpineSkeletonOptions::VT_SKIN, skin);
  }
  void add_loop(bool loop) {
    fbb_.AddElement<uint8_t>(SpineSkeletonOptions::VT_LOOP, static_cast<uint8_t>(loop), 0);
  }
  void add_timeScale(float timeScale) {
    fbb_.AddElement<float>(SpineSkeletonOptions::VT_TIMESCALE, timeScale, 0.0f);
  }
  explicit SpineSkeletonOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpineSkeletonOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpineSkeletonOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpineSkeletonOptions> CreateSpineSkeletonOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataFile = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atlasFile = 0,
    ::flatbuffers::Offset<::flatbuffers::String> animation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> skin = 0,
    bool loop = false,
    float timeScale = 0.0f) {
  SpineSkeletonOptionsBuilder builder_(_fbb);
  builder_.add_timeScale(timeScale);
  builder_.add_skin(skin);
  builder_.add_animation(animation);
  builder_.add_atlasFile(atlasFile);
  builder_.add_dataFile(dataFile);
  builder_.add_nodeOptions(nodeOptions);
  builder_.add_loop(loop);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SpineSkeletonOptions> CreateSpineSkeletonOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    const char *dataFile = nullptr,
    const char *atlasFile = nullptr,
    const char *animation = nullptr,
    const char *skin = nullptr,
    bool loop = false,
    float timeScale = 0.0f) {
  auto dataFile__ = dataFile ? _fbb.CreateString(dataFile) : 0;
  auto atlasFile__ = atlasFile ? _fbb.CreateString(atlasFile) : 0;
  auto animation__ = animation ? _fbb.CreateString(animation) : 0;
  auto skin__ = skin ? _fbb.CreateString(skin) : 0;
  return flatbuffers::CreateSpineSkeletonOptions(
      _fbb,
      nodeOptions,
      dataFile__,
      atlasFile__,
      animation__,
      skin__,
      loop,
      timeScale);
}

struct ControlSwitchOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ControlSwitchOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_MASKIMAGE = 6,
    VT_ONIMAGE = 8,
    VT_OFFIMAGE = 10,
    VT_THUMBIMAGE = 12,
    VT_ON = 14,
    VT_ENABLED = 16
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const flatbuffers::ResourceData *maskImage() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_MASKIMAGE);
  }
  const flatbuffers::ResourceData *onImage() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_ONIMAGE);
  }
  const flatbuffers::ResourceData *offImage() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_OFFIMAGE);
  }
  const flatbuffers::ResourceData *thumbImage() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_THUMBIMAGE);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_MASKIMAGE) &&
           verifier.VerifyTable(maskImage()) &&
           VerifyOffset(verifier, VT_ONIMAGE) &&
           verifier.VerifyTable(onImage()) &&
           VerifyOffset(verifier, VT_OFFIMAGE) &&
           verifier.VerifyTable(offImage()) &&
           VerifyOffset(verifier, VT_THUMBIMAGE) &&
           verifier.VerifyTable(thumbImage()) &&
           VerifyField<uint8_t>(verifier, VT_ON, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct ControlSwitchOptionsBuilder {
  typedef ControlSwitchOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(ControlSwitchOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_maskImage(::flatbuffers::Offset<flatbuffers::ResourceData> maskImage) {
    fbb_.AddOffset(ControlSwitchOptions::VT_MASKIMAGE, maskImage);
  }
  void add_onImage(::flatbuffers::Offset<flatbuffers::ResourceData> onImage) {
    fbb_.AddOffset(ControlSwitchOptions::VT_ONIMAGE, onImage);
  }
  void add_offImage(::flatbuffers::Offset<flatbuffers::ResourceData> offImage) {
    fbb_.AddOffset(ControlSwitchOptions::VT_OFFIMAGE, offImage);
  }
  void add_thumbImage(::flatbuffers::Offset<flatbuffers::ResourceData> thumbImage) {
    fbb_.AddOffset(ControlSwitchOptions::VT_THUMBIMAGE, thumbImage);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(ControlSwitchOptions::VT_ON, static_cast<uint8_t>(on), 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(ControlSwitchOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  explicit ControlSwitchOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ControlSwitchOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ControlSwitchOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ControlSwitchOptions> CreateControlSwitchOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> maskImage = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> onImage = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> offImage = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> thumbImage = 0,
    bool on = false,
    bool enabled = false) {
  ControlSwitchOptionsBuilder builder_(_fbb);
  builder_.add_thumbImage(thumbImage);
  builder_.add_offImage(offImage);
  builder_.add_onImage(onImage);
  builder_.add_maskImage(maskImage);
  builder_.add_nodeOptions(nodeOptions);
  builder_.add_enabled(enabled);
  builder_.add_on(on);
  return builder_.Finish();
}

struct LayerColorOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerColorOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           verifier.EndTable();
  }
};

struct LayerColorOptionsBuilder {
  typedef LayerColorOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(LayerColorOptions::VT_NODEOPTIONS, nodeOptions);
  }
  explicit LayerColorOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerColorOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerColorOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerColorOptions> CreateLayerColorOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0) {
  LayerColorOptionsBuilder builder_(_fbb);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

struct GameMapOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMapOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_FILENAMEDATA = 6
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           verifier.EndTable();
  }
};

struct GameMapOptionsBuilder {
  typedef GameMapOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(GameMapOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(GameMapOptions::VT_FILENAMEDATA, fileNameData);
  }
  explicit GameMapOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMapOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMapOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMapOptions> CreateGameMapOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0) {
  GameMapOptionsBuilder builder_(_fbb);
  builder_.add_fileNameData(fileNameData);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

struct ButtonOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ButtonOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_NORMALDATA = 6,
    VT_PRESSEDDATA = 8,
    VT_DISABLEDDATA = 10,
    VT_FONTRESOURCE = 12,
    VT_TEXT = 14,
    VT_FONTNAME = 16,
    VT_FONTSIZE = 18,
    VT_TEXTCOLOR = 20,
    VT_CAPINSETS = 22,
    VT_SCALE9SIZE = 24,
    VT_SCALE9ENABLED = 26,
    VT_DISPLAYSTATE = 28,
    VT_OUTLINEENABLED = 30,
    VT_OUTLINECOLOR = 32,
    VT_OUTLINESIZE = 34,
    VT_SHADOWENABLED = 36,
    VT_SHADOWCOLOR = 38,
    VT_SHADOWOFFSETX = 40,
    VT_SHADOWOFFSETY = 42,
    VT_SHADOWBLURRADIUS = 44,
    VT_ISLOCALIZED = 46,
    VT_GLOWENABLED = 48,
    VT_GLOWCOLOR = 50,
    VT_BOLDENABLED = 52,
    VT_UNDERLINEENABLED = 54,
    VT_ITALICSENABLED = 56,
    VT_STRIKETHROUGHENABLED = 58
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *normalData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_NORMALDATA);
  }
  const flatbuffers::ResourceData *pressedData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_PRESSEDDATA);
  }
  const flatbuffers::ResourceData *disabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_DISABLEDDATA);
  }
  const flatbuffers::ResourceData *fontResource() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FONTRESOURCE);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *fontName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONTNAME);
  }
  int32_t fontSize() const {
    return GetField<int32_t>(VT_FONTSIZE, 0);
  }
  const flatbuffers::FColor *textColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_TEXTCOLOR);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool scale9Enabled() const {
    return GetField<uint8_t>(VT_SCALE9ENABLED, 0) != 0;
  }
  bool displaystate() const {
    return GetField<uint8_t>(VT_DISPLAYSTATE, 1) != 0;
  }
  bool outlineEnabled() const {
    return GetField<uint8_t>(VT_OUTLINEENABLED, 0) != 0;
  }
  const flatbuffers::FColor *outlineColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_OUTLINECOLOR);
  }
  int32_t outlineSize() const {
    return GetField<int32_t>(VT_OUTLINESIZE, 1);
  }
  bool shadowEnabled() const {
    return GetField<uint8_t>(VT_SHADOWENABLED, 0) != 0;
  }
  const flatbuffers::FColor *shadowColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_SHADOWCOLOR);
  }
  float shadowOffsetX() const {
    return GetField<float>(VT_SHADOWOFFSETX, 2.0f);
  }
  float shadowOffsetY() const {
    return GetField<float>(VT_SHADOWOFFSETY, -2.0f);
  }
  int32_t shadowBlurRadius() const {
    return GetField<int32_t>(VT_SHADOWBLURRADIUS, 0);
  }
  bool isLocalized() const {
    return GetField<uint8_t>(VT_ISLOCALIZED, 0) != 0;
  }
  bool glowEnabled() const {
    return GetField<uint8_t>(VT_GLOWENABLED, 0) != 0;
  }
  const flatbuffers::FColor *glowColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_GLOWCOLOR);
  }
  bool boldEnabled() const {
    return GetField<uint8_t>(VT_BOLDENABLED, 0) != 0;
  }
  bool underlineEnabled() const {
    return GetField<uint8_t>(VT_UNDERLINEENABLED, 0) != 0;
  }
  bool italicsEnabled() const {
    return GetField<uint8_t>(VT_ITALICSENABLED, 0) != 0;
  }
  bool strikethroughEnabled() const {
    return GetField<uint8_t>(VT_STRIKETHROUGHENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_NORMALDATA) &&
           verifier.VerifyTable(normalData()) &&
           VerifyOffset(verifier, VT_PRESSEDDATA) &&
           verifier.VerifyTable(pressedData()) &&
           VerifyOffset(verifier, VT_DISABLEDDATA) &&
           verifier.VerifyTable(disabledData()) &&
           VerifyOffset(verifier, VT_FONTRESOURCE) &&
           verifier.VerifyTable(fontResource()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(fontName()) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE, 4) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_TEXTCOLOR, 1) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SCALE9ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DISPLAYSTATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTLINEENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_OUTLINECOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_OUTLINESIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_SHADOWCOLOR, 1) &&
           VerifyField<float>(verifier, VT_SHADOWOFFSETX, 4) &&
           VerifyField<float>(verifier, VT_SHADOWOFFSETY, 4) &&
           VerifyField<int32_t>(verifier, VT_SHADOWBLURRADIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCALIZED, 1) &&
           VerifyField<uint8_t>(verifier, VT_GLOWENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_GLOWCOLOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_BOLDENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_UNDERLINEENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ITALICSENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_STRIKETHROUGHENABLED, 1) &&
           verifier.EndTable();
  }
};

struct ButtonOptionsBuilder {
  typedef ButtonOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(ButtonOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_normalData(::flatbuffers::Offset<flatbuffers::ResourceData> normalData) {
    fbb_.AddOffset(ButtonOptions::VT_NORMALDATA, normalData);
  }
  void add_pressedData(::flatbuffers::Offset<flatbuffers::ResourceData> pressedData) {
    fbb_.AddOffset(ButtonOptions::VT_PRESSEDDATA, pressedData);
  }
  void add_disabledData(::flatbuffers::Offset<flatbuffers::ResourceData> disabledData) {
    fbb_.AddOffset(ButtonOptions::VT_DISABLEDDATA, disabledData);
  }
  void add_fontResource(::flatbuffers::Offset<flatbuffers::ResourceData> fontResource) {
    fbb_.AddOffset(ButtonOptions::VT_FONTRESOURCE, fontResource);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(ButtonOptions::VT_TEXT, text);
  }
  void add_fontName(::flatbuffers::Offset<::flatbuffers::String> fontName) {
    fbb_.AddOffset(ButtonOptions::VT_FONTNAME, fontName);
  }
  void add_fontSize(int32_t fontSize) {
    fbb_.AddElement<int32_t>(ButtonOptions::VT_FONTSIZE, fontSize, 0);
  }
  void add_textColor(const flatbuffers::FColor *textColor) {
    fbb_.AddStruct(ButtonOptions::VT_TEXTCOLOR, textColor);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(ButtonOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(ButtonOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_scale9Enabled(bool scale9Enabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_SCALE9ENABLED, static_cast<uint8_t>(scale9Enabled), 0);
  }
  void add_displaystate(bool displaystate) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_DISPLAYSTATE, static_cast<uint8_t>(displaystate), 1);
  }
  void add_outlineEnabled(bool outlineEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_OUTLINEENABLED, static_cast<uint8_t>(outlineEnabled), 0);
  }
  void add_outlineColor(const flatbuffers::FColor *outlineColor) {
    fbb_.AddStruct(ButtonOptions::VT_OUTLINECOLOR, outlineColor);
  }
  void add_outlineSize(int32_t outlineSize) {
    fbb_.AddElement<int32_t>(ButtonOptions::VT_OUTLINESIZE, outlineSize, 1);
  }
  void add_shadowEnabled(bool shadowEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_SHADOWENABLED, static_cast<uint8_t>(shadowEnabled), 0);
  }
  void add_shadowColor(const flatbuffers::FColor *shadowColor) {
    fbb_.AddStruct(ButtonOptions::VT_SHADOWCOLOR, shadowColor);
  }
  void add_shadowOffsetX(float shadowOffsetX) {
    fbb_.AddElement<float>(ButtonOptions::VT_SHADOWOFFSETX, shadowOffsetX, 2.0f);
  }
  void add_shadowOffsetY(float shadowOffsetY) {
    fbb_.AddElement<float>(ButtonOptions::VT_SHADOWOFFSETY, shadowOffsetY, -2.0f);
  }
  void add_shadowBlurRadius(int32_t shadowBlurRadius) {
    fbb_.AddElement<int32_t>(ButtonOptions::VT_SHADOWBLURRADIUS, shadowBlurRadius, 0);
  }
  void add_isLocalized(bool isLocalized) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_ISLOCALIZED, static_cast<uint8_t>(isLocalized), 0);
  }
  void add_glowEnabled(bool glowEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_GLOWENABLED, static_cast<uint8_t>(glowEnabled), 0);
  }
  void add_glowColor(const flatbuffers::FColor *glowColor) {
    fbb_.AddStruct(ButtonOptions::VT_GLOWCOLOR, glowColor);
  }
  void add_boldEnabled(bool boldEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_BOLDENABLED, static_cast<uint8_t>(boldEnabled), 0);
  }
  void add_underlineEnabled(bool underlineEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_UNDERLINEENABLED, static_cast<uint8_t>(underlineEnabled), 0);
  }
  void add_italicsEnabled(bool italicsEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_ITALICSENABLED, static_cast<uint8_t>(italicsEnabled), 0);
  }
  void add_strikethroughEnabled(bool strikethroughEnabled) {
    fbb_.AddElement<uint8_t>(ButtonOptions::VT_STRIKETHROUGHENABLED, static_cast<uint8_t>(strikethroughEnabled), 0);
  }
  explicit ButtonOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ButtonOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ButtonOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ButtonOptions> CreateButtonOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> normalData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> pressedData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> disabledData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fontName = 0,
    int32_t fontSize = 0,
    const flatbuffers::FColor *textColor = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool scale9Enabled = false,
    bool displaystate = true,
    bool outlineEnabled = false,
    const flatbuffers::FColor *outlineColor = nullptr,
    int32_t outlineSize = 1,
    bool shadowEnabled = false,
    const flatbuffers::FColor *shadowColor = nullptr,
    float shadowOffsetX = 2.0f,
    float shadowOffsetY = -2.0f,
    int32_t shadowBlurRadius = 0,
    bool isLocalized = false,
    bool glowEnabled = false,
    const flatbuffers::FColor *glowColor = nullptr,
    bool boldEnabled = false,
    bool underlineEnabled = false,
    bool italicsEnabled = false,
    bool strikethroughEnabled = false) {
  ButtonOptionsBuilder builder_(_fbb);
  builder_.add_glowColor(glowColor);
  builder_.add_shadowBlurRadius(shadowBlurRadius);
  builder_.add_shadowOffsetY(shadowOffsetY);
  builder_.add_shadowOffsetX(shadowOffsetX);
  builder_.add_shadowColor(shadowColor);
  builder_.add_outlineSize(outlineSize);
  builder_.add_outlineColor(outlineColor);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_textColor(textColor);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_text(text);
  builder_.add_fontResource(fontResource);
  builder_.add_disabledData(disabledData);
  builder_.add_pressedData(pressedData);
  builder_.add_normalData(normalData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_strikethroughEnabled(strikethroughEnabled);
  builder_.add_italicsEnabled(italicsEnabled);
  builder_.add_underlineEnabled(underlineEnabled);
  builder_.add_boldEnabled(boldEnabled);
  builder_.add_glowEnabled(glowEnabled);
  builder_.add_isLocalized(isLocalized);
  builder_.add_shadowEnabled(shadowEnabled);
  builder_.add_outlineEnabled(outlineEnabled);
  builder_.add_displaystate(displaystate);
  builder_.add_scale9Enabled(scale9Enabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ButtonOptions> CreateButtonOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> normalData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> pressedData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> disabledData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    const char *text = nullptr,
    const char *fontName = nullptr,
    int32_t fontSize = 0,
    const flatbuffers::FColor *textColor = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool scale9Enabled = false,
    bool displaystate = true,
    bool outlineEnabled = false,
    const flatbuffers::FColor *outlineColor = nullptr,
    int32_t outlineSize = 1,
    bool shadowEnabled = false,
    const flatbuffers::FColor *shadowColor = nullptr,
    float shadowOffsetX = 2.0f,
    float shadowOffsetY = -2.0f,
    int32_t shadowBlurRadius = 0,
    bool isLocalized = false,
    bool glowEnabled = false,
    const flatbuffers::FColor *glowColor = nullptr,
    bool boldEnabled = false,
    bool underlineEnabled = false,
    bool italicsEnabled = false,
    bool strikethroughEnabled = false) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto fontName__ = fontName ? _fbb.CreateString(fontName) : 0;
  return flatbuffers::CreateButtonOptions(
      _fbb,
      widgetOptions,
      normalData,
      pressedData,
      disabledData,
      fontResource,
      text__,
      fontName__,
      fontSize,
      textColor,
      capInsets,
      scale9Size,
      scale9Enabled,
      displaystate,
      outlineEnabled,
      outlineColor,
      outlineSize,
      shadowEnabled,
      shadowColor,
      shadowOffsetX,
      shadowOffsetY,
      shadowBlurRadius,
      isLocalized,
      glowEnabled,
      glowColor,
      boldEnabled,
      underlineEnabled,
      italicsEnabled,
      strikethroughEnabled);
}

struct CheckBoxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CheckBoxOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDBOXDATA = 6,
    VT_BACKGROUNDBOXSELECTEDDATA = 8,
    VT_FRONTCROSSDATA = 10,
    VT_BACKGROUNDBOXDISABLEDDATA = 12,
    VT_FRONTCROSSDISABLEDDATA = 14,
    VT_SELECTEDSTATE = 16,
    VT_DISPLAYSTATE = 18
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundBoxData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXDATA);
  }
  const flatbuffers::ResourceData *backGroundBoxSelectedData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXSELECTEDDATA);
  }
  const flatbuffers::ResourceData *frontCrossData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FRONTCROSSDATA);
  }
  const flatbuffers::ResourceData *backGroundBoxDisabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXDISABLEDDATA);
  }
  const flatbuffers::ResourceData *frontCrossDisabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FRONTCROSSDISABLEDDATA);
  }
  bool selectedState() const {
    return GetField<uint8_t>(VT_SELECTEDSTATE, 1) != 0;
  }
  bool displaystate() const {
    return GetField<uint8_t>(VT_DISPLAYSTATE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXDATA) &&
           verifier.VerifyTable(backGroundBoxData()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXSELECTEDDATA) &&
           verifier.VerifyTable(backGroundBoxSelectedData()) &&
           VerifyOffset(verifier, VT_FRONTCROSSDATA) &&
           verifier.VerifyTable(frontCrossData()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXDISABLEDDATA) &&
           verifier.VerifyTable(backGroundBoxDisabledData()) &&
           VerifyOffset(verifier, VT_FRONTCROSSDISABLEDDATA) &&
           verifier.VerifyTable(frontCrossDisabledData()) &&
           VerifyField<uint8_t>(verifier, VT_SELECTEDSTATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DISPLAYSTATE, 1) &&
           verifier.EndTable();
  }
};

struct CheckBoxOptionsBuilder {
  typedef CheckBoxOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(CheckBoxOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundBoxData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxData) {
    fbb_.AddOffset(CheckBoxOptions::VT_BACKGROUNDBOXDATA, backGroundBoxData);
  }
  void add_backGroundBoxSelectedData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxSelectedData) {
    fbb_.AddOffset(CheckBoxOptions::VT_BACKGROUNDBOXSELECTEDDATA, backGroundBoxSelectedData);
  }
  void add_frontCrossData(::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossData) {
    fbb_.AddOffset(CheckBoxOptions::VT_FRONTCROSSDATA, frontCrossData);
  }
  void add_backGroundBoxDisabledData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxDisabledData) {
    fbb_.AddOffset(CheckBoxOptions::VT_BACKGROUNDBOXDISABLEDDATA, backGroundBoxDisabledData);
  }
  void add_frontCrossDisabledData(::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossDisabledData) {
    fbb_.AddOffset(CheckBoxOptions::VT_FRONTCROSSDISABLEDDATA, frontCrossDisabledData);
  }
  void add_selectedState(bool selectedState) {
    fbb_.AddElement<uint8_t>(CheckBoxOptions::VT_SELECTEDSTATE, static_cast<uint8_t>(selectedState), 1);
  }
  void add_displaystate(bool displaystate) {
    fbb_.AddElement<uint8_t>(CheckBoxOptions::VT_DISPLAYSTATE, static_cast<uint8_t>(displaystate), 1);
  }
  explicit CheckBoxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CheckBoxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CheckBoxOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CheckBoxOptions> CreateCheckBoxOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxSelectedData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxDisabledData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossDisabledData = 0,
    bool selectedState = true,
    bool displaystate = true) {
  CheckBoxOptionsBuilder builder_(_fbb);
  builder_.add_frontCrossDisabledData(frontCrossDisabledData);
  builder_.add_backGroundBoxDisabledData(backGroundBoxDisabledData);
  builder_.add_frontCrossData(frontCrossData);
  builder_.add_backGroundBoxSelectedData(backGroundBoxSelectedData);
  builder_.add_backGroundBoxData(backGroundBoxData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_displaystate(displaystate);
  builder_.add_selectedState(selectedState);
  return builder_.Finish();
}

struct RadioButtonOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadioButtonOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDBOXDATA = 6,
    VT_BACKGROUNDBOXSELECTEDDATA = 8,
    VT_FRONTCROSSDATA = 10,
    VT_BACKGROUNDBOXDISABLEDDATA = 12,
    VT_FRONTCROSSDISABLEDDATA = 14,
    VT_SELECTEDSTATE = 16,
    VT_DISPLAYSTATE = 18
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundBoxData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXDATA);
  }
  const flatbuffers::ResourceData *backGroundBoxSelectedData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXSELECTEDDATA);
  }
  const flatbuffers::ResourceData *frontCrossData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FRONTCROSSDATA);
  }
  const flatbuffers::ResourceData *backGroundBoxDisabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDBOXDISABLEDDATA);
  }
  const flatbuffers::ResourceData *frontCrossDisabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FRONTCROSSDISABLEDDATA);
  }
  bool selectedState() const {
    return GetField<uint8_t>(VT_SELECTEDSTATE, 0) != 0;
  }
  bool displaystate() const {
    return GetField<uint8_t>(VT_DISPLAYSTATE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXDATA) &&
           verifier.VerifyTable(backGroundBoxData()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXSELECTEDDATA) &&
           verifier.VerifyTable(backGroundBoxSelectedData()) &&
           VerifyOffset(verifier, VT_FRONTCROSSDATA) &&
           verifier.VerifyTable(frontCrossData()) &&
           VerifyOffset(verifier, VT_BACKGROUNDBOXDISABLEDDATA) &&
           verifier.VerifyTable(backGroundBoxDisabledData()) &&
           VerifyOffset(verifier, VT_FRONTCROSSDISABLEDDATA) &&
           verifier.VerifyTable(frontCrossDisabledData()) &&
           VerifyField<uint8_t>(verifier, VT_SELECTEDSTATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DISPLAYSTATE, 1) &&
           verifier.EndTable();
  }
};

struct RadioButtonOptionsBuilder {
  typedef RadioButtonOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(RadioButtonOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundBoxData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxData) {
    fbb_.AddOffset(RadioButtonOptions::VT_BACKGROUNDBOXDATA, backGroundBoxData);
  }
  void add_backGroundBoxSelectedData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxSelectedData) {
    fbb_.AddOffset(RadioButtonOptions::VT_BACKGROUNDBOXSELECTEDDATA, backGroundBoxSelectedData);
  }
  void add_frontCrossData(::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossData) {
    fbb_.AddOffset(RadioButtonOptions::VT_FRONTCROSSDATA, frontCrossData);
  }
  void add_backGroundBoxDisabledData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxDisabledData) {
    fbb_.AddOffset(RadioButtonOptions::VT_BACKGROUNDBOXDISABLEDDATA, backGroundBoxDisabledData);
  }
  void add_frontCrossDisabledData(::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossDisabledData) {
    fbb_.AddOffset(RadioButtonOptions::VT_FRONTCROSSDISABLEDDATA, frontCrossDisabledData);
  }
  void add_selectedState(bool selectedState) {
    fbb_.AddElement<uint8_t>(RadioButtonOptions::VT_SELECTEDSTATE, static_cast<uint8_t>(selectedState), 0);
  }
  void add_displaystate(bool displaystate) {
    fbb_.AddElement<uint8_t>(RadioButtonOptions::VT_DISPLAYSTATE, static_cast<uint8_t>(displaystate), 0);
  }
  explicit RadioButtonOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadioButtonOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadioButtonOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadioButtonOptions> CreateRadioButtonOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxSelectedData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundBoxDisabledData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> frontCrossDisabledData = 0,
    bool selectedState = false,
    bool displaystate = false) {
  RadioButtonOptionsBuilder builder_(_fbb);
  builder_.add_frontCrossDisabledData(frontCrossDisabledData);
  builder_.add_backGroundBoxDisabledData(backGroundBoxDisabledData);
  builder_.add_frontCrossData(frontCrossData);
  builder_.add_backGroundBoxSelectedData(backGroundBoxSelectedData);
  builder_.add_backGroundBoxData(backGroundBoxData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_displaystate(displaystate);
  builder_.add_selectedState(selectedState);
  return builder_.Finish();
}

struct RadioButtonGroupOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadioButtonGroupOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_ALLOWEDNOSELECTION = 6
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  bool allowedNoSelection() const {
    return GetField<uint8_t>(VT_ALLOWEDNOSELECTION, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyField<uint8_t>(verifier, VT_ALLOWEDNOSELECTION, 1) &&
           verifier.EndTable();
  }
};

struct RadioButtonGroupOptionsBuilder {
  typedef RadioButtonGroupOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(RadioButtonGroupOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_allowedNoSelection(bool allowedNoSelection) {
    fbb_.AddElement<uint8_t>(RadioButtonGroupOptions::VT_ALLOWEDNOSELECTION, static_cast<uint8_t>(allowedNoSelection), 0);
  }
  explicit RadioButtonGroupOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadioButtonGroupOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadioButtonGroupOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadioButtonGroupOptions> CreateRadioButtonGroupOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    bool allowedNoSelection = false) {
  RadioButtonGroupOptionsBuilder builder_(_fbb);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_allowedNoSelection(allowedNoSelection);
  return builder_.Finish();
}

struct ImageViewOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageViewOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_FILENAMEDATA = 6,
    VT_CAPINSETS = 8,
    VT_SCALE9SIZE = 10,
    VT_SCALE9ENABLED = 12
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool scale9Enabled() const {
    return GetField<uint8_t>(VT_SCALE9ENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SCALE9ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct ImageViewOptionsBuilder {
  typedef ImageViewOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(ImageViewOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(ImageViewOptions::VT_FILENAMEDATA, fileNameData);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(ImageViewOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(ImageViewOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_scale9Enabled(bool scale9Enabled) {
    fbb_.AddElement<uint8_t>(ImageViewOptions::VT_SCALE9ENABLED, static_cast<uint8_t>(scale9Enabled), 0);
  }
  explicit ImageViewOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageViewOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageViewOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageViewOptions> CreateImageViewOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool scale9Enabled = false) {
  ImageViewOptionsBuilder builder_(_fbb);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_fileNameData(fileNameData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_scale9Enabled(scale9Enabled);
  return builder_.Finish();
}

struct TextAtlasOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextAtlasOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_CHARMAPFILEDATA = 6,
    VT_STRINGVALUE = 8,
    VT_STARTCHARMAP = 10,
    VT_ITEMWIDTH = 12,
    VT_ITEMHEIGHT = 14
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *charMapFileData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_CHARMAPFILEDATA);
  }
  const ::flatbuffers::String *stringValue() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRINGVALUE);
  }
  const ::flatbuffers::String *startCharMap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARTCHARMAP);
  }
  int32_t itemWidth() const {
    return GetField<int32_t>(VT_ITEMWIDTH, 0);
  }
  int32_t itemHeight() const {
    return GetField<int32_t>(VT_ITEMHEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_CHARMAPFILEDATA) &&
           verifier.VerifyTable(charMapFileData()) &&
           VerifyOffset(verifier, VT_STRINGVALUE) &&
           verifier.VerifyString(stringValue()) &&
           VerifyOffset(verifier, VT_STARTCHARMAP) &&
           verifier.VerifyString(startCharMap()) &&
           VerifyField<int32_t>(verifier, VT_ITEMWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEMHEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct TextAtlasOptionsBuilder {
  typedef TextAtlasOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(TextAtlasOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_charMapFileData(::flatbuffers::Offset<flatbuffers::ResourceData> charMapFileData) {
    fbb_.AddOffset(TextAtlasOptions::VT_CHARMAPFILEDATA, charMapFileData);
  }
  void add_stringValue(::flatbuffers::Offset<::flatbuffers::String> stringValue) {
    fbb_.AddOffset(TextAtlasOptions::VT_STRINGVALUE, stringValue);
  }
  void add_startCharMap(::flatbuffers::Offset<::flatbuffers::String> startCharMap) {
    fbb_.AddOffset(TextAtlasOptions::VT_STARTCHARMAP, startCharMap);
  }
  void add_itemWidth(int32_t itemWidth) {
    fbb_.AddElement<int32_t>(TextAtlasOptions::VT_ITEMWIDTH, itemWidth, 0);
  }
  void add_itemHeight(int32_t itemHeight) {
    fbb_.AddElement<int32_t>(TextAtlasOptions::VT_ITEMHEIGHT, itemHeight, 0);
  }
  explicit TextAtlasOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextAtlasOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextAtlasOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextAtlasOptions> CreateTextAtlasOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> charMapFileData = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stringValue = 0,
    ::flatbuffers::Offset<::flatbuffers::String> startCharMap = 0,
    int32_t itemWidth = 0,
    int32_t itemHeight = 0) {
  TextAtlasOptionsBuilder builder_(_fbb);
  builder_.add_itemHeight(itemHeight);
  builder_.add_itemWidth(itemWidth);
  builder_.add_startCharMap(startCharMap);
  builder_.add_stringValue(stringValue);
  builder_.add_charMapFileData(charMapFileData);
  builder_.add_widgetOptions(widgetOptions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextAtlasOptions> CreateTextAtlasOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> charMapFileData = 0,
    const char *stringValue = nullptr,
    const char *startCharMap = nullptr,
    int32_t itemWidth = 0,
    int32_t itemHeight = 0) {
  auto stringValue__ = stringValue ? _fbb.CreateString(stringValue) : 0;
  auto startCharMap__ = startCharMap ? _fbb.CreateString(startCharMap) : 0;
  return flatbuffers::CreateTextAtlasOptions(
      _fbb,
      widgetOptions,
      charMapFileData,
      stringValue__,
      startCharMap__,
      itemWidth,
      itemHeight);
}

struct TextBMFontOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextBMFontOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_FILENAMEDATA = 6,
    VT_TEXT = 8,
    VT_ISLOCALIZED = 10
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool isLocalized() const {
    return GetField<uint8_t>(VT_ISLOCALIZED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCALIZED, 1) &&
           verifier.EndTable();
  }
};

struct TextBMFontOptionsBuilder {
  typedef TextBMFontOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(TextBMFontOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(TextBMFontOptions::VT_FILENAMEDATA, fileNameData);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextBMFontOptions::VT_TEXT, text);
  }
  void add_isLocalized(bool isLocalized) {
    fbb_.AddElement<uint8_t>(TextBMFontOptions::VT_ISLOCALIZED, static_cast<uint8_t>(isLocalized), 0);
  }
  explicit TextBMFontOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextBMFontOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextBMFontOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextBMFontOptions> CreateTextBMFontOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    bool isLocalized = false) {
  TextBMFontOptionsBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_fileNameData(fileNameData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_isLocalized(isLocalized);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextBMFontOptions> CreateTextBMFontOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0,
    const char *text = nullptr,
    bool isLocalized = false) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return flatbuffers::CreateTextBMFontOptions(
      _fbb,
      widgetOptions,
      fileNameData,
      text__,
      isLocalized);
}

struct TextOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_FONTRESOURCE = 6,
    VT_FONTNAME = 8,
    VT_FONTSIZE = 10,
    VT_TEXT = 12,
    VT_AREAWIDTH = 14,
    VT_AREAHEIGHT = 16,
    VT_HALIGNMENT = 18,
    VT_VALIGNMENT = 20,
    VT_TOUCHSCALEENABLE = 22,
    VT_ISCUSTOMSIZE = 24,
    VT_OUTLINEENABLED = 26,
    VT_OUTLINECOLOR = 28,
    VT_OUTLINESIZE = 30,
    VT_SHADOWENABLED = 32,
    VT_SHADOWCOLOR = 34,
    VT_SHADOWOFFSETX = 36,
    VT_SHADOWOFFSETY = 38,
    VT_SHADOWBLURRADIUS = 40,
    VT_ISLOCALIZED = 42,
    VT_GLOWENABLED = 44,
    VT_GLOWCOLOR = 46,
    VT_BOLDENABLED = 48,
    VT_UNDERLINEENABLED = 50,
    VT_ITALICSENABLED = 52,
    VT_STRIKETHROUGHENABLED = 54
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *fontResource() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FONTRESOURCE);
  }
  const ::flatbuffers::String *fontName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONTNAME);
  }
  int32_t fontSize() const {
    return GetField<int32_t>(VT_FONTSIZE, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  int32_t areaWidth() const {
    return GetField<int32_t>(VT_AREAWIDTH, 0);
  }
  int32_t areaHeight() const {
    return GetField<int32_t>(VT_AREAHEIGHT, 0);
  }
  int32_t hAlignment() const {
    return GetField<int32_t>(VT_HALIGNMENT, 0);
  }
  int32_t vAlignment() const {
    return GetField<int32_t>(VT_VALIGNMENT, 0);
  }
  bool touchScaleEnable() const {
    return GetField<uint8_t>(VT_TOUCHSCALEENABLE, 0) != 0;
  }
  bool isCustomSize() const {
    return GetField<uint8_t>(VT_ISCUSTOMSIZE, 0) != 0;
  }
  bool outlineEnabled() const {
    return GetField<uint8_t>(VT_OUTLINEENABLED, 0) != 0;
  }
  const flatbuffers::FColor *outlineColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_OUTLINECOLOR);
  }
  int32_t outlineSize() const {
    return GetField<int32_t>(VT_OUTLINESIZE, 1);
  }
  bool shadowEnabled() const {
    return GetField<uint8_t>(VT_SHADOWENABLED, 0) != 0;
  }
  const flatbuffers::FColor *shadowColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_SHADOWCOLOR);
  }
  float shadowOffsetX() const {
    return GetField<float>(VT_SHADOWOFFSETX, 2.0f);
  }
  float shadowOffsetY() const {
    return GetField<float>(VT_SHADOWOFFSETY, -2.0f);
  }
  int32_t shadowBlurRadius() const {
    return GetField<int32_t>(VT_SHADOWBLURRADIUS, 0);
  }
  bool isLocalized() const {
    return GetField<uint8_t>(VT_ISLOCALIZED, 0) != 0;
  }
  bool glowEnabled() const {
    return GetField<uint8_t>(VT_GLOWENABLED, 0) != 0;
  }
  const flatbuffers::FColor *glowColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_GLOWCOLOR);
  }
  bool boldEnabled() const {
    return GetField<uint8_t>(VT_BOLDENABLED, 0) != 0;
  }
  bool underlineEnabled() const {
    return GetField<uint8_t>(VT_UNDERLINEENABLED, 0) != 0;
  }
  bool italicsEnabled() const {
    return GetField<uint8_t>(VT_ITALICSENABLED, 0) != 0;
  }
  bool strikethroughEnabled() const {
    return GetField<uint8_t>(VT_STRIKETHROUGHENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_FONTRESOURCE) &&
           verifier.VerifyTable(fontResource()) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(fontName()) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<int32_t>(verifier, VT_AREAWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_AREAHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_HALIGNMENT, 4) &&
           VerifyField<int32_t>(verifier, VT_VALIGNMENT, 4) &&
           VerifyField<uint8_t>(verifier, VT_TOUCHSCALEENABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISCUSTOMSIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTLINEENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_OUTLINECOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_OUTLINESIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_SHADOWCOLOR, 1) &&
           VerifyField<float>(verifier, VT_SHADOWOFFSETX, 4) &&
           VerifyField<float>(verifier, VT_SHADOWOFFSETY, 4) &&
           VerifyField<int32_t>(verifier, VT_SHADOWBLURRADIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCALIZED, 1) &&
           VerifyField<uint8_t>(verifier, VT_GLOWENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_GLOWCOLOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_BOLDENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_UNDERLINEENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ITALICSENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_STRIKETHROUGHENABLED, 1) &&
           verifier.EndTable();
  }
};

struct TextOptionsBuilder {
  typedef TextOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(TextOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_fontResource(::flatbuffers::Offset<flatbuffers::ResourceData> fontResource) {
    fbb_.AddOffset(TextOptions::VT_FONTRESOURCE, fontResource);
  }
  void add_fontName(::flatbuffers::Offset<::flatbuffers::String> fontName) {
    fbb_.AddOffset(TextOptions::VT_FONTNAME, fontName);
  }
  void add_fontSize(int32_t fontSize) {
    fbb_.AddElement<int32_t>(TextOptions::VT_FONTSIZE, fontSize, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextOptions::VT_TEXT, text);
  }
  void add_areaWidth(int32_t areaWidth) {
    fbb_.AddElement<int32_t>(TextOptions::VT_AREAWIDTH, areaWidth, 0);
  }
  void add_areaHeight(int32_t areaHeight) {
    fbb_.AddElement<int32_t>(TextOptions::VT_AREAHEIGHT, areaHeight, 0);
  }
  void add_hAlignment(int32_t hAlignment) {
    fbb_.AddElement<int32_t>(TextOptions::VT_HALIGNMENT, hAlignment, 0);
  }
  void add_vAlignment(int32_t vAlignment) {
    fbb_.AddElement<int32_t>(TextOptions::VT_VALIGNMENT, vAlignment, 0);
  }
  void add_touchScaleEnable(bool touchScaleEnable) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_TOUCHSCALEENABLE, static_cast<uint8_t>(touchScaleEnable), 0);
  }
  void add_isCustomSize(bool isCustomSize) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_ISCUSTOMSIZE, static_cast<uint8_t>(isCustomSize), 0);
  }
  void add_outlineEnabled(bool outlineEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_OUTLINEENABLED, static_cast<uint8_t>(outlineEnabled), 0);
  }
  void add_outlineColor(const flatbuffers::FColor *outlineColor) {
    fbb_.AddStruct(TextOptions::VT_OUTLINECOLOR, outlineColor);
  }
  void add_outlineSize(int32_t outlineSize) {
    fbb_.AddElement<int32_t>(TextOptions::VT_OUTLINESIZE, outlineSize, 1);
  }
  void add_shadowEnabled(bool shadowEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_SHADOWENABLED, static_cast<uint8_t>(shadowEnabled), 0);
  }
  void add_shadowColor(const flatbuffers::FColor *shadowColor) {
    fbb_.AddStruct(TextOptions::VT_SHADOWCOLOR, shadowColor);
  }
  void add_shadowOffsetX(float shadowOffsetX) {
    fbb_.AddElement<float>(TextOptions::VT_SHADOWOFFSETX, shadowOffsetX, 2.0f);
  }
  void add_shadowOffsetY(float shadowOffsetY) {
    fbb_.AddElement<float>(TextOptions::VT_SHADOWOFFSETY, shadowOffsetY, -2.0f);
  }
  void add_shadowBlurRadius(int32_t shadowBlurRadius) {
    fbb_.AddElement<int32_t>(TextOptions::VT_SHADOWBLURRADIUS, shadowBlurRadius, 0);
  }
  void add_isLocalized(bool isLocalized) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_ISLOCALIZED, static_cast<uint8_t>(isLocalized), 0);
  }
  void add_glowEnabled(bool glowEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_GLOWENABLED, static_cast<uint8_t>(glowEnabled), 0);
  }
  void add_glowColor(const flatbuffers::FColor *glowColor) {
    fbb_.AddStruct(TextOptions::VT_GLOWCOLOR, glowColor);
  }
  void add_boldEnabled(bool boldEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_BOLDENABLED, static_cast<uint8_t>(boldEnabled), 0);
  }
  void add_underlineEnabled(bool underlineEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_UNDERLINEENABLED, static_cast<uint8_t>(underlineEnabled), 0);
  }
  void add_italicsEnabled(bool italicsEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_ITALICSENABLED, static_cast<uint8_t>(italicsEnabled), 0);
  }
  void add_strikethroughEnabled(bool strikethroughEnabled) {
    fbb_.AddElement<uint8_t>(TextOptions::VT_STRIKETHROUGHENABLED, static_cast<uint8_t>(strikethroughEnabled), 0);
  }
  explicit TextOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextOptions> CreateTextOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fontName = 0,
    int32_t fontSize = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    int32_t areaWidth = 0,
    int32_t areaHeight = 0,
    int32_t hAlignment = 0,
    int32_t vAlignment = 0,
    bool touchScaleEnable = false,
    bool isCustomSize = false,
    bool outlineEnabled = false,
    const flatbuffers::FColor *outlineColor = nullptr,
    int32_t outlineSize = 1,
    bool shadowEnabled = false,
    const flatbuffers::FColor *shadowColor = nullptr,
    float shadowOffsetX = 2.0f,
    float shadowOffsetY = -2.0f,
    int32_t shadowBlurRadius = 0,
    bool isLocalized = false,
    bool glowEnabled = false,
    const flatbuffers::FColor *glowColor = nullptr,
    bool boldEnabled = false,
    bool underlineEnabled = false,
    bool italicsEnabled = false,
    bool strikethroughEnabled = false) {
  TextOptionsBuilder builder_(_fbb);
  builder_.add_glowColor(glowColor);
  builder_.add_shadowBlurRadius(shadowBlurRadius);
  builder_.add_shadowOffsetY(shadowOffsetY);
  builder_.add_shadowOffsetX(shadowOffsetX);
  builder_.add_shadowColor(shadowColor);
  builder_.add_outlineSize(outlineSize);
  builder_.add_outlineColor(outlineColor);
  builder_.add_vAlignment(vAlignment);
  builder_.add_hAlignment(hAlignment);
  builder_.add_areaHeight(areaHeight);
  builder_.add_areaWidth(areaWidth);
  builder_.add_text(text);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_fontResource(fontResource);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_strikethroughEnabled(strikethroughEnabled);
  builder_.add_italicsEnabled(italicsEnabled);
  builder_.add_underlineEnabled(underlineEnabled);
  builder_.add_boldEnabled(boldEnabled);
  builder_.add_glowEnabled(glowEnabled);
  builder_.add_isLocalized(isLocalized);
  builder_.add_shadowEnabled(shadowEnabled);
  builder_.add_outlineEnabled(outlineEnabled);
  builder_.add_isCustomSize(isCustomSize);
  builder_.add_touchScaleEnable(touchScaleEnable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextOptions> CreateTextOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    const char *fontName = nullptr,
    int32_t fontSize = 0,
    const char *text = nullptr,
    int32_t areaWidth = 0,
    int32_t areaHeight = 0,
    int32_t hAlignment = 0,
    int32_t vAlignment = 0,
    bool touchScaleEnable = false,
    bool isCustomSize = false,
    bool outlineEnabled = false,
    const flatbuffers::FColor *outlineColor = nullptr,
    int32_t outlineSize = 1,
    bool shadowEnabled = false,
    const flatbuffers::FColor *shadowColor = nullptr,
    float shadowOffsetX = 2.0f,
    float shadowOffsetY = -2.0f,
    int32_t shadowBlurRadius = 0,
    bool isLocalized = false,
    bool glowEnabled = false,
    const flatbuffers::FColor *glowColor = nullptr,
    bool boldEnabled = false,
    bool underlineEnabled = false,
    bool italicsEnabled = false,
    bool strikethroughEnabled = false) {
  auto fontName__ = fontName ? _fbb.CreateString(fontName) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return flatbuffers::CreateTextOptions(
      _fbb,
      widgetOptions,
      fontResource,
      fontName__,
      fontSize,
      text__,
      areaWidth,
      areaHeight,
      hAlignment,
      vAlignment,
      touchScaleEnable,
      isCustomSize,
      outlineEnabled,
      outlineColor,
      outlineSize,
      shadowEnabled,
      shadowColor,
      shadowOffsetX,
      shadowOffsetY,
      shadowBlurRadius,
      isLocalized,
      glowEnabled,
      glowColor,
      boldEnabled,
      underlineEnabled,
      italicsEnabled,
      strikethroughEnabled);
}

struct RichTextOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RichTextOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_XMLDEFINITION = 6
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const ::flatbuffers::String *xmlDefinition() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XMLDEFINITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_XMLDEFINITION) &&
           verifier.VerifyString(xmlDefinition()) &&
           verifier.EndTable();
  }
};

struct RichTextOptionsBuilder {
  typedef RichTextOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(RichTextOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_xmlDefinition(::flatbuffers::Offset<::flatbuffers::String> xmlDefinition) {
    fbb_.AddOffset(RichTextOptions::VT_XMLDEFINITION, xmlDefinition);
  }
  explicit RichTextOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RichTextOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RichTextOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RichTextOptions> CreateRichTextOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> xmlDefinition = 0) {
  RichTextOptionsBuilder builder_(_fbb);
  builder_.add_xmlDefinition(xmlDefinition);
  builder_.add_widgetOptions(widgetOptions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RichTextOptions> CreateRichTextOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    const char *xmlDefinition = nullptr) {
  auto xmlDefinition__ = xmlDefinition ? _fbb.CreateString(xmlDefinition) : 0;
  return flatbuffers::CreateRichTextOptions(
      _fbb,
      widgetOptions,
      xmlDefinition__);
}

struct TextFieldOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextFieldOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_FONTRESOURCE = 6,
    VT_FONTNAME = 8,
    VT_FONTSIZE = 10,
    VT_TEXT = 12,
    VT_PLACEHOLDER = 14,
    VT_PASSWORDENABLED = 16,
    VT_PASSWORDSTYLETEXT = 18,
    VT_MAXLENGTHENABLED = 20,
    VT_MAXLENGTH = 22,
    VT_AREAWIDTH = 24,
    VT_AREAHEIGHT = 26,
    VT_ISCUSTOMSIZE = 28,
    VT_ISLOCALIZED = 30
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *fontResource() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FONTRESOURCE);
  }
  const ::flatbuffers::String *fontName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONTNAME);
  }
  int32_t fontSize() const {
    return GetField<int32_t>(VT_FONTSIZE, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *placeHolder() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLACEHOLDER);
  }
  bool passwordEnabled() const {
    return GetField<uint8_t>(VT_PASSWORDENABLED, 0) != 0;
  }
  const ::flatbuffers::String *passwordStyleText() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORDSTYLETEXT);
  }
  bool maxLengthEnabled() const {
    return GetField<uint8_t>(VT_MAXLENGTHENABLED, 0) != 0;
  }
  int32_t maxLength() const {
    return GetField<int32_t>(VT_MAXLENGTH, 0);
  }
  int32_t areaWidth() const {
    return GetField<int32_t>(VT_AREAWIDTH, 0);
  }
  int32_t areaHeight() const {
    return GetField<int32_t>(VT_AREAHEIGHT, 0);
  }
  bool isCustomSize() const {
    return GetField<uint8_t>(VT_ISCUSTOMSIZE, 0) != 0;
  }
  bool isLocalized() const {
    return GetField<uint8_t>(VT_ISLOCALIZED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_FONTRESOURCE) &&
           verifier.VerifyTable(fontResource()) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(fontName()) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_PLACEHOLDER) &&
           verifier.VerifyString(placeHolder()) &&
           VerifyField<uint8_t>(verifier, VT_PASSWORDENABLED, 1) &&
           VerifyOffset(verifier, VT_PASSWORDSTYLETEXT) &&
           verifier.VerifyString(passwordStyleText()) &&
           VerifyField<uint8_t>(verifier, VT_MAXLENGTHENABLED, 1) &&
           VerifyField<int32_t>(verifier, VT_MAXLENGTH, 4) &&
           VerifyField<int32_t>(verifier, VT_AREAWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_AREAHEIGHT, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISCUSTOMSIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCALIZED, 1) &&
           verifier.EndTable();
  }
};

struct TextFieldOptionsBuilder {
  typedef TextFieldOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(TextFieldOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_fontResource(::flatbuffers::Offset<flatbuffers::ResourceData> fontResource) {
    fbb_.AddOffset(TextFieldOptions::VT_FONTRESOURCE, fontResource);
  }
  void add_fontName(::flatbuffers::Offset<::flatbuffers::String> fontName) {
    fbb_.AddOffset(TextFieldOptions::VT_FONTNAME, fontName);
  }
  void add_fontSize(int32_t fontSize) {
    fbb_.AddElement<int32_t>(TextFieldOptions::VT_FONTSIZE, fontSize, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextFieldOptions::VT_TEXT, text);
  }
  void add_placeHolder(::flatbuffers::Offset<::flatbuffers::String> placeHolder) {
    fbb_.AddOffset(TextFieldOptions::VT_PLACEHOLDER, placeHolder);
  }
  void add_passwordEnabled(bool passwordEnabled) {
    fbb_.AddElement<uint8_t>(TextFieldOptions::VT_PASSWORDENABLED, static_cast<uint8_t>(passwordEnabled), 0);
  }
  void add_passwordStyleText(::flatbuffers::Offset<::flatbuffers::String> passwordStyleText) {
    fbb_.AddOffset(TextFieldOptions::VT_PASSWORDSTYLETEXT, passwordStyleText);
  }
  void add_maxLengthEnabled(bool maxLengthEnabled) {
    fbb_.AddElement<uint8_t>(TextFieldOptions::VT_MAXLENGTHENABLED, static_cast<uint8_t>(maxLengthEnabled), 0);
  }
  void add_maxLength(int32_t maxLength) {
    fbb_.AddElement<int32_t>(TextFieldOptions::VT_MAXLENGTH, maxLength, 0);
  }
  void add_areaWidth(int32_t areaWidth) {
    fbb_.AddElement<int32_t>(TextFieldOptions::VT_AREAWIDTH, areaWidth, 0);
  }
  void add_areaHeight(int32_t areaHeight) {
    fbb_.AddElement<int32_t>(TextFieldOptions::VT_AREAHEIGHT, areaHeight, 0);
  }
  void add_isCustomSize(bool isCustomSize) {
    fbb_.AddElement<uint8_t>(TextFieldOptions::VT_ISCUSTOMSIZE, static_cast<uint8_t>(isCustomSize), 0);
  }
  void add_isLocalized(bool isLocalized) {
    fbb_.AddElement<uint8_t>(TextFieldOptions::VT_ISLOCALIZED, static_cast<uint8_t>(isLocalized), 0);
  }
  explicit TextFieldOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextFieldOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextFieldOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextFieldOptions> CreateTextFieldOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fontName = 0,
    int32_t fontSize = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> placeHolder = 0,
    bool passwordEnabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> passwordStyleText = 0,
    bool maxLengthEnabled = false,
    int32_t maxLength = 0,
    int32_t areaWidth = 0,
    int32_t areaHeight = 0,
    bool isCustomSize = false,
    bool isLocalized = false) {
  TextFieldOptionsBuilder builder_(_fbb);
  builder_.add_areaHeight(areaHeight);
  builder_.add_areaWidth(areaWidth);
  builder_.add_maxLength(maxLength);
  builder_.add_passwordStyleText(passwordStyleText);
  builder_.add_placeHolder(placeHolder);
  builder_.add_text(text);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_fontResource(fontResource);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_isLocalized(isLocalized);
  builder_.add_isCustomSize(isCustomSize);
  builder_.add_maxLengthEnabled(maxLengthEnabled);
  builder_.add_passwordEnabled(passwordEnabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextFieldOptions> CreateTextFieldOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    const char *fontName = nullptr,
    int32_t fontSize = 0,
    const char *text = nullptr,
    const char *placeHolder = nullptr,
    bool passwordEnabled = false,
    const char *passwordStyleText = nullptr,
    bool maxLengthEnabled = false,
    int32_t maxLength = 0,
    int32_t areaWidth = 0,
    int32_t areaHeight = 0,
    bool isCustomSize = false,
    bool isLocalized = false) {
  auto fontName__ = fontName ? _fbb.CreateString(fontName) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto placeHolder__ = placeHolder ? _fbb.CreateString(placeHolder) : 0;
  auto passwordStyleText__ = passwordStyleText ? _fbb.CreateString(passwordStyleText) : 0;
  return flatbuffers::CreateTextFieldOptions(
      _fbb,
      widgetOptions,
      fontResource,
      fontName__,
      fontSize,
      text__,
      placeHolder__,
      passwordEnabled,
      passwordStyleText__,
      maxLengthEnabled,
      maxLength,
      areaWidth,
      areaHeight,
      isCustomSize,
      isLocalized);
}

struct LoadingBarOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoadingBarOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_TEXTUREDATA = 6,
    VT_PERCENT = 8,
    VT_DIRECTION = 10
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *textureData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_TEXTUREDATA);
  }
  int32_t percent() const {
    return GetField<int32_t>(VT_PERCENT, 80);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_TEXTUREDATA) &&
           verifier.VerifyTable(textureData()) &&
           VerifyField<int32_t>(verifier, VT_PERCENT, 4) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION, 4) &&
           verifier.EndTable();
  }
};

struct LoadingBarOptionsBuilder {
  typedef LoadingBarOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(LoadingBarOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_textureData(::flatbuffers::Offset<flatbuffers::ResourceData> textureData) {
    fbb_.AddOffset(LoadingBarOptions::VT_TEXTUREDATA, textureData);
  }
  void add_percent(int32_t percent) {
    fbb_.AddElement<int32_t>(LoadingBarOptions::VT_PERCENT, percent, 80);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(LoadingBarOptions::VT_DIRECTION, direction, 0);
  }
  explicit LoadingBarOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoadingBarOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoadingBarOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoadingBarOptions> CreateLoadingBarOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> textureData = 0,
    int32_t percent = 80,
    int32_t direction = 0) {
  LoadingBarOptionsBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_percent(percent);
  builder_.add_textureData(textureData);
  builder_.add_widgetOptions(widgetOptions);
  return builder_.Finish();
}

struct SliderOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliderOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BARFILENAMEDATA = 6,
    VT_BALLNORMALDATA = 8,
    VT_BALLPRESSEDDATA = 10,
    VT_BALLDISABLEDDATA = 12,
    VT_PROGRESSBARDATA = 14,
    VT_PERCENT = 16,
    VT_DISPLAYSTATE = 18
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *barFileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BARFILENAMEDATA);
  }
  const flatbuffers::ResourceData *ballNormalData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BALLNORMALDATA);
  }
  const flatbuffers::ResourceData *ballPressedData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BALLPRESSEDDATA);
  }
  const flatbuffers::ResourceData *ballDisabledData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BALLDISABLEDDATA);
  }
  const flatbuffers::ResourceData *progressBarData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_PROGRESSBARDATA);
  }
  int32_t percent() const {
    return GetField<int32_t>(VT_PERCENT, 50);
  }
  bool displaystate() const {
    return GetField<uint8_t>(VT_DISPLAYSTATE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BARFILENAMEDATA) &&
           verifier.VerifyTable(barFileNameData()) &&
           VerifyOffset(verifier, VT_BALLNORMALDATA) &&
           verifier.VerifyTable(ballNormalData()) &&
           VerifyOffset(verifier, VT_BALLPRESSEDDATA) &&
           verifier.VerifyTable(ballPressedData()) &&
           VerifyOffset(verifier, VT_BALLDISABLEDDATA) &&
           verifier.VerifyTable(ballDisabledData()) &&
           VerifyOffset(verifier, VT_PROGRESSBARDATA) &&
           verifier.VerifyTable(progressBarData()) &&
           VerifyField<int32_t>(verifier, VT_PERCENT, 4) &&
           VerifyField<uint8_t>(verifier, VT_DISPLAYSTATE, 1) &&
           verifier.EndTable();
  }
};

struct SliderOptionsBuilder {
  typedef SliderOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(SliderOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_barFileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> barFileNameData) {
    fbb_.AddOffset(SliderOptions::VT_BARFILENAMEDATA, barFileNameData);
  }
  void add_ballNormalData(::flatbuffers::Offset<flatbuffers::ResourceData> ballNormalData) {
    fbb_.AddOffset(SliderOptions::VT_BALLNORMALDATA, ballNormalData);
  }
  void add_ballPressedData(::flatbuffers::Offset<flatbuffers::ResourceData> ballPressedData) {
    fbb_.AddOffset(SliderOptions::VT_BALLPRESSEDDATA, ballPressedData);
  }
  void add_ballDisabledData(::flatbuffers::Offset<flatbuffers::ResourceData> ballDisabledData) {
    fbb_.AddOffset(SliderOptions::VT_BALLDISABLEDDATA, ballDisabledData);
  }
  void add_progressBarData(::flatbuffers::Offset<flatbuffers::ResourceData> progressBarData) {
    fbb_.AddOffset(SliderOptions::VT_PROGRESSBARDATA, progressBarData);
  }
  void add_percent(int32_t percent) {
    fbb_.AddElement<int32_t>(SliderOptions::VT_PERCENT, percent, 50);
  }
  void add_displaystate(bool displaystate) {
    fbb_.AddElement<uint8_t>(SliderOptions::VT_DISPLAYSTATE, static_cast<uint8_t>(displaystate), 1);
  }
  explicit SliderOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliderOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliderOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SliderOptions> CreateSliderOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> barFileNameData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> ballNormalData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> ballPressedData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> ballDisabledData = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> progressBarData = 0,
    int32_t percent = 50,
    bool displaystate = true) {
  SliderOptionsBuilder builder_(_fbb);
  builder_.add_percent(percent);
  builder_.add_progressBarData(progressBarData);
  builder_.add_ballDisabledData(ballDisabledData);
  builder_.add_ballPressedData(ballPressedData);
  builder_.add_ballNormalData(ballNormalData);
  builder_.add_barFileNameData(barFileNameData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_displaystate(displaystate);
  return builder_.Finish();
}

struct PanelOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PanelOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDIMAGEDATA = 6,
    VT_CLIPENABLED = 8,
    VT_BGCOLOR = 10,
    VT_BGSTARTCOLOR = 12,
    VT_BGENDCOLOR = 14,
    VT_COLORTYPE = 16,
    VT_BGCOLOROPACITY = 18,
    VT_COLORVECTOR = 20,
    VT_CAPINSETS = 22,
    VT_SCALE9SIZE = 24,
    VT_BACKGROUNDSCALE9ENABLED = 26
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundImageData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDIMAGEDATA);
  }
  bool clipEnabled() const {
    return GetField<uint8_t>(VT_CLIPENABLED, 0) != 0;
  }
  const flatbuffers::FColor *bgColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGCOLOR);
  }
  const flatbuffers::FColor *bgStartColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGSTARTCOLOR);
  }
  const flatbuffers::FColor *bgEndColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGENDCOLOR);
  }
  int32_t colorType() const {
    return GetField<int32_t>(VT_COLORTYPE, 0);
  }
  uint8_t bgColorOpacity() const {
    return GetField<uint8_t>(VT_BGCOLOROPACITY, 255);
  }
  const flatbuffers::FVec2 *colorVector() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_COLORVECTOR);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool backGroundScale9Enabled() const {
    return GetField<uint8_t>(VT_BACKGROUNDSCALE9ENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDIMAGEDATA) &&
           verifier.VerifyTable(backGroundImageData()) &&
           VerifyField<uint8_t>(verifier, VT_CLIPENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGSTARTCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGENDCOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_COLORTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BGCOLOROPACITY, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_COLORVECTOR, 4) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDSCALE9ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct PanelOptionsBuilder {
  typedef PanelOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(PanelOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundImageData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData) {
    fbb_.AddOffset(PanelOptions::VT_BACKGROUNDIMAGEDATA, backGroundImageData);
  }
  void add_clipEnabled(bool clipEnabled) {
    fbb_.AddElement<uint8_t>(PanelOptions::VT_CLIPENABLED, static_cast<uint8_t>(clipEnabled), 0);
  }
  void add_bgColor(const flatbuffers::FColor *bgColor) {
    fbb_.AddStruct(PanelOptions::VT_BGCOLOR, bgColor);
  }
  void add_bgStartColor(const flatbuffers::FColor *bgStartColor) {
    fbb_.AddStruct(PanelOptions::VT_BGSTARTCOLOR, bgStartColor);
  }
  void add_bgEndColor(const flatbuffers::FColor *bgEndColor) {
    fbb_.AddStruct(PanelOptions::VT_BGENDCOLOR, bgEndColor);
  }
  void add_colorType(int32_t colorType) {
    fbb_.AddElement<int32_t>(PanelOptions::VT_COLORTYPE, colorType, 0);
  }
  void add_bgColorOpacity(uint8_t bgColorOpacity) {
    fbb_.AddElement<uint8_t>(PanelOptions::VT_BGCOLOROPACITY, bgColorOpacity, 255);
  }
  void add_colorVector(const flatbuffers::FVec2 *colorVector) {
    fbb_.AddStruct(PanelOptions::VT_COLORVECTOR, colorVector);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(PanelOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(PanelOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_backGroundScale9Enabled(bool backGroundScale9Enabled) {
    fbb_.AddElement<uint8_t>(PanelOptions::VT_BACKGROUNDSCALE9ENABLED, static_cast<uint8_t>(backGroundScale9Enabled), 0);
  }
  explicit PanelOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PanelOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PanelOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PanelOptions> CreatePanelOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData = 0,
    bool clipEnabled = false,
    const flatbuffers::FColor *bgColor = nullptr,
    const flatbuffers::FColor *bgStartColor = nullptr,
    const flatbuffers::FColor *bgEndColor = nullptr,
    int32_t colorType = 0,
    uint8_t bgColorOpacity = 255,
    const flatbuffers::FVec2 *colorVector = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool backGroundScale9Enabled = false) {
  PanelOptionsBuilder builder_(_fbb);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_colorVector(colorVector);
  builder_.add_colorType(colorType);
  builder_.add_bgEndColor(bgEndColor);
  builder_.add_bgStartColor(bgStartColor);
  builder_.add_bgColor(bgColor);
  builder_.add_backGroundImageData(backGroundImageData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_backGroundScale9Enabled(backGroundScale9Enabled);
  builder_.add_bgColorOpacity(bgColorOpacity);
  builder_.add_clipEnabled(clipEnabled);
  return builder_.Finish();
}

struct ScrollViewOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScrollViewOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDIMAGEDATA = 6,
    VT_CLIPENABLED = 8,
    VT_BGCOLOR = 10,
    VT_BGSTARTCOLOR = 12,
    VT_BGENDCOLOR = 14,
    VT_COLORTYPE = 16,
    VT_BGCOLOROPACITY = 18,
    VT_COLORVECTOR = 20,
    VT_CAPINSETS = 22,
    VT_SCALE9SIZE = 24,
    VT_BACKGROUNDSCALE9ENABLED = 26,
    VT_INNERSIZE = 28,
    VT_DIRECTION = 30,
    VT_BOUNCEENABLED = 32,
    VT_SCROLLBARENABELD = 34,
    VT_SCROLLBARAUTOHIDE = 36,
    VT_SCROLLBARAUTOHIDETIME = 38
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundImageData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDIMAGEDATA);
  }
  bool clipEnabled() const {
    return GetField<uint8_t>(VT_CLIPENABLED, 0) != 0;
  }
  const flatbuffers::FColor *bgColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGCOLOR);
  }
  const flatbuffers::FColor *bgStartColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGSTARTCOLOR);
  }
  const flatbuffers::FColor *bgEndColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGENDCOLOR);
  }
  int32_t colorType() const {
    return GetField<int32_t>(VT_COLORTYPE, 0);
  }
  uint8_t bgColorOpacity() const {
    return GetField<uint8_t>(VT_BGCOLOROPACITY, 255);
  }
  const flatbuffers::FVec2 *colorVector() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_COLORVECTOR);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool backGroundScale9Enabled() const {
    return GetField<uint8_t>(VT_BACKGROUNDSCALE9ENABLED, 0) != 0;
  }
  const flatbuffers::FlatSize *innerSize() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_INNERSIZE);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  bool bounceEnabled() const {
    return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0;
  }
  bool scrollbarEnabeld() const {
    return GetField<uint8_t>(VT_SCROLLBARENABELD, 1) != 0;
  }
  bool scrollbarAutoHide() const {
    return GetField<uint8_t>(VT_SCROLLBARAUTOHIDE, 1) != 0;
  }
  float scrollbarAutoHideTime() const {
    return GetField<float>(VT_SCROLLBARAUTOHIDETIME, 0.2f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDIMAGEDATA) &&
           verifier.VerifyTable(backGroundImageData()) &&
           VerifyField<uint8_t>(verifier, VT_CLIPENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGSTARTCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGENDCOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_COLORTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BGCOLOROPACITY, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_COLORVECTOR, 4) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDSCALE9ENABLED, 1) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_INNERSIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION, 4) &&
           VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SCROLLBARENABELD, 1) &&
           VerifyField<uint8_t>(verifier, VT_SCROLLBARAUTOHIDE, 1) &&
           VerifyField<float>(verifier, VT_SCROLLBARAUTOHIDETIME, 4) &&
           verifier.EndTable();
  }
};

struct ScrollViewOptionsBuilder {
  typedef ScrollViewOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(ScrollViewOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundImageData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData) {
    fbb_.AddOffset(ScrollViewOptions::VT_BACKGROUNDIMAGEDATA, backGroundImageData);
  }
  void add_clipEnabled(bool clipEnabled) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_CLIPENABLED, static_cast<uint8_t>(clipEnabled), 0);
  }
  void add_bgColor(const flatbuffers::FColor *bgColor) {
    fbb_.AddStruct(ScrollViewOptions::VT_BGCOLOR, bgColor);
  }
  void add_bgStartColor(const flatbuffers::FColor *bgStartColor) {
    fbb_.AddStruct(ScrollViewOptions::VT_BGSTARTCOLOR, bgStartColor);
  }
  void add_bgEndColor(const flatbuffers::FColor *bgEndColor) {
    fbb_.AddStruct(ScrollViewOptions::VT_BGENDCOLOR, bgEndColor);
  }
  void add_colorType(int32_t colorType) {
    fbb_.AddElement<int32_t>(ScrollViewOptions::VT_COLORTYPE, colorType, 0);
  }
  void add_bgColorOpacity(uint8_t bgColorOpacity) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_BGCOLOROPACITY, bgColorOpacity, 255);
  }
  void add_colorVector(const flatbuffers::FVec2 *colorVector) {
    fbb_.AddStruct(ScrollViewOptions::VT_COLORVECTOR, colorVector);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(ScrollViewOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(ScrollViewOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_backGroundScale9Enabled(bool backGroundScale9Enabled) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_BACKGROUNDSCALE9ENABLED, static_cast<uint8_t>(backGroundScale9Enabled), 0);
  }
  void add_innerSize(const flatbuffers::FlatSize *innerSize) {
    fbb_.AddStruct(ScrollViewOptions::VT_INNERSIZE, innerSize);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(ScrollViewOptions::VT_DIRECTION, direction, 0);
  }
  void add_bounceEnabled(bool bounceEnabled) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0);
  }
  void add_scrollbarEnabeld(bool scrollbarEnabeld) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_SCROLLBARENABELD, static_cast<uint8_t>(scrollbarEnabeld), 1);
  }
  void add_scrollbarAutoHide(bool scrollbarAutoHide) {
    fbb_.AddElement<uint8_t>(ScrollViewOptions::VT_SCROLLBARAUTOHIDE, static_cast<uint8_t>(scrollbarAutoHide), 1);
  }
  void add_scrollbarAutoHideTime(float scrollbarAutoHideTime) {
    fbb_.AddElement<float>(ScrollViewOptions::VT_SCROLLBARAUTOHIDETIME, scrollbarAutoHideTime, 0.2f);
  }
  explicit ScrollViewOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScrollViewOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScrollViewOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScrollViewOptions> CreateScrollViewOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData = 0,
    bool clipEnabled = false,
    const flatbuffers::FColor *bgColor = nullptr,
    const flatbuffers::FColor *bgStartColor = nullptr,
    const flatbuffers::FColor *bgEndColor = nullptr,
    int32_t colorType = 0,
    uint8_t bgColorOpacity = 255,
    const flatbuffers::FVec2 *colorVector = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool backGroundScale9Enabled = false,
    const flatbuffers::FlatSize *innerSize = nullptr,
    int32_t direction = 0,
    bool bounceEnabled = false,
    bool scrollbarEnabeld = true,
    bool scrollbarAutoHide = true,
    float scrollbarAutoHideTime = 0.2f) {
  ScrollViewOptionsBuilder builder_(_fbb);
  builder_.add_scrollbarAutoHideTime(scrollbarAutoHideTime);
  builder_.add_direction(direction);
  builder_.add_innerSize(innerSize);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_colorVector(colorVector);
  builder_.add_colorType(colorType);
  builder_.add_bgEndColor(bgEndColor);
  builder_.add_bgStartColor(bgStartColor);
  builder_.add_bgColor(bgColor);
  builder_.add_backGroundImageData(backGroundImageData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_scrollbarAutoHide(scrollbarAutoHide);
  builder_.add_scrollbarEnabeld(scrollbarEnabeld);
  builder_.add_bounceEnabled(bounceEnabled);
  builder_.add_backGroundScale9Enabled(backGroundScale9Enabled);
  builder_.add_bgColorOpacity(bgColorOpacity);
  builder_.add_clipEnabled(clipEnabled);
  return builder_.Finish();
}

struct PageViewOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PageViewOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDIMAGEDATA = 6,
    VT_CLIPENABLED = 8,
    VT_BGCOLOR = 10,
    VT_BGSTARTCOLOR = 12,
    VT_BGENDCOLOR = 14,
    VT_COLORTYPE = 16,
    VT_BGCOLOROPACITY = 18,
    VT_COLORVECTOR = 20,
    VT_CAPINSETS = 22,
    VT_SCALE9SIZE = 24,
    VT_BACKGROUNDSCALE9ENABLED = 26
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundImageData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDIMAGEDATA);
  }
  bool clipEnabled() const {
    return GetField<uint8_t>(VT_CLIPENABLED, 0) != 0;
  }
  const flatbuffers::FColor *bgColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGCOLOR);
  }
  const flatbuffers::FColor *bgStartColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGSTARTCOLOR);
  }
  const flatbuffers::FColor *bgEndColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGENDCOLOR);
  }
  int32_t colorType() const {
    return GetField<int32_t>(VT_COLORTYPE, 0);
  }
  uint8_t bgColorOpacity() const {
    return GetField<uint8_t>(VT_BGCOLOROPACITY, 255);
  }
  const flatbuffers::FVec2 *colorVector() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_COLORVECTOR);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool backGroundScale9Enabled() const {
    return GetField<uint8_t>(VT_BACKGROUNDSCALE9ENABLED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDIMAGEDATA) &&
           verifier.VerifyTable(backGroundImageData()) &&
           VerifyField<uint8_t>(verifier, VT_CLIPENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGSTARTCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGENDCOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_COLORTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BGCOLOROPACITY, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_COLORVECTOR, 4) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDSCALE9ENABLED, 1) &&
           verifier.EndTable();
  }
};

struct PageViewOptionsBuilder {
  typedef PageViewOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(PageViewOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundImageData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData) {
    fbb_.AddOffset(PageViewOptions::VT_BACKGROUNDIMAGEDATA, backGroundImageData);
  }
  void add_clipEnabled(bool clipEnabled) {
    fbb_.AddElement<uint8_t>(PageViewOptions::VT_CLIPENABLED, static_cast<uint8_t>(clipEnabled), 0);
  }
  void add_bgColor(const flatbuffers::FColor *bgColor) {
    fbb_.AddStruct(PageViewOptions::VT_BGCOLOR, bgColor);
  }
  void add_bgStartColor(const flatbuffers::FColor *bgStartColor) {
    fbb_.AddStruct(PageViewOptions::VT_BGSTARTCOLOR, bgStartColor);
  }
  void add_bgEndColor(const flatbuffers::FColor *bgEndColor) {
    fbb_.AddStruct(PageViewOptions::VT_BGENDCOLOR, bgEndColor);
  }
  void add_colorType(int32_t colorType) {
    fbb_.AddElement<int32_t>(PageViewOptions::VT_COLORTYPE, colorType, 0);
  }
  void add_bgColorOpacity(uint8_t bgColorOpacity) {
    fbb_.AddElement<uint8_t>(PageViewOptions::VT_BGCOLOROPACITY, bgColorOpacity, 255);
  }
  void add_colorVector(const flatbuffers::FVec2 *colorVector) {
    fbb_.AddStruct(PageViewOptions::VT_COLORVECTOR, colorVector);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(PageViewOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(PageViewOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_backGroundScale9Enabled(bool backGroundScale9Enabled) {
    fbb_.AddElement<uint8_t>(PageViewOptions::VT_BACKGROUNDSCALE9ENABLED, static_cast<uint8_t>(backGroundScale9Enabled), 0);
  }
  explicit PageViewOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PageViewOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PageViewOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PageViewOptions> CreatePageViewOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData = 0,
    bool clipEnabled = false,
    const flatbuffers::FColor *bgColor = nullptr,
    const flatbuffers::FColor *bgStartColor = nullptr,
    const flatbuffers::FColor *bgEndColor = nullptr,
    int32_t colorType = 0,
    uint8_t bgColorOpacity = 255,
    const flatbuffers::FVec2 *colorVector = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool backGroundScale9Enabled = false) {
  PageViewOptionsBuilder builder_(_fbb);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_colorVector(colorVector);
  builder_.add_colorType(colorType);
  builder_.add_bgEndColor(bgEndColor);
  builder_.add_bgStartColor(bgStartColor);
  builder_.add_bgColor(bgColor);
  builder_.add_backGroundImageData(backGroundImageData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_backGroundScale9Enabled(backGroundScale9Enabled);
  builder_.add_bgColorOpacity(bgColorOpacity);
  builder_.add_clipEnabled(clipEnabled);
  return builder_.Finish();
}

struct ListViewOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListViewOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGETOPTIONS = 4,
    VT_BACKGROUNDIMAGEDATA = 6,
    VT_CLIPENABLED = 8,
    VT_BGCOLOR = 10,
    VT_BGSTARTCOLOR = 12,
    VT_BGENDCOLOR = 14,
    VT_COLORTYPE = 16,
    VT_BGCOLOROPACITY = 18,
    VT_COLORVECTOR = 20,
    VT_CAPINSETS = 22,
    VT_SCALE9SIZE = 24,
    VT_BACKGROUNDSCALE9ENABLED = 26,
    VT_INNERSIZE = 28,
    VT_DIRECTION = 30,
    VT_BOUNCEENABLED = 32,
    VT_ITEMMARGIN = 34,
    VT_DIRECTIONTYPE = 36,
    VT_HORIZONTALTYPE = 38,
    VT_VERTICALTYPE = 40
  };
  const flatbuffers::WidgetOptions *widgetOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_WIDGETOPTIONS);
  }
  const flatbuffers::ResourceData *backGroundImageData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_BACKGROUNDIMAGEDATA);
  }
  bool clipEnabled() const {
    return GetField<uint8_t>(VT_CLIPENABLED, 0) != 0;
  }
  const flatbuffers::FColor *bgColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGCOLOR);
  }
  const flatbuffers::FColor *bgStartColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGSTARTCOLOR);
  }
  const flatbuffers::FColor *bgEndColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_BGENDCOLOR);
  }
  int32_t colorType() const {
    return GetField<int32_t>(VT_COLORTYPE, 0);
  }
  uint8_t bgColorOpacity() const {
    return GetField<uint8_t>(VT_BGCOLOROPACITY, 255);
  }
  const flatbuffers::FVec2 *colorVector() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_COLORVECTOR);
  }
  const flatbuffers::CapInsets *capInsets() const {
    return GetStruct<const flatbuffers::CapInsets *>(VT_CAPINSETS);
  }
  const flatbuffers::FlatSize *scale9Size() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_SCALE9SIZE);
  }
  bool backGroundScale9Enabled() const {
    return GetField<uint8_t>(VT_BACKGROUNDSCALE9ENABLED, 0) != 0;
  }
  const flatbuffers::FlatSize *innerSize() const {
    return GetStruct<const flatbuffers::FlatSize *>(VT_INNERSIZE);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  bool bounceEnabled() const {
    return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0;
  }
  int32_t itemMargin() const {
    return GetField<int32_t>(VT_ITEMMARGIN, 0);
  }
  const ::flatbuffers::String *directionType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTIONTYPE);
  }
  const ::flatbuffers::String *horizontalType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HORIZONTALTYPE);
  }
  const ::flatbuffers::String *verticalType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERTICALTYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDGETOPTIONS) &&
           verifier.VerifyTable(widgetOptions()) &&
           VerifyOffset(verifier, VT_BACKGROUNDIMAGEDATA) &&
           verifier.VerifyTable(backGroundImageData()) &&
           VerifyField<uint8_t>(verifier, VT_CLIPENABLED, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGSTARTCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_BGENDCOLOR, 1) &&
           VerifyField<int32_t>(verifier, VT_COLORTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BGCOLOROPACITY, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_COLORVECTOR, 4) &&
           VerifyField<flatbuffers::CapInsets>(verifier, VT_CAPINSETS, 4) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_SCALE9SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDSCALE9ENABLED, 1) &&
           VerifyField<flatbuffers::FlatSize>(verifier, VT_INNERSIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION, 4) &&
           VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED, 1) &&
           VerifyField<int32_t>(verifier, VT_ITEMMARGIN, 4) &&
           VerifyOffset(verifier, VT_DIRECTIONTYPE) &&
           verifier.VerifyString(directionType()) &&
           VerifyOffset(verifier, VT_HORIZONTALTYPE) &&
           verifier.VerifyString(horizontalType()) &&
           VerifyOffset(verifier, VT_VERTICALTYPE) &&
           verifier.VerifyString(verticalType()) &&
           verifier.EndTable();
  }
};

struct ListViewOptionsBuilder {
  typedef ListViewOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widgetOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions) {
    fbb_.AddOffset(ListViewOptions::VT_WIDGETOPTIONS, widgetOptions);
  }
  void add_backGroundImageData(::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData) {
    fbb_.AddOffset(ListViewOptions::VT_BACKGROUNDIMAGEDATA, backGroundImageData);
  }
  void add_clipEnabled(bool clipEnabled) {
    fbb_.AddElement<uint8_t>(ListViewOptions::VT_CLIPENABLED, static_cast<uint8_t>(clipEnabled), 0);
  }
  void add_bgColor(const flatbuffers::FColor *bgColor) {
    fbb_.AddStruct(ListViewOptions::VT_BGCOLOR, bgColor);
  }
  void add_bgStartColor(const flatbuffers::FColor *bgStartColor) {
    fbb_.AddStruct(ListViewOptions::VT_BGSTARTCOLOR, bgStartColor);
  }
  void add_bgEndColor(const flatbuffers::FColor *bgEndColor) {
    fbb_.AddStruct(ListViewOptions::VT_BGENDCOLOR, bgEndColor);
  }
  void add_colorType(int32_t colorType) {
    fbb_.AddElement<int32_t>(ListViewOptions::VT_COLORTYPE, colorType, 0);
  }
  void add_bgColorOpacity(uint8_t bgColorOpacity) {
    fbb_.AddElement<uint8_t>(ListViewOptions::VT_BGCOLOROPACITY, bgColorOpacity, 255);
  }
  void add_colorVector(const flatbuffers::FVec2 *colorVector) {
    fbb_.AddStruct(ListViewOptions::VT_COLORVECTOR, colorVector);
  }
  void add_capInsets(const flatbuffers::CapInsets *capInsets) {
    fbb_.AddStruct(ListViewOptions::VT_CAPINSETS, capInsets);
  }
  void add_scale9Size(const flatbuffers::FlatSize *scale9Size) {
    fbb_.AddStruct(ListViewOptions::VT_SCALE9SIZE, scale9Size);
  }
  void add_backGroundScale9Enabled(bool backGroundScale9Enabled) {
    fbb_.AddElement<uint8_t>(ListViewOptions::VT_BACKGROUNDSCALE9ENABLED, static_cast<uint8_t>(backGroundScale9Enabled), 0);
  }
  void add_innerSize(const flatbuffers::FlatSize *innerSize) {
    fbb_.AddStruct(ListViewOptions::VT_INNERSIZE, innerSize);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(ListViewOptions::VT_DIRECTION, direction, 0);
  }
  void add_bounceEnabled(bool bounceEnabled) {
    fbb_.AddElement<uint8_t>(ListViewOptions::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0);
  }
  void add_itemMargin(int32_t itemMargin) {
    fbb_.AddElement<int32_t>(ListViewOptions::VT_ITEMMARGIN, itemMargin, 0);
  }
  void add_directionType(::flatbuffers::Offset<::flatbuffers::String> directionType) {
    fbb_.AddOffset(ListViewOptions::VT_DIRECTIONTYPE, directionType);
  }
  void add_horizontalType(::flatbuffers::Offset<::flatbuffers::String> horizontalType) {
    fbb_.AddOffset(ListViewOptions::VT_HORIZONTALTYPE, horizontalType);
  }
  void add_verticalType(::flatbuffers::Offset<::flatbuffers::String> verticalType) {
    fbb_.AddOffset(ListViewOptions::VT_VERTICALTYPE, verticalType);
  }
  explicit ListViewOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListViewOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListViewOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListViewOptions> CreateListViewOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData = 0,
    bool clipEnabled = false,
    const flatbuffers::FColor *bgColor = nullptr,
    const flatbuffers::FColor *bgStartColor = nullptr,
    const flatbuffers::FColor *bgEndColor = nullptr,
    int32_t colorType = 0,
    uint8_t bgColorOpacity = 255,
    const flatbuffers::FVec2 *colorVector = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool backGroundScale9Enabled = false,
    const flatbuffers::FlatSize *innerSize = nullptr,
    int32_t direction = 0,
    bool bounceEnabled = false,
    int32_t itemMargin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> directionType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> horizontalType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> verticalType = 0) {
  ListViewOptionsBuilder builder_(_fbb);
  builder_.add_verticalType(verticalType);
  builder_.add_horizontalType(horizontalType);
  builder_.add_directionType(directionType);
  builder_.add_itemMargin(itemMargin);
  builder_.add_direction(direction);
  builder_.add_innerSize(innerSize);
  builder_.add_scale9Size(scale9Size);
  builder_.add_capInsets(capInsets);
  builder_.add_colorVector(colorVector);
  builder_.add_colorType(colorType);
  builder_.add_bgEndColor(bgEndColor);
  builder_.add_bgStartColor(bgStartColor);
  builder_.add_bgColor(bgColor);
  builder_.add_backGroundImageData(backGroundImageData);
  builder_.add_widgetOptions(widgetOptions);
  builder_.add_bounceEnabled(bounceEnabled);
  builder_.add_backGroundScale9Enabled(backGroundScale9Enabled);
  builder_.add_bgColorOpacity(bgColorOpacity);
  builder_.add_clipEnabled(clipEnabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListViewOptions> CreateListViewOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> widgetOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> backGroundImageData = 0,
    bool clipEnabled = false,
    const flatbuffers::FColor *bgColor = nullptr,
    const flatbuffers::FColor *bgStartColor = nullptr,
    const flatbuffers::FColor *bgEndColor = nullptr,
    int32_t colorType = 0,
    uint8_t bgColorOpacity = 255,
    const flatbuffers::FVec2 *colorVector = nullptr,
    const flatbuffers::CapInsets *capInsets = nullptr,
    const flatbuffers::FlatSize *scale9Size = nullptr,
    bool backGroundScale9Enabled = false,
    const flatbuffers::FlatSize *innerSize = nullptr,
    int32_t direction = 0,
    bool bounceEnabled = false,
    int32_t itemMargin = 0,
    const char *directionType = nullptr,
    const char *horizontalType = nullptr,
    const char *verticalType = nullptr) {
  auto directionType__ = directionType ? _fbb.CreateString(directionType) : 0;
  auto horizontalType__ = horizontalType ? _fbb.CreateString(horizontalType) : 0;
  auto verticalType__ = verticalType ? _fbb.CreateString(verticalType) : 0;
  return flatbuffers::CreateListViewOptions(
      _fbb,
      widgetOptions,
      backGroundImageData,
      clipEnabled,
      bgColor,
      bgStartColor,
      bgEndColor,
      colorType,
      bgColorOpacity,
      colorVector,
      capInsets,
      scale9Size,
      backGroundScale9Enabled,
      innerSize,
      direction,
      bounceEnabled,
      itemMargin,
      directionType__,
      horizontalType__,
      verticalType__);
}

struct TextFieldExOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextFieldExOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_FONTRESOURCE = 6,
    VT_FONTNAME = 8,
    VT_FONTSIZE = 10,
    VT_TEXT = 12,
    VT_PLACEHOLDERTEXT = 14,
    VT_PASSWORDENABLED = 16,
    VT_PASSWORDSTYLETEXT = 18,
    VT_MAXLENGTH = 20,
    VT_TEXTCOLOR = 22,
    VT_PLACEHOLDERCOLOR = 24,
    VT_CURSORCOLOR = 26,
    VT_ENABLED = 28,
    VT_EDITABLE = 30,
    VT_ISLOCALIZED = 32
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const flatbuffers::ResourceData *fontResource() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FONTRESOURCE);
  }
  const ::flatbuffers::String *fontName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONTNAME);
  }
  int32_t fontSize() const {
    return GetField<int32_t>(VT_FONTSIZE, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *placeholderText() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLACEHOLDERTEXT);
  }
  bool passwordEnabled() const {
    return GetField<uint8_t>(VT_PASSWORDENABLED, 0) != 0;
  }
  const ::flatbuffers::String *passwordStyleText() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORDSTYLETEXT);
  }
  int32_t maxLength() const {
    return GetField<int32_t>(VT_MAXLENGTH, 0);
  }
  const flatbuffers::FColor *textColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_TEXTCOLOR);
  }
  const flatbuffers::FColor *placeholderColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_PLACEHOLDERCOLOR);
  }
  const flatbuffers::FColor *cursorColor() const {
    return GetStruct<const flatbuffers::FColor *>(VT_CURSORCOLOR);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 1) != 0;
  }
  bool editable() const {
    return GetField<uint8_t>(VT_EDITABLE, 1) != 0;
  }
  bool isLocalized() const {
    return GetField<uint8_t>(VT_ISLOCALIZED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_FONTRESOURCE) &&
           verifier.VerifyTable(fontResource()) &&
           VerifyOffset(verifier, VT_FONTNAME) &&
           verifier.VerifyString(fontName()) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_PLACEHOLDERTEXT) &&
           verifier.VerifyString(placeholderText()) &&
           VerifyField<uint8_t>(verifier, VT_PASSWORDENABLED, 1) &&
           VerifyOffset(verifier, VT_PASSWORDSTYLETEXT) &&
           verifier.VerifyString(passwordStyleText()) &&
           VerifyField<int32_t>(verifier, VT_MAXLENGTH, 4) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_TEXTCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_PLACEHOLDERCOLOR, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_CURSORCOLOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_EDITABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCALIZED, 1) &&
           verifier.EndTable();
  }
};

struct TextFieldExOptionsBuilder {
  typedef TextFieldExOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(TextFieldExOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_fontResource(::flatbuffers::Offset<flatbuffers::ResourceData> fontResource) {
    fbb_.AddOffset(TextFieldExOptions::VT_FONTRESOURCE, fontResource);
  }
  void add_fontName(::flatbuffers::Offset<::flatbuffers::String> fontName) {
    fbb_.AddOffset(TextFieldExOptions::VT_FONTNAME, fontName);
  }
  void add_fontSize(int32_t fontSize) {
    fbb_.AddElement<int32_t>(TextFieldExOptions::VT_FONTSIZE, fontSize, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextFieldExOptions::VT_TEXT, text);
  }
  void add_placeholderText(::flatbuffers::Offset<::flatbuffers::String> placeholderText) {
    fbb_.AddOffset(TextFieldExOptions::VT_PLACEHOLDERTEXT, placeholderText);
  }
  void add_passwordEnabled(bool passwordEnabled) {
    fbb_.AddElement<uint8_t>(TextFieldExOptions::VT_PASSWORDENABLED, static_cast<uint8_t>(passwordEnabled), 0);
  }
  void add_passwordStyleText(::flatbuffers::Offset<::flatbuffers::String> passwordStyleText) {
    fbb_.AddOffset(TextFieldExOptions::VT_PASSWORDSTYLETEXT, passwordStyleText);
  }
  void add_maxLength(int32_t maxLength) {
    fbb_.AddElement<int32_t>(TextFieldExOptions::VT_MAXLENGTH, maxLength, 0);
  }
  void add_textColor(const flatbuffers::FColor *textColor) {
    fbb_.AddStruct(TextFieldExOptions::VT_TEXTCOLOR, textColor);
  }
  void add_placeholderColor(const flatbuffers::FColor *placeholderColor) {
    fbb_.AddStruct(TextFieldExOptions::VT_PLACEHOLDERCOLOR, placeholderColor);
  }
  void add_cursorColor(const flatbuffers::FColor *cursorColor) {
    fbb_.AddStruct(TextFieldExOptions::VT_CURSORCOLOR, cursorColor);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(TextFieldExOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
  }
  void add_editable(bool editable) {
    fbb_.AddElement<uint8_t>(TextFieldExOptions::VT_EDITABLE, static_cast<uint8_t>(editable), 1);
  }
  void add_isLocalized(bool isLocalized) {
    fbb_.AddElement<uint8_t>(TextFieldExOptions::VT_ISLOCALIZED, static_cast<uint8_t>(isLocalized), 0);
  }
  explicit TextFieldExOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextFieldExOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextFieldExOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextFieldExOptions> CreateTextFieldExOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fontName = 0,
    int32_t fontSize = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> placeholderText = 0,
    bool passwordEnabled = false,
    ::flatbuffers::Offset<::flatbuffers::String> passwordStyleText = 0,
    int32_t maxLength = 0,
    const flatbuffers::FColor *textColor = nullptr,
    const flatbuffers::FColor *placeholderColor = nullptr,
    const flatbuffers::FColor *cursorColor = nullptr,
    bool enabled = true,
    bool editable = true,
    bool isLocalized = false) {
  TextFieldExOptionsBuilder builder_(_fbb);
  builder_.add_cursorColor(cursorColor);
  builder_.add_placeholderColor(placeholderColor);
  builder_.add_textColor(textColor);
  builder_.add_maxLength(maxLength);
  builder_.add_passwordStyleText(passwordStyleText);
  builder_.add_placeholderText(placeholderText);
  builder_.add_text(text);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_fontResource(fontResource);
  builder_.add_nodeOptions(nodeOptions);
  builder_.add_isLocalized(isLocalized);
  builder_.add_editable(editable);
  builder_.add_enabled(enabled);
  builder_.add_passwordEnabled(passwordEnabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextFieldExOptions> CreateTextFieldExOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fontResource = 0,
    const char *fontName = nullptr,
    int32_t fontSize = 0,
    const char *text = nullptr,
    const char *placeholderText = nullptr,
    bool passwordEnabled = false,
    const char *passwordStyleText = nullptr,
    int32_t maxLength = 0,
    const flatbuffers::FColor *textColor = nullptr,
    const flatbuffers::FColor *placeholderColor = nullptr,
    const flatbuffers::FColor *cursorColor = nullptr,
    bool enabled = true,
    bool editable = true,
    bool isLocalized = false) {
  auto fontName__ = fontName ? _fbb.CreateString(fontName) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto placeholderText__ = placeholderText ? _fbb.CreateString(placeholderText) : 0;
  auto passwordStyleText__ = passwordStyleText ? _fbb.CreateString(passwordStyleText) : 0;
  return flatbuffers::CreateTextFieldExOptions(
      _fbb,
      nodeOptions,
      fontResource,
      fontName__,
      fontSize,
      text__,
      placeholderText__,
      passwordEnabled,
      passwordStyleText__,
      maxLength,
      textColor,
      placeholderColor,
      cursorColor,
      enabled,
      editable,
      isLocalized);
}

struct ProjectNodeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectNodeOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_FILENAME = 6,
    VT_INNERACTIONSPEED = 8
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const ::flatbuffers::String *fileName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float innerActionSpeed() const {
    return GetField<float>(VT_INNERACTIONSPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(fileName()) &&
           VerifyField<float>(verifier, VT_INNERACTIONSPEED, 4) &&
           verifier.EndTable();
  }
};

struct ProjectNodeOptionsBuilder {
  typedef ProjectNodeOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(ProjectNodeOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_fileName(::flatbuffers::Offset<::flatbuffers::String> fileName) {
    fbb_.AddOffset(ProjectNodeOptions::VT_FILENAME, fileName);
  }
  void add_innerActionSpeed(float innerActionSpeed) {
    fbb_.AddElement<float>(ProjectNodeOptions::VT_INNERACTIONSPEED, innerActionSpeed, 0.0f);
  }
  explicit ProjectNodeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProjectNodeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProjectNodeOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProjectNodeOptions> CreateProjectNodeOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fileName = 0,
    float innerActionSpeed = 0.0f) {
  ProjectNodeOptionsBuilder builder_(_fbb);
  builder_.add_innerActionSpeed(innerActionSpeed);
  builder_.add_fileName(fileName);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProjectNodeOptions> CreateProjectNodeOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    const char *fileName = nullptr,
    float innerActionSpeed = 0.0f) {
  auto fileName__ = fileName ? _fbb.CreateString(fileName) : 0;
  return flatbuffers::CreateProjectNodeOptions(
      _fbb,
      nodeOptions,
      fileName__,
      innerActionSpeed);
}

struct ComponentOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ComponentOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_TYPE = 6,
    VT_COMAUDIOOPTIONS = 8
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::ComAudioOptions *comAudioOptions() const {
    return GetPointer<const flatbuffers::ComAudioOptions *>(VT_COMAUDIOOPTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_COMAUDIOOPTIONS) &&
           verifier.VerifyTable(comAudioOptions()) &&
           verifier.EndTable();
  }
};

struct ComponentOptionsBuilder {
  typedef ComponentOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(ComponentOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ComponentOptions::VT_TYPE, type);
  }
  void add_comAudioOptions(::flatbuffers::Offset<flatbuffers::ComAudioOptions> comAudioOptions) {
    fbb_.AddOffset(ComponentOptions::VT_COMAUDIOOPTIONS, comAudioOptions);
  }
  explicit ComponentOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ComponentOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ComponentOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ComponentOptions> CreateComponentOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<flatbuffers::ComAudioOptions> comAudioOptions = 0) {
  ComponentOptionsBuilder builder_(_fbb);
  builder_.add_comAudioOptions(comAudioOptions);
  builder_.add_type(type);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ComponentOptions> CreateComponentOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    const char *type = nullptr,
    ::flatbuffers::Offset<flatbuffers::ComAudioOptions> comAudioOptions = 0) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return flatbuffers::CreateComponentOptions(
      _fbb,
      nodeOptions,
      type__,
      comAudioOptions);
}

struct ComAudioOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ComAudioOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODEOPTIONS = 4,
    VT_NAME = 6,
    VT_ENABLED = 8,
    VT_LOOP = 10,
    VT_VOLUME = 12,
    VT_FILENAMEDATA = 14
  };
  const flatbuffers::WidgetOptions *nodeOptions() const {
    return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool loop() const {
    return GetField<uint8_t>(VT_LOOP, 0) != 0;
  }
  int32_t volume() const {
    return GetField<int32_t>(VT_VOLUME, 0);
  }
  const flatbuffers::ResourceData *fileNameData() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_FILENAMEDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOOP, 1) &&
           VerifyField<int32_t>(verifier, VT_VOLUME, 4) &&
           VerifyOffset(verifier, VT_FILENAMEDATA) &&
           verifier.VerifyTable(fileNameData()) &&
           verifier.EndTable();
  }
};

struct ComAudioOptionsBuilder {
  typedef ComAudioOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodeOptions(::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) {
    fbb_.AddOffset(ComAudioOptions::VT_NODEOPTIONS, nodeOptions);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ComAudioOptions::VT_NAME, name);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(ComAudioOptions::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_loop(bool loop) {
    fbb_.AddElement<uint8_t>(ComAudioOptions::VT_LOOP, static_cast<uint8_t>(loop), 0);
  }
  void add_volume(int32_t volume) {
    fbb_.AddElement<int32_t>(ComAudioOptions::VT_VOLUME, volume, 0);
  }
  void add_fileNameData(::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData) {
    fbb_.AddOffset(ComAudioOptions::VT_FILENAMEDATA, fileNameData);
  }
  explicit ComAudioOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ComAudioOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ComAudioOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ComAudioOptions> CreateComAudioOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    bool enabled = false,
    bool loop = false,
    int32_t volume = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0) {
  ComAudioOptionsBuilder builder_(_fbb);
  builder_.add_fileNameData(fileNameData);
  builder_.add_volume(volume);
  builder_.add_name(name);
  builder_.add_nodeOptions(nodeOptions);
  builder_.add_loop(loop);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ComAudioOptions> CreateComAudioOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    const char *name = nullptr,
    bool enabled = false,
    bool loop = false,
    int32_t volume = 0,
    ::flatbuffers::Offset<flatbuffers::ResourceData> fileNameData = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbuffers::CreateComAudioOptions(
      _fbb,
      nodeOptions,
      name__,
      enabled,
      loop,
      volume,
      fileNameData);
}

struct AnimationInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STARTINDEX = 6,
    VT_ENDINDEX = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t startIndex() const {
    return GetField<int32_t>(VT_STARTINDEX, 0);
  }
  int32_t endIndex() const {
    return GetField<int32_t>(VT_ENDINDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_STARTINDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDINDEX, 4) &&
           verifier.EndTable();
  }
};

struct AnimationInfoBuilder {
  typedef AnimationInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnimationInfo::VT_NAME, name);
  }
  void add_startIndex(int32_t startIndex) {
    fbb_.AddElement<int32_t>(AnimationInfo::VT_STARTINDEX, startIndex, 0);
  }
  void add_endIndex(int32_t endIndex) {
    fbb_.AddElement<int32_t>(AnimationInfo::VT_ENDINDEX, endIndex, 0);
  }
  explicit AnimationInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationInfo> CreateAnimationInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t startIndex = 0,
    int32_t endIndex = 0) {
  AnimationInfoBuilder builder_(_fbb);
  builder_.add_endIndex(endIndex);
  builder_.add_startIndex(startIndex);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimationInfo> CreateAnimationInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t startIndex = 0,
    int32_t endIndex = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbuffers::CreateAnimationInfo(
      _fbb,
      name__,
      startIndex,
      endIndex);
}

struct NodeAction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DURATION = 4,
    VT_SPEED = 6,
    VT_TIMELINES = 8,
    VT_CURRENTANIMATIONNAME = 10
  };
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::TimeLine>> *timeLines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::TimeLine>> *>(VT_TIMELINES);
  }
  const ::flatbuffers::String *currentAnimationName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTANIMATIONNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DURATION, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_TIMELINES) &&
           verifier.VerifyVector(timeLines()) &&
           verifier.VerifyVectorOfTables(timeLines()) &&
           VerifyOffset(verifier, VT_CURRENTANIMATIONNAME) &&
           verifier.VerifyString(currentAnimationName()) &&
           verifier.EndTable();
  }
};

struct NodeActionBuilder {
  typedef NodeAction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(NodeAction::VT_DURATION, duration, 0);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(NodeAction::VT_SPEED, speed, 0.0f);
  }
  void add_timeLines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::TimeLine>>> timeLines) {
    fbb_.AddOffset(NodeAction::VT_TIMELINES, timeLines);
  }
  void add_currentAnimationName(::flatbuffers::Offset<::flatbuffers::String> currentAnimationName) {
    fbb_.AddOffset(NodeAction::VT_CURRENTANIMATIONNAME, currentAnimationName);
  }
  explicit NodeActionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeAction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeAction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeAction> CreateNodeAction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t duration = 0,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::TimeLine>>> timeLines = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentAnimationName = 0) {
  NodeActionBuilder builder_(_fbb);
  builder_.add_currentAnimationName(currentAnimationName);
  builder_.add_timeLines(timeLines);
  builder_.add_speed(speed);
  builder_.add_duration(duration);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NodeAction> CreateNodeActionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t duration = 0,
    float speed = 0.0f,
    const std::vector<::flatbuffers::Offset<flatbuffers::TimeLine>> *timeLines = nullptr,
    const char *currentAnimationName = nullptr) {
  auto timeLines__ = timeLines ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::TimeLine>>(*timeLines) : 0;
  auto currentAnimationName__ = currentAnimationName ? _fbb.CreateString(currentAnimationName) : 0;
  return flatbuffers::CreateNodeAction(
      _fbb,
      duration,
      speed,
      timeLines__,
      currentAnimationName__);
}

struct TimeLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTY = 4,
    VT_ACTIONTAG = 6,
    VT_FRAMES = 8
  };
  const ::flatbuffers::String *property() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROPERTY);
  }
  int32_t actionTag() const {
    return GetField<int32_t>(VT_ACTIONTAG, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Frame>> *frames() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Frame>> *>(VT_FRAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROPERTY) &&
           verifier.VerifyString(property()) &&
           VerifyField<int32_t>(verifier, VT_ACTIONTAG, 4) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.VerifyVector(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           verifier.EndTable();
  }
};

struct TimeLineBuilder {
  typedef TimeLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_property(::flatbuffers::Offset<::flatbuffers::String> property) {
    fbb_.AddOffset(TimeLine::VT_PROPERTY, property);
  }
  void add_actionTag(int32_t actionTag) {
    fbb_.AddElement<int32_t>(TimeLine::VT_ACTIONTAG, actionTag, 0);
  }
  void add_frames(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Frame>>> frames) {
    fbb_.AddOffset(TimeLine::VT_FRAMES, frames);
  }
  explicit TimeLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TimeLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TimeLine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TimeLine> CreateTimeLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> property = 0,
    int32_t actionTag = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Frame>>> frames = 0) {
  TimeLineBuilder builder_(_fbb);
  builder_.add_frames(frames);
  builder_.add_actionTag(actionTag);
  builder_.add_property(property);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TimeLine> CreateTimeLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *property = nullptr,
    int32_t actionTag = 0,
    const std::vector<::flatbuffers::Offset<flatbuffers::Frame>> *frames = nullptr) {
  auto property__ = property ? _fbb.CreateString(property) : 0;
  auto frames__ = frames ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::Frame>>(*frames) : 0;
  return flatbuffers::CreateTimeLine(
      _fbb,
      property__,
      actionTag,
      frames__);
}

struct Frame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTFRAME = 4,
    VT_SCALEFRAME = 6,
    VT_COLORFRAME = 8,
    VT_TEXTUREFRAME = 10,
    VT_EVENTFRAME = 12,
    VT_INTFRAME = 14,
    VT_BOOLFRAME = 16,
    VT_INNERACTIONFRAME = 18,
    VT_BLENDFRAME = 20
  };
  const flatbuffers::PointFrame *pointFrame() const {
    return GetPointer<const flatbuffers::PointFrame *>(VT_POINTFRAME);
  }
  const flatbuffers::ScaleFrame *scaleFrame() const {
    return GetPointer<const flatbuffers::ScaleFrame *>(VT_SCALEFRAME);
  }
  const flatbuffers::ColorFrame *colorFrame() const {
    return GetPointer<const flatbuffers::ColorFrame *>(VT_COLORFRAME);
  }
  const flatbuffers::TextureFrame *textureFrame() const {
    return GetPointer<const flatbuffers::TextureFrame *>(VT_TEXTUREFRAME);
  }
  const flatbuffers::EventFrame *eventFrame() const {
    return GetPointer<const flatbuffers::EventFrame *>(VT_EVENTFRAME);
  }
  const flatbuffers::IntFrame *intFrame() const {
    return GetPointer<const flatbuffers::IntFrame *>(VT_INTFRAME);
  }
  const flatbuffers::BoolFrame *boolFrame() const {
    return GetPointer<const flatbuffers::BoolFrame *>(VT_BOOLFRAME);
  }
  const flatbuffers::InnerActionFrame *innerActionFrame() const {
    return GetPointer<const flatbuffers::InnerActionFrame *>(VT_INNERACTIONFRAME);
  }
  const flatbuffers::BlendFrame *blendFrame() const {
    return GetPointer<const flatbuffers::BlendFrame *>(VT_BLENDFRAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTFRAME) &&
           verifier.VerifyTable(pointFrame()) &&
           VerifyOffset(verifier, VT_SCALEFRAME) &&
           verifier.VerifyTable(scaleFrame()) &&
           VerifyOffset(verifier, VT_COLORFRAME) &&
           verifier.VerifyTable(colorFrame()) &&
           VerifyOffset(verifier, VT_TEXTUREFRAME) &&
           verifier.VerifyTable(textureFrame()) &&
           VerifyOffset(verifier, VT_EVENTFRAME) &&
           verifier.VerifyTable(eventFrame()) &&
           VerifyOffset(verifier, VT_INTFRAME) &&
           verifier.VerifyTable(intFrame()) &&
           VerifyOffset(verifier, VT_BOOLFRAME) &&
           verifier.VerifyTable(boolFrame()) &&
           VerifyOffset(verifier, VT_INNERACTIONFRAME) &&
           verifier.VerifyTable(innerActionFrame()) &&
           VerifyOffset(verifier, VT_BLENDFRAME) &&
           verifier.VerifyTable(blendFrame()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  typedef Frame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pointFrame(::flatbuffers::Offset<flatbuffers::PointFrame> pointFrame) {
    fbb_.AddOffset(Frame::VT_POINTFRAME, pointFrame);
  }
  void add_scaleFrame(::flatbuffers::Offset<flatbuffers::ScaleFrame> scaleFrame) {
    fbb_.AddOffset(Frame::VT_SCALEFRAME, scaleFrame);
  }
  void add_colorFrame(::flatbuffers::Offset<flatbuffers::ColorFrame> colorFrame) {
    fbb_.AddOffset(Frame::VT_COLORFRAME, colorFrame);
  }
  void add_textureFrame(::flatbuffers::Offset<flatbuffers::TextureFrame> textureFrame) {
    fbb_.AddOffset(Frame::VT_TEXTUREFRAME, textureFrame);
  }
  void add_eventFrame(::flatbuffers::Offset<flatbuffers::EventFrame> eventFrame) {
    fbb_.AddOffset(Frame::VT_EVENTFRAME, eventFrame);
  }
  void add_intFrame(::flatbuffers::Offset<flatbuffers::IntFrame> intFrame) {
    fbb_.AddOffset(Frame::VT_INTFRAME, intFrame);
  }
  void add_boolFrame(::flatbuffers::Offset<flatbuffers::BoolFrame> boolFrame) {
    fbb_.AddOffset(Frame::VT_BOOLFRAME, boolFrame);
  }
  void add_innerActionFrame(::flatbuffers::Offset<flatbuffers::InnerActionFrame> innerActionFrame) {
    fbb_.AddOffset(Frame::VT_INNERACTIONFRAME, innerActionFrame);
  }
  void add_blendFrame(::flatbuffers::Offset<flatbuffers::BlendFrame> blendFrame) {
    fbb_.AddOffset(Frame::VT_BLENDFRAME, blendFrame);
  }
  explicit FrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Frame> CreateFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::PointFrame> pointFrame = 0,
    ::flatbuffers::Offset<flatbuffers::ScaleFrame> scaleFrame = 0,
    ::flatbuffers::Offset<flatbuffers::ColorFrame> colorFrame = 0,
    ::flatbuffers::Offset<flatbuffers::TextureFrame> textureFrame = 0,
    ::flatbuffers::Offset<flatbuffers::EventFrame> eventFrame = 0,
    ::flatbuffers::Offset<flatbuffers::IntFrame> intFrame = 0,
    ::flatbuffers::Offset<flatbuffers::BoolFrame> boolFrame = 0,
    ::flatbuffers::Offset<flatbuffers::InnerActionFrame> innerActionFrame = 0,
    ::flatbuffers::Offset<flatbuffers::BlendFrame> blendFrame = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_blendFrame(blendFrame);
  builder_.add_innerActionFrame(innerActionFrame);
  builder_.add_boolFrame(boolFrame);
  builder_.add_intFrame(intFrame);
  builder_.add_eventFrame(eventFrame);
  builder_.add_textureFrame(textureFrame);
  builder_.add_colorFrame(colorFrame);
  builder_.add_scaleFrame(scaleFrame);
  builder_.add_pointFrame(pointFrame);
  return builder_.Finish();
}

struct PointFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_POSITION = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const flatbuffers::FVec2 *position() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_POSITION);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_POSITION, 4) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct PointFrameBuilder {
  typedef PointFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(PointFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(PointFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_position(const flatbuffers::FVec2 *position) {
    fbb_.AddStruct(PointFrame::VT_POSITION, position);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(PointFrame::VT_EASINGDATA, easingData);
  }
  explicit PointFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointFrame> CreatePointFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    const flatbuffers::FVec2 *position = nullptr,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  PointFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_position(position);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct ScaleFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScaleFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_SCALE = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const flatbuffers::FVec2 *scale() const {
    return GetStruct<const flatbuffers::FVec2 *>(VT_SCALE);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<flatbuffers::FVec2>(verifier, VT_SCALE, 4) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct ScaleFrameBuilder {
  typedef ScaleFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(ScaleFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(ScaleFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_scale(const flatbuffers::FVec2 *scale) {
    fbb_.AddStruct(ScaleFrame::VT_SCALE, scale);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(ScaleFrame::VT_EASINGDATA, easingData);
  }
  explicit ScaleFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScaleFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScaleFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScaleFrame> CreateScaleFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    const flatbuffers::FVec2 *scale = nullptr,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  ScaleFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_scale(scale);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct ColorFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_COLOR = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const flatbuffers::FColor *color() const {
    return GetStruct<const flatbuffers::FColor *>(VT_COLOR);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<flatbuffers::FColor>(verifier, VT_COLOR, 1) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct ColorFrameBuilder {
  typedef ColorFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(ColorFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(ColorFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_color(const flatbuffers::FColor *color) {
    fbb_.AddStruct(ColorFrame::VT_COLOR, color);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(ColorFrame::VT_EASINGDATA, easingData);
  }
  explicit ColorFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColorFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColorFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ColorFrame> CreateColorFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    const flatbuffers::FColor *color = nullptr,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  ColorFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_color(color);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct TextureFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextureFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_TEXTUREFILE = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const flatbuffers::ResourceData *textureFile() const {
    return GetPointer<const flatbuffers::ResourceData *>(VT_TEXTUREFILE);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyOffset(verifier, VT_TEXTUREFILE) &&
           verifier.VerifyTable(textureFile()) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct TextureFrameBuilder {
  typedef TextureFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(TextureFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(TextureFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_textureFile(::flatbuffers::Offset<flatbuffers::ResourceData> textureFile) {
    fbb_.AddOffset(TextureFrame::VT_TEXTUREFILE, textureFile);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(TextureFrame::VT_EASINGDATA, easingData);
  }
  explicit TextureFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextureFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextureFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextureFrame> CreateTextureFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    ::flatbuffers::Offset<flatbuffers::ResourceData> textureFile = 0,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  TextureFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_textureFile(textureFile);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct EventFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_VALUE = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct EventFrameBuilder {
  typedef EventFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(EventFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(EventFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(EventFrame::VT_VALUE, value);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(EventFrame::VT_EASINGDATA, easingData);
  }
  explicit EventFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventFrame> CreateEventFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  EventFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_value(value);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventFrame> CreateEventFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    const char *value = nullptr,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flatbuffers::CreateEventFrame(
      _fbb,
      frameIndex,
      tween,
      value__,
      easingData);
}

struct IntFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_VALUE = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct IntFrameBuilder {
  typedef IntFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(IntFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(IntFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntFrame::VT_VALUE, value, 0);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(IntFrame::VT_EASINGDATA, easingData);
  }
  explicit IntFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntFrame> CreateIntFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    int32_t value = 0,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  IntFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_value(value);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct BoolFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_VALUE = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 1) != 0;
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct BoolFrameBuilder {
  typedef BoolFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(BoolFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(BoolFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BoolFrame::VT_VALUE, static_cast<uint8_t>(value), 1);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(BoolFrame::VT_EASINGDATA, easingData);
  }
  explicit BoolFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolFrame> CreateBoolFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    bool value = true,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  BoolFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_frameIndex(frameIndex);
  builder_.add_value(value);
  builder_.add_tween(tween);
  return builder_.Finish();
}

struct InnerActionFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InnerActionFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_INNERACTIONTYPE = 8,
    VT_CURRENTANIAMTIONNAME = 10,
    VT_SINGLEFRAMEINDEX = 12,
    VT_EASINGDATA = 14
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  int32_t innerActionType() const {
    return GetField<int32_t>(VT_INNERACTIONTYPE, 0);
  }
  const ::flatbuffers::String *currentAniamtionName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTANIAMTIONNAME);
  }
  int32_t singleFrameIndex() const {
    return GetField<int32_t>(VT_SINGLEFRAMEINDEX, 0);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<int32_t>(verifier, VT_INNERACTIONTYPE, 4) &&
           VerifyOffset(verifier, VT_CURRENTANIAMTIONNAME) &&
           verifier.VerifyString(currentAniamtionName()) &&
           VerifyField<int32_t>(verifier, VT_SINGLEFRAMEINDEX, 4) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct InnerActionFrameBuilder {
  typedef InnerActionFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(InnerActionFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(InnerActionFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_innerActionType(int32_t innerActionType) {
    fbb_.AddElement<int32_t>(InnerActionFrame::VT_INNERACTIONTYPE, innerActionType, 0);
  }
  void add_currentAniamtionName(::flatbuffers::Offset<::flatbuffers::String> currentAniamtionName) {
    fbb_.AddOffset(InnerActionFrame::VT_CURRENTANIAMTIONNAME, currentAniamtionName);
  }
  void add_singleFrameIndex(int32_t singleFrameIndex) {
    fbb_.AddElement<int32_t>(InnerActionFrame::VT_SINGLEFRAMEINDEX, singleFrameIndex, 0);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(InnerActionFrame::VT_EASINGDATA, easingData);
  }
  explicit InnerActionFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InnerActionFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InnerActionFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InnerActionFrame> CreateInnerActionFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    int32_t innerActionType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentAniamtionName = 0,
    int32_t singleFrameIndex = 0,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  InnerActionFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_singleFrameIndex(singleFrameIndex);
  builder_.add_currentAniamtionName(currentAniamtionName);
  builder_.add_innerActionType(innerActionType);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InnerActionFrame> CreateInnerActionFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    int32_t innerActionType = 0,
    const char *currentAniamtionName = nullptr,
    int32_t singleFrameIndex = 0,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  auto currentAniamtionName__ = currentAniamtionName ? _fbb.CreateString(currentAniamtionName) : 0;
  return flatbuffers::CreateInnerActionFrame(
      _fbb,
      frameIndex,
      tween,
      innerActionType,
      currentAniamtionName__,
      singleFrameIndex,
      easingData);
}

struct EasingData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EasingDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_POINTS = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -1);
  }
  const ::flatbuffers::Vector<const flatbuffers::FVec2 *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const flatbuffers::FVec2 *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct EasingDataBuilder {
  typedef EasingData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(EasingData::VT_TYPE, type, -1);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const flatbuffers::FVec2 *>> points) {
    fbb_.AddOffset(EasingData::VT_POINTS, points);
  }
  explicit EasingDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EasingData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EasingData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EasingData> CreateEasingData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<const flatbuffers::FVec2 *>> points = 0) {
  EasingDataBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EasingData> CreateEasingDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -1,
    const std::vector<flatbuffers::FVec2> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<flatbuffers::FVec2>(*points) : 0;
  return flatbuffers::CreateEasingData(
      _fbb,
      type,
      points__);
}

struct ResourceData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_PLISTFILE = 6,
    VT_RESOURCETYPE = 8
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  const ::flatbuffers::String *plistFile() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLISTFILE);
  }
  int32_t resourceType() const {
    return GetField<int32_t>(VT_RESOURCETYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_PLISTFILE) &&
           verifier.VerifyString(plistFile()) &&
           VerifyField<int32_t>(verifier, VT_RESOURCETYPE, 4) &&
           verifier.EndTable();
  }
};

struct ResourceDataBuilder {
  typedef ResourceData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(ResourceData::VT_PATH, path);
  }
  void add_plistFile(::flatbuffers::Offset<::flatbuffers::String> plistFile) {
    fbb_.AddOffset(ResourceData::VT_PLISTFILE, plistFile);
  }
  void add_resourceType(int32_t resourceType) {
    fbb_.AddElement<int32_t>(ResourceData::VT_RESOURCETYPE, resourceType, 0);
  }
  explicit ResourceDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceData> CreateResourceData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> plistFile = 0,
    int32_t resourceType = 0) {
  ResourceDataBuilder builder_(_fbb);
  builder_.add_resourceType(resourceType);
  builder_.add_plistFile(plistFile);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceData> CreateResourceDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    const char *plistFile = nullptr,
    int32_t resourceType = 0) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  auto plistFile__ = plistFile ? _fbb.CreateString(plistFile) : 0;
  return flatbuffers::CreateResourceData(
      _fbb,
      path__,
      plistFile__,
      resourceType);
}

struct BlendFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlendFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEINDEX = 4,
    VT_TWEEN = 6,
    VT_BLENDFUNC = 8,
    VT_EASINGDATA = 10
  };
  int32_t frameIndex() const {
    return GetField<int32_t>(VT_FRAMEINDEX, 0);
  }
  bool tween() const {
    return GetField<uint8_t>(VT_TWEEN, 1) != 0;
  }
  const flatbuffers::BlendFunc *blendFunc() const {
    return GetStruct<const flatbuffers::BlendFunc *>(VT_BLENDFUNC);
  }
  const flatbuffers::EasingData *easingData() const {
    return GetPointer<const flatbuffers::EasingData *>(VT_EASINGDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAMEINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_TWEEN, 1) &&
           VerifyField<flatbuffers::BlendFunc>(verifier, VT_BLENDFUNC, 4) &&
           VerifyOffset(verifier, VT_EASINGDATA) &&
           verifier.VerifyTable(easingData()) &&
           verifier.EndTable();
  }
};

struct BlendFrameBuilder {
  typedef BlendFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frameIndex(int32_t frameIndex) {
    fbb_.AddElement<int32_t>(BlendFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_tween(bool tween) {
    fbb_.AddElement<uint8_t>(BlendFrame::VT_TWEEN, static_cast<uint8_t>(tween), 1);
  }
  void add_blendFunc(const flatbuffers::BlendFunc *blendFunc) {
    fbb_.AddStruct(BlendFrame::VT_BLENDFUNC, blendFunc);
  }
  void add_easingData(::flatbuffers::Offset<flatbuffers::EasingData> easingData) {
    fbb_.AddOffset(BlendFrame::VT_EASINGDATA, easingData);
  }
  explicit BlendFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlendFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlendFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlendFrame> CreateBlendFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frameIndex = 0,
    bool tween = true,
    const flatbuffers::BlendFunc *blendFunc = nullptr,
    ::flatbuffers::Offset<flatbuffers::EasingData> easingData = 0) {
  BlendFrameBuilder builder_(_fbb);
  builder_.add_easingData(easingData);
  builder_.add_blendFunc(blendFunc);
  builder_.add_frameIndex(frameIndex);
  builder_.add_tween(tween);
  return builder_.Finish();
}

inline const flatbuffers::CSParseBinary *GetCSParseBinary(const void *buf) {
  return ::flatbuffers::GetRoot<flatbuffers::CSParseBinary>(buf);
}

inline const flatbuffers::CSParseBinary *GetSizePrefixedCSParseBinary(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<flatbuffers::CSParseBinary>(buf);
}

inline bool VerifyCSParseBinaryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flatbuffers::CSParseBinary>(nullptr);
}

inline bool VerifySizePrefixedCSParseBinaryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flatbuffers::CSParseBinary>(nullptr);
}

inline void FinishCSParseBinaryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::CSParseBinary> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCSParseBinaryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::CSParseBinary> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_CSPARSEBINARY_FLATBUFFERS_H_
