#include "lua-bindings/auto/axlua_base_auto.hpp"
#include "cocos2d.h"
#include "2d/ProtectedNode.h"
#include "base/AsyncTaskPool.h"
#include "lua-bindings/manual/ComponentLua.h"
#include "renderer/Renderer.h"
#include "renderer/PipelineDescriptor.h"
#include "renderer/backend/RenderTarget.h"
#include "lua-bindings/manual/tolua_fix.h"
#include "lua-bindings/manual/LuaBasicConversions.h"

int lua_ax_base_Object_retain(lua_State* tolua_S)
{
    int argc = 0;
    ax::Object* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Object",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Object*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Object_retain'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Object_retain'", nullptr);
            return 0;
        }
        cobj->retain();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Object:retain",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Object_retain'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Object_release(lua_State* tolua_S)
{
    int argc = 0;
    ax::Object* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Object",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Object*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Object_release'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Object_release'", nullptr);
            return 0;
        }
        cobj->release();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Object:release",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Object_release'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Object_getReferenceCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::Object* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Object",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Object*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Object_getReferenceCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Object_getReferenceCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getReferenceCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Object:getReferenceCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Object_getReferenceCount'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_Object_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Object)");
    return 0;
}

int lua_register_ax_base_Object(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Object");
    tolua_cclass(tolua_S,"Object","ax.Object","",nullptr);

    tolua_beginmodule(tolua_S,"Object");
        tolua_function(tolua_S,"retain",lua_ax_base_Object_retain);
        tolua_function(tolua_S,"release",lua_ax_base_Object_release);
        tolua_function(tolua_S,"getReferenceCount",lua_ax_base_Object_getReferenceCount);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Object).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Object";
    g_typeCast[typeName] = "ax.Object";
    return 1;
}

int lua_ax_base_EventListener_checkAvailable(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListener* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListener",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListener*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListener_checkAvailable'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListener_checkAvailable'", nullptr);
            return 0;
        }
        auto&& ret = cobj->checkAvailable();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListener:checkAvailable",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListener_checkAvailable'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListener_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListener* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListener",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListener*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListener_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListener_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::EventListener>(tolua_S, "ax.EventListener",(ax::EventListener*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListener:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListener_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListener_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListener* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListener",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListener*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListener_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.EventListener:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListener_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListener:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListener_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListener_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListener* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListener",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListener*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListener_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListener_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListener:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListener_isEnabled'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_EventListener_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListener)");
    return 0;
}

int lua_register_ax_base_EventListener(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListener");
    tolua_cclass(tolua_S,"EventListener","ax.EventListener","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"EventListener");
        tolua_function(tolua_S,"checkAvailable",lua_ax_base_EventListener_checkAvailable);
        tolua_function(tolua_S,"clone",lua_ax_base_EventListener_clone);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_EventListener_setEnabled);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_EventListener_isEnabled);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListener).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListener";
    g_typeCast[typeName] = "ax.EventListener";
    return 1;
}

int lua_ax_base_EventListenerCustom_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerCustom* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerCustom_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerCustom();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerCustom");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerCustom:EventListenerCustom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerCustom_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerCustom_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerCustom)");
    return 0;
}

int lua_register_ax_base_EventListenerCustom(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerCustom");
    tolua_cclass(tolua_S,"EventListenerCustom","ax.EventListenerCustom","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerCustom");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerCustom_constructor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerCustom).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerCustom";
    g_typeCast[typeName] = "ax.EventListenerCustom";
    return 1;
}

int lua_ax_base_ShaderCache_purge(lua_State* tolua_S)
{
    int argc = 0;
    ax::backend::ShaderCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::backend::ShaderCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShaderCache_purge'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_purge'", nullptr);
            return 0;
        }
        cobj->purge();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "axb.ShaderCache:purge",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_purge'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShaderCache_newVertexShaderModule(lua_State* tolua_S)
{
    int argc = 0;
    ax::backend::ShaderCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::backend::ShaderCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShaderCache_newVertexShaderModule'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "axb.ShaderCache:newVertexShaderModule");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_newVertexShaderModule'", nullptr);
            return 0;
        }
        auto&& ret = cobj->newVertexShaderModule(arg0);
        object_to_luaval<ax::backend::ShaderModule>(tolua_S, "axb.ShaderModule",(ax::backend::ShaderModule*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "axb.ShaderCache:newVertexShaderModule",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_newVertexShaderModule'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShaderCache_newFragmentShaderModule(lua_State* tolua_S)
{
    int argc = 0;
    ax::backend::ShaderCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::backend::ShaderCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShaderCache_newFragmentShaderModule'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "axb.ShaderCache:newFragmentShaderModule");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_newFragmentShaderModule'", nullptr);
            return 0;
        }
        auto&& ret = cobj->newFragmentShaderModule(arg0);
        object_to_luaval<ax::backend::ShaderModule>(tolua_S, "axb.ShaderModule",(ax::backend::ShaderModule*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "axb.ShaderCache:newFragmentShaderModule",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_newFragmentShaderModule'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShaderCache_removeUnusedShader(lua_State* tolua_S)
{
    int argc = 0;
    ax::backend::ShaderCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::backend::ShaderCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShaderCache_removeUnusedShader'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_removeUnusedShader'", nullptr);
            return 0;
        }
        cobj->removeUnusedShader();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "axb.ShaderCache:removeUnusedShader",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_removeUnusedShader'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShaderCache_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::backend::ShaderCache::getInstance();
        object_to_luaval<ax::backend::ShaderCache>(tolua_S, "axb.ShaderCache",(ax::backend::ShaderCache*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "axb.ShaderCache:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ShaderCache_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"axb.ShaderCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShaderCache_destroyInstance'", nullptr);
            return 0;
        }
        ax::backend::ShaderCache::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "axb.ShaderCache:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShaderCache_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_ShaderCache_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ShaderCache)");
    return 0;
}

int lua_register_ax_base_ShaderCache(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"axb.ShaderCache");
    tolua_cclass(tolua_S,"ShaderCache","axb.ShaderCache","",nullptr);

    tolua_beginmodule(tolua_S,"ShaderCache");
        tolua_function(tolua_S,"purge",lua_ax_base_ShaderCache_purge);
        tolua_function(tolua_S,"newVertexShaderModule",lua_ax_base_ShaderCache_newVertexShaderModule);
        tolua_function(tolua_S,"newFragmentShaderModule",lua_ax_base_ShaderCache_newFragmentShaderModule);
        tolua_function(tolua_S,"removeUnusedShader",lua_ax_base_ShaderCache_removeUnusedShader);
        tolua_function(tolua_S,"getInstance", lua_ax_base_ShaderCache_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_ShaderCache_destroyInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::backend::ShaderCache).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "axb.ShaderCache";
    g_typeCast[typeName] = "axb.ShaderCache";
    return 1;
}

int lua_ax_base_Texture2D_updateWithImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_updateWithImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Image* arg0;
        ax::backend::PixelFormat arg1;

        ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.Texture2D:updateWithImage");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithImage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithImage(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        ax::Image* arg0;
        ax::backend::PixelFormat arg1;
        int arg2;

        ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.Texture2D:updateWithImage");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithImage");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithImage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithImage(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:updateWithImage",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_updateWithImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_updateWithMipmaps(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_updateWithMipmaps'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 6) 
    {
        ax::_MipmapInfo* arg0;
        int arg1;
        ax::backend::PixelFormat arg2;
        ax::backend::PixelFormat arg3;
        int arg4;
        int arg5;

        #pragma warning NO CONVERSION TO NATIVE FOR _MipmapInfo*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:updateWithMipmaps");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithMipmaps'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithMipmaps(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 7) 
    {
        ax::_MipmapInfo* arg0;
        int arg1;
        ax::backend::PixelFormat arg2;
        ax::backend::PixelFormat arg3;
        int arg4;
        int arg5;
        bool arg6;

        #pragma warning NO CONVERSION TO NATIVE FOR _MipmapInfo*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_boolean(tolua_S, 8,&arg6, "ax.Texture2D:updateWithMipmaps");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithMipmaps'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithMipmaps(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 8) 
    {
        ax::_MipmapInfo* arg0;
        int arg1;
        ax::backend::PixelFormat arg2;
        ax::backend::PixelFormat arg3;
        int arg4;
        int arg5;
        bool arg6;
        int arg7;

        #pragma warning NO CONVERSION TO NATIVE FOR _MipmapInfo*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_boolean(tolua_S, 8,&arg6, "ax.Texture2D:updateWithMipmaps");

        ok &= luaval_to_int32(tolua_S, 9,(int *)&arg7, "ax.Texture2D:updateWithMipmaps");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithMipmaps'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithMipmaps(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:updateWithMipmaps",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_updateWithMipmaps'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_updateWithSubData(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_updateWithSubData'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        void* arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:updateWithSubData");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithSubData'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithSubData(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 6) 
    {
        void* arg0;
        int arg1;
        int arg2;
        int arg3;
        int arg4;
        int arg5;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:updateWithSubData");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:updateWithSubData");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateWithSubData'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateWithSubData(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:updateWithSubData",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_updateWithSubData'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_drawAtPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_drawAtPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Vec2 arg0;
        double arg1;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Texture2D:drawAtPoint");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Texture2D:drawAtPoint");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_drawAtPoint'", nullptr);
            return 0;
        }
        cobj->drawAtPoint(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:drawAtPoint",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_drawAtPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_drawInRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_drawInRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Rect arg0;
        double arg1;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Texture2D:drawInRect");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Texture2D:drawInRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_drawInRect'", nullptr);
            return 0;
        }
        cobj->drawInRect(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:drawInRect",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_drawInRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_initWithImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_initWithImage'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::Image* arg0;
            ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.Texture2D:initWithImage");

            if (!ok) { break; }
            ax::backend::PixelFormat arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Texture2D:initWithImage");

            if (!ok) { break; }
            bool ret = cobj->initWithImage(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Image* arg0;
            ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.Texture2D:initWithImage");

            if (!ok) { break; }
            bool ret = cobj->initWithImage(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Texture2D:initWithImage",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_initWithImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_initWithString(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_initWithString'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::FontDefinition arg1;
            ok &= luaval_to_fontdefinition(tolua_S, 3, &arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextVAlignment arg5;
            ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 7) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextVAlignment arg5;
            ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool arg6;
            ok &= luaval_to_boolean(tolua_S, 8,&arg6, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 8) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            ax::TextVAlignment arg5;
            ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool arg6;
            ok &= luaval_to_boolean(tolua_S, 8,&arg6, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            int arg7;
            ok &= luaval_to_int32(tolua_S, 9,(int *)&arg7, "ax.Texture2D:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Texture2D:initWithString",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_initWithString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_updateTextureDescriptor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_updateTextureDescriptor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::TextureDescriptor arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR TextureDescriptor
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateTextureDescriptor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateTextureDescriptor(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        ax::backend::TextureDescriptor arg0;
        bool arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR TextureDescriptor
		ok = false;

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Texture2D:updateTextureDescriptor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_updateTextureDescriptor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->updateTextureDescriptor(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:updateTextureDescriptor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_updateTextureDescriptor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Texture2D:setRenderTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setRenderTarget'", nullptr);
            return 0;
        }
        cobj->setRenderTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setRenderTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_isRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_isRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_isRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isRenderTarget();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:isRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_isRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_generateMipmap(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_generateMipmap'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_generateMipmap'", nullptr);
            return 0;
        }
        cobj->generateMipmap();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:generateMipmap",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_generateMipmap'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setAntiAliasTexParameters(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setAntiAliasTexParameters'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setAntiAliasTexParameters'", nullptr);
            return 0;
        }
        cobj->setAntiAliasTexParameters();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setAntiAliasTexParameters",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setAntiAliasTexParameters'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setAliasTexParameters(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setAliasTexParameters'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setAliasTexParameters'", nullptr);
            return 0;
        }
        cobj->setAliasTexParameters();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setAliasTexParameters",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setAliasTexParameters'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getStringForFormat(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getStringForFormat'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getStringForFormat'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStringForFormat();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getStringForFormat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getStringForFormat'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getBitsPerPixelForFormat(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getBitsPerPixelForFormat'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::backend::PixelFormat arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Texture2D:getBitsPerPixelForFormat");

            if (!ok) { break; }
            unsigned int ret = cobj->getBitsPerPixelForFormat(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            unsigned int ret = cobj->getBitsPerPixelForFormat();
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Texture2D:getBitsPerPixelForFormat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getBitsPerPixelForFormat'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getContentSizeInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getContentSizeInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getContentSizeInPixels'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getContentSizeInPixels();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getContentSizeInPixels",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getContentSizeInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_hasPremultipliedAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_hasPremultipliedAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_hasPremultipliedAlpha'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasPremultipliedAlpha();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:hasPremultipliedAlpha",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_hasPremultipliedAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setPremultipliedAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setPremultipliedAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Texture2D:setPremultipliedAlpha");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setPremultipliedAlpha'", nullptr);
            return 0;
        }
        cobj->setPremultipliedAlpha(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setPremultipliedAlpha",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setPremultipliedAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_hasMipmaps(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_hasMipmaps'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_hasMipmaps'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasMipmaps();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:hasMipmaps",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_hasMipmaps'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getPixelFormat(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getPixelFormat'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getPixelFormat'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getPixelFormat();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getPixelFormat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getPixelFormat'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getSamplerFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getSamplerFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getSamplerFlags'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSamplerFlags();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getSamplerFlags",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getSamplerFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getPixelsWide(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getPixelsWide'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getPixelsWide'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPixelsWide();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getPixelsWide",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getPixelsWide'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getPixelsHigh(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getPixelsHigh'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getPixelsHigh'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPixelsHigh();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getPixelsHigh",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getPixelsHigh'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getBackendTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getBackendTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getBackendTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBackendTexture();
        object_to_luaval<ax::backend::TextureBackend>(tolua_S, "axb.TextureBackend",(ax::backend::TextureBackend*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getBackendTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getBackendTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getMaxS(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getMaxS'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getMaxS'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMaxS();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getMaxS",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getMaxS'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setMaxS(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setMaxS'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Texture2D:setMaxS");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setMaxS'", nullptr);
            return 0;
        }
        cobj->setMaxS(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setMaxS",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setMaxS'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getMaxT(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getMaxT'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getMaxT'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMaxT();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getMaxT",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getMaxT'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setMaxT(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_setMaxT'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Texture2D:setMaxT");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setMaxT'", nullptr);
            return 0;
        }
        cobj->setMaxT(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:setMaxT",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setMaxT'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getContentSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getContentSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getContentSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getContentSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getContentSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getContentSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_getPath(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Texture2D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Texture2D_getPath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getPath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPath();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:getPath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getPath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Texture2D_setDefaultAlphaPixelFormat(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::backend::PixelFormat arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Texture2D:setDefaultAlphaPixelFormat");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_setDefaultAlphaPixelFormat'", nullptr);
            return 0;
        }
        ax::Texture2D::setDefaultAlphaPixelFormat(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Texture2D:setDefaultAlphaPixelFormat",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_setDefaultAlphaPixelFormat'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Texture2D_getDefaultAlphaPixelFormat(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Texture2D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_getDefaultAlphaPixelFormat'", nullptr);
            return 0;
        }
        int ret = (int)ax::Texture2D::getDefaultAlphaPixelFormat();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Texture2D:getDefaultAlphaPixelFormat",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_getDefaultAlphaPixelFormat'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Texture2D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Texture2D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Texture2D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Texture2D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Texture2D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Texture2D:Texture2D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Texture2D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Texture2D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Texture2D)");
    return 0;
}

int lua_register_ax_base_Texture2D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Texture2D");
    tolua_cclass(tolua_S,"Texture2D","ax.Texture2D","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Texture2D");
        tolua_function(tolua_S,"new",lua_ax_base_Texture2D_constructor);
        tolua_function(tolua_S,"updateWithImage",lua_ax_base_Texture2D_updateWithImage);
        tolua_function(tolua_S,"updateWithMipmaps",lua_ax_base_Texture2D_updateWithMipmaps);
        tolua_function(tolua_S,"updateWithSubData",lua_ax_base_Texture2D_updateWithSubData);
        tolua_function(tolua_S,"drawAtPoint",lua_ax_base_Texture2D_drawAtPoint);
        tolua_function(tolua_S,"drawInRect",lua_ax_base_Texture2D_drawInRect);
        tolua_function(tolua_S,"initWithImage",lua_ax_base_Texture2D_initWithImage);
        tolua_function(tolua_S,"initWithString",lua_ax_base_Texture2D_initWithString);
        tolua_function(tolua_S,"updateTextureDescriptor",lua_ax_base_Texture2D_updateTextureDescriptor);
        tolua_function(tolua_S,"setRenderTarget",lua_ax_base_Texture2D_setRenderTarget);
        tolua_function(tolua_S,"isRenderTarget",lua_ax_base_Texture2D_isRenderTarget);
        tolua_function(tolua_S,"generateMipmap",lua_ax_base_Texture2D_generateMipmap);
        tolua_function(tolua_S,"setAntiAliasTexParameters",lua_ax_base_Texture2D_setAntiAliasTexParameters);
        tolua_function(tolua_S,"setAliasTexParameters",lua_ax_base_Texture2D_setAliasTexParameters);
        tolua_function(tolua_S,"getStringForFormat",lua_ax_base_Texture2D_getStringForFormat);
        tolua_function(tolua_S,"getBitsPerPixelForFormat",lua_ax_base_Texture2D_getBitsPerPixelForFormat);
        tolua_function(tolua_S,"getContentSizeInPixels",lua_ax_base_Texture2D_getContentSizeInPixels);
        tolua_function(tolua_S,"hasPremultipliedAlpha",lua_ax_base_Texture2D_hasPremultipliedAlpha);
        tolua_function(tolua_S,"setPremultipliedAlpha",lua_ax_base_Texture2D_setPremultipliedAlpha);
        tolua_function(tolua_S,"hasMipmaps",lua_ax_base_Texture2D_hasMipmaps);
        tolua_function(tolua_S,"getPixelFormat",lua_ax_base_Texture2D_getPixelFormat);
        tolua_function(tolua_S,"getSamplerFlags",lua_ax_base_Texture2D_getSamplerFlags);
        tolua_function(tolua_S,"getPixelsWide",lua_ax_base_Texture2D_getPixelsWide);
        tolua_function(tolua_S,"getPixelsHigh",lua_ax_base_Texture2D_getPixelsHigh);
        tolua_function(tolua_S,"getBackendTexture",lua_ax_base_Texture2D_getBackendTexture);
        tolua_function(tolua_S,"getMaxS",lua_ax_base_Texture2D_getMaxS);
        tolua_function(tolua_S,"setMaxS",lua_ax_base_Texture2D_setMaxS);
        tolua_function(tolua_S,"getMaxT",lua_ax_base_Texture2D_getMaxT);
        tolua_function(tolua_S,"setMaxT",lua_ax_base_Texture2D_setMaxT);
        tolua_function(tolua_S,"getContentSize",lua_ax_base_Texture2D_getContentSize);
        tolua_function(tolua_S,"getPath",lua_ax_base_Texture2D_getPath);
        tolua_function(tolua_S,"setDefaultAlphaPixelFormat", lua_ax_base_Texture2D_setDefaultAlphaPixelFormat);
        tolua_function(tolua_S,"getDefaultAlphaPixelFormat", lua_ax_base_Texture2D_getDefaultAlphaPixelFormat);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Texture2D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Texture2D";
    g_typeCast[typeName] = "ax.Texture2D";
    return 1;
}

int lua_ax_base_Touch_getLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getPreviousLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getPreviousLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getPreviousLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPreviousLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getPreviousLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getPreviousLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getStartLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getStartLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getStartLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getStartLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getStartLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getDelta(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getDelta'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getDelta'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDelta();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getDelta",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getDelta'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getPreviousLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getPreviousLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getPreviousLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPreviousLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getPreviousLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getPreviousLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getStartLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getStartLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getStartLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getStartLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getStartLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_setTouchInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_setTouchInfo'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            cobj->setTouchInfo(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Touch:setTouchInfo");

            if (!ok) { break; }
            cobj->setTouchInfo(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Touch:setTouchInfo",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_setTouchInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getID(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getID'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getID'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getID",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getCurrentForce(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getCurrentForce'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getCurrentForce'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCurrentForce();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getCurrentForce",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getCurrentForce'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_getMaxForce(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Touch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Touch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Touch_getMaxForce'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_getMaxForce'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMaxForce();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:getMaxForce",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_getMaxForce'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Touch_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Touch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Touch_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Touch();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Touch");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Touch:Touch",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Touch_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Touch_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Touch)");
    return 0;
}

int lua_register_ax_base_Touch(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Touch");
    tolua_cclass(tolua_S,"Touch","ax.Touch","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Touch");
        tolua_function(tolua_S,"new",lua_ax_base_Touch_constructor);
        tolua_function(tolua_S,"getLocation",lua_ax_base_Touch_getLocation);
        tolua_function(tolua_S,"getPreviousLocation",lua_ax_base_Touch_getPreviousLocation);
        tolua_function(tolua_S,"getStartLocation",lua_ax_base_Touch_getStartLocation);
        tolua_function(tolua_S,"getDelta",lua_ax_base_Touch_getDelta);
        tolua_function(tolua_S,"getLocationInView",lua_ax_base_Touch_getLocationInView);
        tolua_function(tolua_S,"getPreviousLocationInView",lua_ax_base_Touch_getPreviousLocationInView);
        tolua_function(tolua_S,"getStartLocationInView",lua_ax_base_Touch_getStartLocationInView);
        tolua_function(tolua_S,"setTouchInfo",lua_ax_base_Touch_setTouchInfo);
        tolua_function(tolua_S,"getId",lua_ax_base_Touch_getID);
        tolua_function(tolua_S,"getCurrentForce",lua_ax_base_Touch_getCurrentForce);
        tolua_function(tolua_S,"getMaxForce",lua_ax_base_Touch_getMaxForce);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Touch).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Touch";
    g_typeCast[typeName] = "ax.Touch";
    return 1;
}

int lua_ax_base_Event_getType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Event* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Event",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Event*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Event_getType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Event_getType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Event:getType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Event_getType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Event_stopPropagation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Event* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Event",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Event*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Event_stopPropagation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Event_stopPropagation'", nullptr);
            return 0;
        }
        cobj->stopPropagation();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Event:stopPropagation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Event_stopPropagation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Event_isStopped(lua_State* tolua_S)
{
    int argc = 0;
    ax::Event* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Event",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Event*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Event_isStopped'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Event_isStopped'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStopped();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Event:isStopped",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Event_isStopped'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Event_getCurrentTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Event* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Event",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Event*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Event_getCurrentTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Event_getCurrentTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCurrentTarget();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Event:getCurrentTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Event_getCurrentTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Event_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Event* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Event::Type arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Event:Event");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Event_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Event(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Event");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Event:Event",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Event_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Event_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Event)");
    return 0;
}

int lua_register_ax_base_Event(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Event");
    tolua_cclass(tolua_S,"Event","ax.Event","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Event");
        tolua_function(tolua_S,"new",lua_ax_base_Event_constructor);
        tolua_function(tolua_S,"getType",lua_ax_base_Event_getType);
        tolua_function(tolua_S,"stopPropagation",lua_ax_base_Event_stopPropagation);
        tolua_function(tolua_S,"isStopped",lua_ax_base_Event_isStopped);
        tolua_function(tolua_S,"getCurrentTarget",lua_ax_base_Event_getCurrentTarget);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Event).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Event";
    g_typeCast[typeName] = "ax.Event";
    return 1;
}

int lua_ax_base_EventTouch_getEventCode(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventTouch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventTouch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventTouch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventTouch_getEventCode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventTouch_getEventCode'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getEventCode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventTouch:getEventCode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventTouch_getEventCode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventTouch_setEventCode(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventTouch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventTouch",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventTouch*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventTouch_setEventCode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventTouch::EventCode arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventTouch:setEventCode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventTouch_setEventCode'", nullptr);
            return 0;
        }
        cobj->setEventCode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventTouch:setEventCode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventTouch_setEventCode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventTouch_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventTouch* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventTouch_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventTouch();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventTouch");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventTouch:EventTouch",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventTouch_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventTouch_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventTouch)");
    return 0;
}

int lua_register_ax_base_EventTouch(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventTouch");
    tolua_cclass(tolua_S,"EventTouch","ax.EventTouch","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventTouch");
        tolua_function(tolua_S,"new",lua_ax_base_EventTouch_constructor);
        tolua_function(tolua_S,"getEventCode",lua_ax_base_EventTouch_getEventCode);
        tolua_function(tolua_S,"setEventCode",lua_ax_base_EventTouch_setEventCode);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventTouch).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventTouch";
    g_typeCast[typeName] = "ax.EventTouch";
    return 1;
}

int lua_ax_base_EventKeyboard_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventKeyboard* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::EventKeyboard::KeyCode arg0;
        bool arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventKeyboard:EventKeyboard");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.EventKeyboard:EventKeyboard");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventKeyboard_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventKeyboard(arg0, arg1);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventKeyboard");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventKeyboard:EventKeyboard",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventKeyboard_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventKeyboard_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventKeyboard)");
    return 0;
}

int lua_register_ax_base_EventKeyboard(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventKeyboard");
    tolua_cclass(tolua_S,"EventKeyboard","ax.EventKeyboard","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventKeyboard");
        tolua_function(tolua_S,"new",lua_ax_base_EventKeyboard_constructor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventKeyboard).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventKeyboard";
    g_typeCast[typeName] = "ax.EventKeyboard";
    return 1;
}

int lua_ax_base_Component_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_isEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Component:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_setName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_setName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Component:setName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_setName'", nullptr);
            return 0;
        }
        cobj->setName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:setName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_setName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_getOwner(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_getOwner'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_getOwner'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOwner();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:getOwner",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_getOwner'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_setOwner(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_setOwner'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Component:setOwner");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_setOwner'", nullptr);
            return 0;
        }
        cobj->setOwner(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:setOwner",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_setOwner'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Component:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_update'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_onAdd(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_onAdd'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_onAdd'", nullptr);
            return 0;
        }
        cobj->onAdd();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:onAdd",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_onAdd'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_onRemove(lua_State* tolua_S)
{
    int argc = 0;
    ax::Component* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Component*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Component_onRemove'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_onRemove'", nullptr);
            return 0;
        }
        cobj->onRemove();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Component:onRemove",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_onRemove'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Component_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Component",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Component_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Component::create();
        object_to_luaval<ax::Component>(tolua_S, "ax.Component",(ax::Component*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Component:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Component_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Component_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Component)");
    return 0;
}

int lua_register_ax_base_Component(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Component");
    tolua_cclass(tolua_S,"Component","ax.Component","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Component");
        tolua_function(tolua_S,"init",lua_ax_base_Component_init);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_Component_isEnabled);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_Component_setEnabled);
        tolua_function(tolua_S,"getName",lua_ax_base_Component_getName);
        tolua_function(tolua_S,"setName",lua_ax_base_Component_setName);
        tolua_function(tolua_S,"getOwner",lua_ax_base_Component_getOwner);
        tolua_function(tolua_S,"setOwner",lua_ax_base_Component_setOwner);
        tolua_function(tolua_S,"update",lua_ax_base_Component_update);
        tolua_function(tolua_S,"onAdd",lua_ax_base_Component_onAdd);
        tolua_function(tolua_S,"onRemove",lua_ax_base_Component_onRemove);
        tolua_function(tolua_S,"create", lua_ax_base_Component_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Component).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Component";
    g_typeCast[typeName] = "ax.Component";
    return 1;
}

int lua_ax_base_Node_getDescription(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getDescription'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getDescription'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDescription();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getDescription",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getDescription'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setLocalZOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setLocalZOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:setLocalZOrder");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setLocalZOrder'", nullptr);
            return 0;
        }
        cobj->setLocalZOrder(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setLocalZOrder",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setLocalZOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_updateOrderOfArrival(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_updateOrderOfArrival'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_updateOrderOfArrival'", nullptr);
            return 0;
        }
        cobj->updateOrderOfArrival();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:updateOrderOfArrival",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_updateOrderOfArrival'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getLocalZOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getLocalZOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getLocalZOrder'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLocalZOrder();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getLocalZOrder",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getLocalZOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setGlobalZOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setGlobalZOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setGlobalZOrder");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setGlobalZOrder'", nullptr);
            return 0;
        }
        cobj->setGlobalZOrder(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setGlobalZOrder",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setGlobalZOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getGlobalZOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getGlobalZOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getGlobalZOrder'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGlobalZOrder();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getGlobalZOrder",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getGlobalZOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setScaleX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setScaleX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setScaleX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setScaleX'", nullptr);
            return 0;
        }
        cobj->setScaleX(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setScaleX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setScaleX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScaleX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScaleX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getScaleX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScaleX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getScaleX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScaleX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setScaleY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setScaleY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setScaleY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setScaleY'", nullptr);
            return 0;
        }
        cobj->setScaleY(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setScaleY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setScaleY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScaleY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScaleY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getScaleY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScaleY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getScaleY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScaleY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setScaleZ(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setScaleZ'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setScaleZ");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setScaleZ'", nullptr);
            return 0;
        }
        cobj->setScaleZ(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setScaleZ",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setScaleZ'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScaleZ(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScaleZ'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getScaleZ'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScaleZ();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getScaleZ",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScaleZ'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setScale'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setScale");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Node:setScale");

            if (!ok) { break; }
            cobj->setScale(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setScale");

            if (!ok) { break; }
            cobj->setScale(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:setScale",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScale'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getScale'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScale();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getScale",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPosition'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setPosition");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Node:setPosition");

            if (!ok) { break; }
            cobj->setPosition(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:setPosition");

            if (!ok) { break; }
            cobj->setPosition(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:setPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPositionNormalized(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPositionNormalized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:setPositionNormalized");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPositionNormalized'", nullptr);
            return 0;
        }
        cobj->setPositionNormalized(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPositionNormalized",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPositionNormalized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setNormalizedPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setNormalizedPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:setNormalizedPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setNormalizedPosition'", nullptr);
            return 0;
        }
        cobj->setNormalizedPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setNormalizedPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setNormalizedPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPositionNormalized(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPositionNormalized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPositionNormalized'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionNormalized();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPositionNormalized",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPositionNormalized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNormalizedPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNormalizedPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getNormalizedPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNormalizedPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getNormalizedPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNormalizedPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPositionX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPositionX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setPositionX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPositionX'", nullptr);
            return 0;
        }
        cobj->setPositionX(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPositionX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPositionX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPositionX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPositionX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPositionX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPositionX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPositionX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPositionY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPositionY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setPositionY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPositionY'", nullptr);
            return 0;
        }
        cobj->setPositionY(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPositionY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPositionY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPositionY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPositionY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPositionY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPositionY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPositionY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPosition3D(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPosition3D'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Node:setPosition3D");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPosition3D'", nullptr);
            return 0;
        }
        cobj->setPosition3D(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPosition3D",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPosition3D'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPosition3D(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPosition3D'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPosition3D'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPosition3D();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPosition3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPosition3D'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPositionZ(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPositionZ'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setPositionZ");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPositionZ'", nullptr);
            return 0;
        }
        cobj->setPositionZ(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPositionZ",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPositionZ'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPositionZ(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPositionZ'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPositionZ'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionZ();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPositionZ",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPositionZ'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setSkewX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setSkewX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setSkewX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setSkewX'", nullptr);
            return 0;
        }
        cobj->setSkewX(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setSkewX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setSkewX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getSkewX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getSkewX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getSkewX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSkewX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getSkewX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getSkewX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setSkewY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setSkewY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setSkewY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setSkewY'", nullptr);
            return 0;
        }
        cobj->setSkewY(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setSkewY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setSkewY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getSkewY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getSkewY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getSkewY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSkewY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getSkewY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getSkewY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getAnchorPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getAnchorPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getAnchorPoint'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnchorPoint();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getAnchorPoint",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getAnchorPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getAnchorPointInPoints(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getAnchorPointInPoints'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getAnchorPointInPoints'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnchorPointInPoints();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getAnchorPointInPoints",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getAnchorPointInPoints'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getContentSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getContentSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getContentSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getContentSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getContentSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getContentSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_hitTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_hitTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:hitTest");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_hitTest'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hitTest(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:hitTest",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_hitTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setVisible(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setVisible'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:setVisible");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setVisible'", nullptr);
            return 0;
        }
        cobj->setVisible(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setVisible",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setVisible'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isVisible(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isVisible'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isVisible'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isVisible();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isVisible",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isVisible'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setRotation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setRotation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setRotation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setRotation'", nullptr);
            return 0;
        }
        cobj->setRotation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setRotation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setRotation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getRotation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getRotation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getRotation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getRotation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getRotation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setRotation3D(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setRotation3D'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Node:setRotation3D");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setRotation3D'", nullptr);
            return 0;
        }
        cobj->setRotation3D(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setRotation3D",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setRotation3D'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getRotation3D(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getRotation3D'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getRotation3D'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotation3D();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getRotation3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getRotation3D'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setRotationSkewX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setRotationSkewX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setRotationSkewX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setRotationSkewX'", nullptr);
            return 0;
        }
        cobj->setRotationSkewX(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setRotationSkewX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setRotationSkewX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getRotationSkewX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getRotationSkewX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getRotationSkewX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotationSkewX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getRotationSkewX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getRotationSkewX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setRotationSkewY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setRotationSkewY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:setRotationSkewY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setRotationSkewY'", nullptr);
            return 0;
        }
        cobj->setRotationSkewY(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setRotationSkewY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setRotationSkewY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getRotationSkewY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getRotationSkewY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getRotationSkewY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotationSkewY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getRotationSkewY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getRotationSkewY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setIgnoreAnchorPointForPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setIgnoreAnchorPointForPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:setIgnoreAnchorPointForPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setIgnoreAnchorPointForPosition'", nullptr);
            return 0;
        }
        cobj->setIgnoreAnchorPointForPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setIgnoreAnchorPointForPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setIgnoreAnchorPointForPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isIgnoreAnchorPointForPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isIgnoreAnchorPointForPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isIgnoreAnchorPointForPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isIgnoreAnchorPointForPosition();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isIgnoreAnchorPointForPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isIgnoreAnchorPointForPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_addChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_addChild'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:addChild");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Node:addChild");

            if (!ok) { break; }
            cobj->addChild(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:addChild");

            if (!ok) { break; }
            cobj->addChild(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:addChild");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Node:addChild");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Node:addChild");

            if (!ok) { break; }
            cobj->addChild(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:addChild");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Node:addChild");

            if (!ok) { break; }
            std::string_view arg2;
            ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.Node:addChild");

            if (!ok) { break; }
            cobj->addChild(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:addChild",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_addChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getChildByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getChildByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:getChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getChildByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getChildByTag(arg0);
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getChildByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getChildByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getChildByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getChildByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:getChildByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getChildByName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getChildByName(arg0);
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getChildByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getChildByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getChildren(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getChildren'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::Vector<ax::Node *>& ret = cobj->getChildren();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Vector<ax::Node *>& ret = cobj->getChildren();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getChildren'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getChildrenCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getChildrenCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getChildrenCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getChildrenCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getChildrenCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getChildrenCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setParent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setParent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:setParent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setParent'", nullptr);
            return 0;
        }
        cobj->setParent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setParent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setParent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getParent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getParent'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::Node* ret = cobj->getParent();
            object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Node* ret = cobj->getParent();
            object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getParent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getParent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeFromParentAndCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeFromParentAndCleanup'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:removeFromParentAndCleanup");

            if (!ok) { break; }
            cobj->removeFromParentAndCleanup(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->removeFromParent();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:removeFromParent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeFromParentAndCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:removeChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChild'", nullptr);
            return 0;
        }
        cobj->removeChild(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:removeChild");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:removeChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChild'", nullptr);
            return 0;
        }
        cobj->removeChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:removeChild",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeChildByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeChildByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:removeChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChildByTag'", nullptr);
            return 0;
        }
        cobj->removeChildByTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:removeChildByTag");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:removeChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChildByTag'", nullptr);
            return 0;
        }
        cobj->removeChildByTag(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:removeChildByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeChildByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeChildByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeChildByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:removeChildByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChildByName'", nullptr);
            return 0;
        }
        cobj->removeChildByName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        std::string_view arg0;
        bool arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:removeChildByName");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:removeChildByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeChildByName'", nullptr);
            return 0;
        }
        cobj->removeChildByName(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:removeChildByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeChildByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            bool arg0;
            ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:removeAllChildrenWithCleanup");

            if (!ok) { break; }
            cobj->removeAllChildrenWithCleanup(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->removeAllChildren();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:removeAllChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_reorderChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_reorderChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Node* arg0;
        int arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:reorderChild");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Node:reorderChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_reorderChild'", nullptr);
            return 0;
        }
        cobj->reorderChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:reorderChild",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_reorderChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_sortAllChildren(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_sortAllChildren'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_sortAllChildren'", nullptr);
            return 0;
        }
        cobj->sortAllChildren();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:sortAllChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_sortAllChildren'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getTag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:setTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setTag'", nullptr);
            return 0;
        }
        cobj->setTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:setName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setName'", nullptr);
            return 0;
        }
        cobj->setName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setUserObject(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setUserObject'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Object* arg0;

        ok &= luaval_to_object<ax::Object>(tolua_S, 2, "ax.Object",&arg0, "ax.Node:setUserObject");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setUserObject'", nullptr);
            return 0;
        }
        cobj->setUserObject(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setUserObject",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setUserObject'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isRunning(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isRunning'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isRunning'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isRunning();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isRunning",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isRunning'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_cleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_cleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_cleanup'", nullptr);
            return 0;
        }
        cobj->cleanup();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:cleanup",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_cleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_draw(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_draw'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj->draw();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Renderer* arg0;
            ok &= luaval_to_object<ax::Renderer>(tolua_S, 2, "ax.Renderer",&arg0, "ax.Node:draw");

            if (!ok) { break; }
            ax::Mat4 arg1;
            ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Node:draw");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Node:draw");

            if (!ok) { break; }
            cobj->draw(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:draw",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_draw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_visit(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_visit'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            cobj->visit();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Renderer* arg0;
            ok &= luaval_to_object<ax::Renderer>(tolua_S, 2, "ax.Renderer",&arg0, "ax.Node:visit");

            if (!ok) { break; }
            ax::Mat4 arg1;
            ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Node:visit");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Node:visit");

            if (!ok) { break; }
            cobj->visit(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:visit",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_visit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getScene'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScene();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getBoundingBox(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getBoundingBox'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getBoundingBox'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBoundingBox();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getBoundingBox",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getBoundingBox'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setEventDispatcher(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setEventDispatcher'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventDispatcher* arg0;

        ok &= luaval_to_object<ax::EventDispatcher>(tolua_S, 2, "ax.EventDispatcher",&arg0, "ax.Node:setEventDispatcher");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setEventDispatcher'", nullptr);
            return 0;
        }
        cobj->setEventDispatcher(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setEventDispatcher",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setEventDispatcher'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getEventDispatcher(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getEventDispatcher'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getEventDispatcher'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEventDispatcher();
        object_to_luaval<ax::EventDispatcher>(tolua_S, "ax.EventDispatcher",(ax::EventDispatcher*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getEventDispatcher",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getEventDispatcher'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setActionManager(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setActionManager'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionManager* arg0;

        ok &= luaval_to_object<ax::ActionManager>(tolua_S, 2, "ax.ActionManager",&arg0, "ax.Node:setActionManager");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setActionManager'", nullptr);
            return 0;
        }
        cobj->setActionManager(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setActionManager",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setActionManager'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getActionManager(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getActionManager'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::ActionManager* ret = cobj->getActionManager();
            object_to_luaval<ax::ActionManager>(tolua_S, "ax.ActionManager",(ax::ActionManager*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::ActionManager* ret = cobj->getActionManager();
            object_to_luaval<ax::ActionManager>(tolua_S, "ax.ActionManager",(ax::ActionManager*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getActionManager",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getActionManager'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_runAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_runAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Action* arg0;

        ok &= luaval_to_object<ax::Action>(tolua_S, 2, "ax.Action",&arg0, "ax.Node:runAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_runAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->runAction(arg0);
        object_to_luaval<ax::Action>(tolua_S, "ax.Action",(ax::Action*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:runAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_runAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_stopAllActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_stopAllActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_stopAllActions'", nullptr);
            return 0;
        }
        cobj->stopAllActions();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:stopAllActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_stopAllActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_stopAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_stopAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Action* arg0;

        ok &= luaval_to_object<ax::Action>(tolua_S, 2, "ax.Action",&arg0, "ax.Node:stopAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_stopAction'", nullptr);
            return 0;
        }
        cobj->stopAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:stopAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_stopAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_stopActionByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_stopActionByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:stopActionByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_stopActionByTag'", nullptr);
            return 0;
        }
        cobj->stopActionByTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:stopActionByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_stopActionByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_stopAllActionsByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_stopAllActionsByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:stopAllActionsByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_stopAllActionsByTag'", nullptr);
            return 0;
        }
        cobj->stopAllActionsByTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:stopAllActionsByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_stopAllActionsByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_stopActionsByFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_stopActionsByFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Node:stopActionsByFlags");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_stopActionsByFlags'", nullptr);
            return 0;
        }
        cobj->stopActionsByFlags(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:stopActionsByFlags",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_stopActionsByFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getActionByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getActionByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:getActionByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getActionByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getActionByTag(arg0);
        object_to_luaval<ax::Action>(tolua_S, "ax.Action",(ax::Action*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getActionByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getActionByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNumberOfRunningActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNumberOfRunningActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getNumberOfRunningActions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfRunningActions();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getNumberOfRunningActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNumberOfRunningActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNumberOfRunningActionsByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNumberOfRunningActionsByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Node:getNumberOfRunningActionsByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getNumberOfRunningActionsByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfRunningActionsByTag(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getNumberOfRunningActionsByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNumberOfRunningActionsByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setScheduler(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setScheduler'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scheduler* arg0;

        ok &= luaval_to_object<ax::Scheduler>(tolua_S, 2, "ax.Scheduler",&arg0, "ax.Node:setScheduler");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setScheduler'", nullptr);
            return 0;
        }
        cobj->setScheduler(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setScheduler",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setScheduler'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getScheduler(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getScheduler'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::Scheduler* ret = cobj->getScheduler();
            object_to_luaval<ax::Scheduler>(tolua_S, "ax.Scheduler",(ax::Scheduler*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Scheduler* ret = cobj->getScheduler();
            object_to_luaval<ax::Scheduler>(tolua_S, "ax.Scheduler",(ax::Scheduler*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getScheduler",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getScheduler'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isScheduled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isScheduled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:isScheduled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isScheduled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isScheduled(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isScheduled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isScheduled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_resume(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_resume'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_resume'", nullptr);
            return 0;
        }
        cobj->resume();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:resume",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_resume'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_pause(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_pause'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_pause'", nullptr);
            return 0;
        }
        cobj->pause();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:pause",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_pause'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Node:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_update'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_updateTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_updateTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_updateTransform'", nullptr);
            return 0;
        }
        cobj->updateTransform();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:updateTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_updateTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNodeToParentTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNodeToParentTransform'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:getNodeToParentTransform");

            if (!ok) { break; }
            ax::Mat4 ret = cobj->getNodeToParentTransform(arg0);
            mat4_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::Mat4& ret = cobj->getNodeToParentTransform();
            mat4_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getNodeToParentTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNodeToParentTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNodeToParentAffineTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNodeToParentAffineTransform'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:getNodeToParentAffineTransform");

            if (!ok) { break; }
            ax::AffineTransform ret = cobj->getNodeToParentAffineTransform(arg0);
            affinetransform_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::AffineTransform ret = cobj->getNodeToParentAffineTransform();
            affinetransform_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:getNodeToParentAffineTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNodeToParentAffineTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setNodeToParentTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setNodeToParentTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Mat4 arg0;

        ok &= luaval_to_mat4(tolua_S, 2, &arg0, "ax.Node:setNodeToParentTransform");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setNodeToParentTransform'", nullptr);
            return 0;
        }
        cobj->setNodeToParentTransform(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setNodeToParentTransform",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setNodeToParentTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getParentToNodeTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getParentToNodeTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getParentToNodeTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getParentToNodeTransform();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getParentToNodeTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getParentToNodeTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getParentToNodeAffineTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getParentToNodeAffineTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getParentToNodeAffineTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getParentToNodeAffineTransform();
        affinetransform_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getParentToNodeAffineTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getParentToNodeAffineTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNodeToWorldTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNodeToWorldTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getNodeToWorldTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNodeToWorldTransform();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getNodeToWorldTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNodeToWorldTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getNodeToWorldAffineTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getNodeToWorldAffineTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getNodeToWorldAffineTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNodeToWorldAffineTransform();
        affinetransform_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getNodeToWorldAffineTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getNodeToWorldAffineTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getWorldToNodeTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getWorldToNodeTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getWorldToNodeTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWorldToNodeTransform();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getWorldToNodeTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getWorldToNodeTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getWorldToNodeAffineTransform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getWorldToNodeAffineTransform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getWorldToNodeAffineTransform'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWorldToNodeAffineTransform();
        affinetransform_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getWorldToNodeAffineTransform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getWorldToNodeAffineTransform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertToNodeSpace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertToNodeSpace'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:convertToNodeSpace");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertToNodeSpace'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToNodeSpace(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertToNodeSpace",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertToNodeSpace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertToWorldSpace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertToWorldSpace'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:convertToWorldSpace");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertToWorldSpace'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToWorldSpace(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertToWorldSpace",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertToWorldSpace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertToNodeSpaceAR(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertToNodeSpaceAR'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:convertToNodeSpaceAR");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertToNodeSpaceAR'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToNodeSpaceAR(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertToNodeSpaceAR",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertToNodeSpaceAR'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertToWorldSpaceAR(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertToWorldSpaceAR'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:convertToWorldSpaceAR");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertToWorldSpaceAR'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToWorldSpaceAR(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertToWorldSpaceAR",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertToWorldSpaceAR'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertTouchToNodeSpace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertTouchToNodeSpace'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Touch* arg0;

        ok &= luaval_to_object<ax::Touch>(tolua_S, 2, "ax.Touch",&arg0, "ax.Node:convertTouchToNodeSpace");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertTouchToNodeSpace'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertTouchToNodeSpace(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertTouchToNodeSpace",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertTouchToNodeSpace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_convertTouchToNodeSpaceAR(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_convertTouchToNodeSpaceAR'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Touch* arg0;

        ok &= luaval_to_object<ax::Touch>(tolua_S, 2, "ax.Touch",&arg0, "ax.Node:convertTouchToNodeSpaceAR");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_convertTouchToNodeSpaceAR'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertTouchToNodeSpaceAR(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:convertTouchToNodeSpaceAR",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_convertTouchToNodeSpaceAR'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getWorldPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getWorldPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getWorldPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWorldPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getWorldPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getWorldPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setWorldPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setWorldPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Node:setWorldPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setWorldPosition'", nullptr);
            return 0;
        }
        cobj->setWorldPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setWorldPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setWorldPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getComponent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getComponent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:getComponent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getComponent'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getComponent(arg0);
        object_to_luaval<ax::Component>(tolua_S, "ax.Component",(ax::Component*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getComponent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getComponent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_addComponent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_addComponent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Component* arg0;

        ok &= luaval_to_object<ax::Component>(tolua_S, 2, "ax.Component",&arg0, "ax.Node:addComponent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_addComponent'", nullptr);
            return 0;
        }
        auto&& ret = cobj->addComponent(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:addComponent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_addComponent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeComponent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeComponent'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Component* arg0;
            ok &= luaval_to_object<ax::Component>(tolua_S, 2, "ax.Component",&arg0, "ax.Node:removeComponent");

            if (!ok) { break; }
            bool ret = cobj->removeComponent(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Node:removeComponent");

            if (!ok) { break; }
            bool ret = cobj->removeComponent(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:removeComponent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeComponent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_removeAllComponents(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_removeAllComponents'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_removeAllComponents'", nullptr);
            return 0;
        }
        cobj->removeAllComponents();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:removeAllComponents",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_removeAllComponents'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getDisplayedOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getDisplayedOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getDisplayedOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDisplayedOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getDisplayedOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getDisplayedOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.Node:setOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOpacity'", nullptr);
            return 0;
        }
        cobj->setOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_updateDisplayedOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_updateDisplayedOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.Node:updateDisplayedOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_updateDisplayedOpacity'", nullptr);
            return 0;
        }
        cobj->updateDisplayedOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:updateDisplayedOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_updateDisplayedOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isCascadeOpacityEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isCascadeOpacityEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isCascadeOpacityEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isCascadeOpacityEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isCascadeOpacityEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isCascadeOpacityEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setCascadeOpacityEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setCascadeOpacityEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:setCascadeOpacityEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setCascadeOpacityEnabled'", nullptr);
            return 0;
        }
        cobj->setCascadeOpacityEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setCascadeOpacityEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setCascadeOpacityEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getColor();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getDisplayedColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getDisplayedColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getDisplayedColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDisplayedColor();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getDisplayedColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getDisplayedColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.Node:setColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setColor'", nullptr);
            return 0;
        }
        cobj->setColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_updateDisplayedColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_updateDisplayedColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.Node:updateDisplayedColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_updateDisplayedColor'", nullptr);
            return 0;
        }
        cobj->updateDisplayedColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:updateDisplayedColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_updateDisplayedColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isCascadeColorEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isCascadeColorEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isCascadeColorEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isCascadeColorEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isCascadeColorEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isCascadeColorEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setCascadeColorEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setCascadeColorEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:setCascadeColorEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setCascadeColorEnabled'", nullptr);
            return 0;
        }
        cobj->setCascadeColorEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setCascadeColorEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setCascadeColorEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOpacityModifyRGB(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOpacityModifyRGB'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:setOpacityModifyRGB");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOpacityModifyRGB'", nullptr);
            return 0;
        }
        cobj->setOpacityModifyRGB(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOpacityModifyRGB",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOpacityModifyRGB'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_isOpacityModifyRGB(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_isOpacityModifyRGB'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_isOpacityModifyRGB'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isOpacityModifyRGB();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:isOpacityModifyRGB",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_isOpacityModifyRGB'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOnEnterCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOnEnterCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOnEnterCallback'", nullptr);
            return 0;
        }
        cobj->setOnEnterCallback(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOnEnterCallback",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOnEnterCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOnExitCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOnExitCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOnExitCallback'", nullptr);
            return 0;
        }
        cobj->setOnExitCallback(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOnExitCallback",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOnExitCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOnEnterTransitionDidFinishCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOnEnterTransitionDidFinishCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOnEnterTransitionDidFinishCallback'", nullptr);
            return 0;
        }
        cobj->setOnEnterTransitionDidFinishCallback(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOnEnterTransitionDidFinishCallback",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOnEnterTransitionDidFinishCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getOnEnterTransitionDidFinishCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getOnEnterTransitionDidFinishCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getOnEnterTransitionDidFinishCallback'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOnEnterTransitionDidFinishCallback();
        #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getOnEnterTransitionDidFinishCallback",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getOnEnterTransitionDidFinishCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setOnExitTransitionDidStartCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setOnExitTransitionDidStartCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setOnExitTransitionDidStartCallback'", nullptr);
            return 0;
        }
        cobj->setOnExitTransitionDidStartCallback(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setOnExitTransitionDidStartCallback",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setOnExitTransitionDidStartCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getOnExitTransitionDidStartCallback(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getOnExitTransitionDidStartCallback'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getOnExitTransitionDidStartCallback'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOnExitTransitionDidStartCallback();
        #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getOnExitTransitionDidStartCallback",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getOnExitTransitionDidStartCallback'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getCameraMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getCameraMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getCameraMask'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCameraMask();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getCameraMask",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getCameraMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setCameraMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setCameraMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned short arg0;

        ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.Node:setCameraMask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setCameraMask'", nullptr);
            return 0;
        }
        cobj->setCameraMask(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        unsigned short arg0;
        bool arg1;

        ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.Node:setCameraMask");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:setCameraMask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setCameraMask'", nullptr);
            return 0;
        }
        cobj->setCameraMask(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setCameraMask",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setCameraMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_applyMaskOnEnter(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_applyMaskOnEnter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Node:applyMaskOnEnter");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_applyMaskOnEnter'", nullptr);
            return 0;
        }
        cobj->applyMaskOnEnter(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:applyMaskOnEnter",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_applyMaskOnEnter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setProgramState(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setProgramState'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::backend::ProgramState* arg0;
            ok &= luaval_to_object<ax::backend::ProgramState>(tolua_S, 2, "axb.ProgramState",&arg0, "ax.Node:setProgramState");

            if (!ok) { break; }
            bool ret = cobj->setProgramState(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::backend::ProgramState* arg0;
            ok &= luaval_to_object<ax::backend::ProgramState>(tolua_S, 2, "axb.ProgramState",&arg0, "ax.Node:setProgramState");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:setProgramState");

            if (!ok) { break; }
            bool ret = cobj->setProgramState(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Node:setProgramState");

            if (!ok) { break; }
            cobj->setProgramState(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Node:setProgramState",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setProgramState'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setProgramStateWithRegistry(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setProgramStateWithRegistry'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        ax::Texture2D* arg1;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Node:setProgramStateWithRegistry");

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.Node:setProgramStateWithRegistry");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setProgramStateWithRegistry'", nullptr);
            return 0;
        }
        cobj->setProgramStateWithRegistry(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setProgramStateWithRegistry",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setProgramStateWithRegistry'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setProgramStateByProgramId(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setProgramStateByProgramId'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned long long arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR unsigned long long
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setProgramStateByProgramId'", nullptr);
            return 0;
        }
        auto&& ret = cobj->setProgramStateByProgramId(arg0);
        object_to_luaval<ax::backend::ProgramState>(tolua_S, "axb.ProgramState",(ax::backend::ProgramState*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setProgramStateByProgramId",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setProgramStateByProgramId'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getProgramState(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getProgramState'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getProgramState'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProgramState();
        object_to_luaval<ax::backend::ProgramState>(tolua_S, "axb.ProgramState",(ax::backend::ProgramState*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getProgramState",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getProgramState'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_updateProgramStateTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_updateProgramStateTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Node:updateProgramStateTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_updateProgramStateTexture'", nullptr);
            return 0;
        }
        cobj->updateProgramStateTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:updateProgramStateTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_updateProgramStateTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_resetChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_resetChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Node:resetChild");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Node:resetChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_resetChild'", nullptr);
            return 0;
        }
        cobj->resetChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:resetChild",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_resetChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_initLayer(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_initLayer'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_initLayer'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initLayer();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:initLayer",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_initLayer'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_setPhysicsBody(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_setPhysicsBody'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::PhysicsBody* arg0;

        ok &= luaval_to_object<ax::PhysicsBody>(tolua_S, 2, "ax.PhysicsBody",&arg0, "ax.Node:setPhysicsBody");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_setPhysicsBody'", nullptr);
            return 0;
        }
        cobj->setPhysicsBody(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:setPhysicsBody",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_setPhysicsBody'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_getPhysicsBody(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Node*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Node_getPhysicsBody'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getPhysicsBody'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPhysicsBody();
        object_to_luaval<ax::PhysicsBody>(tolua_S, "ax.PhysicsBody",(ax::PhysicsBody*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:getPhysicsBody",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getPhysicsBody'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Node_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Node::create();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Node:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Node_getAttachedNodeCount(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Node",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_getAttachedNodeCount'", nullptr);
            return 0;
        }
        auto&& ret = ax::Node::getAttachedNodeCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Node:getAttachedNodeCount",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_getAttachedNodeCount'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Node_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Node* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Node_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Node();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Node");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Node:Node",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Node_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Node_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Node)");
    return 0;
}

int lua_register_ax_base_Node(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Node");
    tolua_cclass(tolua_S,"Node","ax.Node","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Node");
        tolua_function(tolua_S,"new",lua_ax_base_Node_constructor);
        tolua_function(tolua_S,"getDescription",lua_ax_base_Node_getDescription);
        tolua_function(tolua_S,"setLocalZOrder",lua_ax_base_Node_setLocalZOrder);
        tolua_function(tolua_S,"updateOrderOfArrival",lua_ax_base_Node_updateOrderOfArrival);
        tolua_function(tolua_S,"getLocalZOrder",lua_ax_base_Node_getLocalZOrder);
        tolua_function(tolua_S,"setGlobalZOrder",lua_ax_base_Node_setGlobalZOrder);
        tolua_function(tolua_S,"getGlobalZOrder",lua_ax_base_Node_getGlobalZOrder);
        tolua_function(tolua_S,"setScaleX",lua_ax_base_Node_setScaleX);
        tolua_function(tolua_S,"getScaleX",lua_ax_base_Node_getScaleX);
        tolua_function(tolua_S,"setScaleY",lua_ax_base_Node_setScaleY);
        tolua_function(tolua_S,"getScaleY",lua_ax_base_Node_getScaleY);
        tolua_function(tolua_S,"setScaleZ",lua_ax_base_Node_setScaleZ);
        tolua_function(tolua_S,"getScaleZ",lua_ax_base_Node_getScaleZ);
        tolua_function(tolua_S,"setScale",lua_ax_base_Node_setScale);
        tolua_function(tolua_S,"getScale",lua_ax_base_Node_getScale);
        tolua_function(tolua_S,"setPosition",lua_ax_base_Node_setPosition);
        tolua_function(tolua_S,"setPositionNormalized",lua_ax_base_Node_setPositionNormalized);
        tolua_function(tolua_S,"setNormalizedPosition",lua_ax_base_Node_setNormalizedPosition);
        tolua_function(tolua_S,"getPositionNormalized",lua_ax_base_Node_getPositionNormalized);
        tolua_function(tolua_S,"getNormalizedPosition",lua_ax_base_Node_getNormalizedPosition);
        tolua_function(tolua_S,"setPositionX",lua_ax_base_Node_setPositionX);
        tolua_function(tolua_S,"getPositionX",lua_ax_base_Node_getPositionX);
        tolua_function(tolua_S,"setPositionY",lua_ax_base_Node_setPositionY);
        tolua_function(tolua_S,"getPositionY",lua_ax_base_Node_getPositionY);
        tolua_function(tolua_S,"setPosition3D",lua_ax_base_Node_setPosition3D);
        tolua_function(tolua_S,"getPosition3D",lua_ax_base_Node_getPosition3D);
        tolua_function(tolua_S,"setPositionZ",lua_ax_base_Node_setPositionZ);
        tolua_function(tolua_S,"getPositionZ",lua_ax_base_Node_getPositionZ);
        tolua_function(tolua_S,"setSkewX",lua_ax_base_Node_setSkewX);
        tolua_function(tolua_S,"getSkewX",lua_ax_base_Node_getSkewX);
        tolua_function(tolua_S,"setSkewY",lua_ax_base_Node_setSkewY);
        tolua_function(tolua_S,"getSkewY",lua_ax_base_Node_getSkewY);
        tolua_function(tolua_S,"getAnchorPoint",lua_ax_base_Node_getAnchorPoint);
        tolua_function(tolua_S,"getAnchorPointInPoints",lua_ax_base_Node_getAnchorPointInPoints);
        tolua_function(tolua_S,"getContentSize",lua_ax_base_Node_getContentSize);
        tolua_function(tolua_S,"hitTest",lua_ax_base_Node_hitTest);
        tolua_function(tolua_S,"setVisible",lua_ax_base_Node_setVisible);
        tolua_function(tolua_S,"isVisible",lua_ax_base_Node_isVisible);
        tolua_function(tolua_S,"setRotation",lua_ax_base_Node_setRotation);
        tolua_function(tolua_S,"getRotation",lua_ax_base_Node_getRotation);
        tolua_function(tolua_S,"setRotation3D",lua_ax_base_Node_setRotation3D);
        tolua_function(tolua_S,"getRotation3D",lua_ax_base_Node_getRotation3D);
        tolua_function(tolua_S,"setRotationSkewX",lua_ax_base_Node_setRotationSkewX);
        tolua_function(tolua_S,"getRotationSkewX",lua_ax_base_Node_getRotationSkewX);
        tolua_function(tolua_S,"setRotationSkewY",lua_ax_base_Node_setRotationSkewY);
        tolua_function(tolua_S,"getRotationSkewY",lua_ax_base_Node_getRotationSkewY);
        tolua_function(tolua_S,"setIgnoreAnchorPointForPosition",lua_ax_base_Node_setIgnoreAnchorPointForPosition);
        tolua_function(tolua_S,"isIgnoreAnchorPointForPosition",lua_ax_base_Node_isIgnoreAnchorPointForPosition);
        tolua_function(tolua_S,"addChild",lua_ax_base_Node_addChild);
        tolua_function(tolua_S,"getChildByTag",lua_ax_base_Node_getChildByTag);
        tolua_function(tolua_S,"getChildByName",lua_ax_base_Node_getChildByName);
        tolua_function(tolua_S,"getChildren",lua_ax_base_Node_getChildren);
        tolua_function(tolua_S,"getChildrenCount",lua_ax_base_Node_getChildrenCount);
        tolua_function(tolua_S,"setParent",lua_ax_base_Node_setParent);
        tolua_function(tolua_S,"getParent",lua_ax_base_Node_getParent);
        tolua_function(tolua_S,"removeFromParent",lua_ax_base_Node_removeFromParentAndCleanup);
        tolua_function(tolua_S,"removeChild",lua_ax_base_Node_removeChild);
        tolua_function(tolua_S,"removeChildByTag",lua_ax_base_Node_removeChildByTag);
        tolua_function(tolua_S,"removeChildByName",lua_ax_base_Node_removeChildByName);
        tolua_function(tolua_S,"removeAllChildren",lua_ax_base_Node_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"reorderChild",lua_ax_base_Node_reorderChild);
        tolua_function(tolua_S,"sortAllChildren",lua_ax_base_Node_sortAllChildren);
        tolua_function(tolua_S,"getTag",lua_ax_base_Node_getTag);
        tolua_function(tolua_S,"setTag",lua_ax_base_Node_setTag);
        tolua_function(tolua_S,"getName",lua_ax_base_Node_getName);
        tolua_function(tolua_S,"setName",lua_ax_base_Node_setName);
        tolua_function(tolua_S,"setUserObject",lua_ax_base_Node_setUserObject);
        tolua_function(tolua_S,"isRunning",lua_ax_base_Node_isRunning);
        tolua_function(tolua_S,"cleanup",lua_ax_base_Node_cleanup);
        tolua_function(tolua_S,"draw",lua_ax_base_Node_draw);
        tolua_function(tolua_S,"visit",lua_ax_base_Node_visit);
        tolua_function(tolua_S,"getScene",lua_ax_base_Node_getScene);
        tolua_function(tolua_S,"getBoundingBox",lua_ax_base_Node_getBoundingBox);
        tolua_function(tolua_S,"setEventDispatcher",lua_ax_base_Node_setEventDispatcher);
        tolua_function(tolua_S,"getEventDispatcher",lua_ax_base_Node_getEventDispatcher);
        tolua_function(tolua_S,"setActionManager",lua_ax_base_Node_setActionManager);
        tolua_function(tolua_S,"getActionManager",lua_ax_base_Node_getActionManager);
        tolua_function(tolua_S,"runAction",lua_ax_base_Node_runAction);
        tolua_function(tolua_S,"stopAllActions",lua_ax_base_Node_stopAllActions);
        tolua_function(tolua_S,"stopAction",lua_ax_base_Node_stopAction);
        tolua_function(tolua_S,"stopActionByTag",lua_ax_base_Node_stopActionByTag);
        tolua_function(tolua_S,"stopAllActionsByTag",lua_ax_base_Node_stopAllActionsByTag);
        tolua_function(tolua_S,"stopActionsByFlags",lua_ax_base_Node_stopActionsByFlags);
        tolua_function(tolua_S,"getActionByTag",lua_ax_base_Node_getActionByTag);
        tolua_function(tolua_S,"getNumberOfRunningActions",lua_ax_base_Node_getNumberOfRunningActions);
        tolua_function(tolua_S,"getNumberOfRunningActionsByTag",lua_ax_base_Node_getNumberOfRunningActionsByTag);
        tolua_function(tolua_S,"setScheduler",lua_ax_base_Node_setScheduler);
        tolua_function(tolua_S,"getScheduler",lua_ax_base_Node_getScheduler);
        tolua_function(tolua_S,"isScheduled",lua_ax_base_Node_isScheduled);
        tolua_function(tolua_S,"resume",lua_ax_base_Node_resume);
        tolua_function(tolua_S,"pause",lua_ax_base_Node_pause);
        tolua_function(tolua_S,"update",lua_ax_base_Node_update);
        tolua_function(tolua_S,"updateTransform",lua_ax_base_Node_updateTransform);
        tolua_function(tolua_S,"getNodeToParentTransform",lua_ax_base_Node_getNodeToParentTransform);
        tolua_function(tolua_S,"getNodeToParentAffineTransform",lua_ax_base_Node_getNodeToParentAffineTransform);
        tolua_function(tolua_S,"setNodeToParentTransform",lua_ax_base_Node_setNodeToParentTransform);
        tolua_function(tolua_S,"getParentToNodeTransform",lua_ax_base_Node_getParentToNodeTransform);
        tolua_function(tolua_S,"getParentToNodeAffineTransform",lua_ax_base_Node_getParentToNodeAffineTransform);
        tolua_function(tolua_S,"getNodeToWorldTransform",lua_ax_base_Node_getNodeToWorldTransform);
        tolua_function(tolua_S,"getNodeToWorldAffineTransform",lua_ax_base_Node_getNodeToWorldAffineTransform);
        tolua_function(tolua_S,"getWorldToNodeTransform",lua_ax_base_Node_getWorldToNodeTransform);
        tolua_function(tolua_S,"getWorldToNodeAffineTransform",lua_ax_base_Node_getWorldToNodeAffineTransform);
        tolua_function(tolua_S,"convertToNodeSpace",lua_ax_base_Node_convertToNodeSpace);
        tolua_function(tolua_S,"convertToWorldSpace",lua_ax_base_Node_convertToWorldSpace);
        tolua_function(tolua_S,"convertToNodeSpaceAR",lua_ax_base_Node_convertToNodeSpaceAR);
        tolua_function(tolua_S,"convertToWorldSpaceAR",lua_ax_base_Node_convertToWorldSpaceAR);
        tolua_function(tolua_S,"convertTouchToNodeSpace",lua_ax_base_Node_convertTouchToNodeSpace);
        tolua_function(tolua_S,"convertTouchToNodeSpaceAR",lua_ax_base_Node_convertTouchToNodeSpaceAR);
        tolua_function(tolua_S,"getWorldPosition",lua_ax_base_Node_getWorldPosition);
        tolua_function(tolua_S,"setWorldPosition",lua_ax_base_Node_setWorldPosition);
        tolua_function(tolua_S,"getComponent",lua_ax_base_Node_getComponent);
        tolua_function(tolua_S,"addComponent",lua_ax_base_Node_addComponent);
        tolua_function(tolua_S,"removeComponent",lua_ax_base_Node_removeComponent);
        tolua_function(tolua_S,"removeAllComponents",lua_ax_base_Node_removeAllComponents);
        tolua_function(tolua_S,"getOpacity",lua_ax_base_Node_getOpacity);
        tolua_function(tolua_S,"getDisplayedOpacity",lua_ax_base_Node_getDisplayedOpacity);
        tolua_function(tolua_S,"setOpacity",lua_ax_base_Node_setOpacity);
        tolua_function(tolua_S,"updateDisplayedOpacity",lua_ax_base_Node_updateDisplayedOpacity);
        tolua_function(tolua_S,"isCascadeOpacityEnabled",lua_ax_base_Node_isCascadeOpacityEnabled);
        tolua_function(tolua_S,"setCascadeOpacityEnabled",lua_ax_base_Node_setCascadeOpacityEnabled);
        tolua_function(tolua_S,"getColor",lua_ax_base_Node_getColor);
        tolua_function(tolua_S,"getDisplayedColor",lua_ax_base_Node_getDisplayedColor);
        tolua_function(tolua_S,"setColor",lua_ax_base_Node_setColor);
        tolua_function(tolua_S,"updateDisplayedColor",lua_ax_base_Node_updateDisplayedColor);
        tolua_function(tolua_S,"isCascadeColorEnabled",lua_ax_base_Node_isCascadeColorEnabled);
        tolua_function(tolua_S,"setCascadeColorEnabled",lua_ax_base_Node_setCascadeColorEnabled);
        tolua_function(tolua_S,"setOpacityModifyRGB",lua_ax_base_Node_setOpacityModifyRGB);
        tolua_function(tolua_S,"isOpacityModifyRGB",lua_ax_base_Node_isOpacityModifyRGB);
        tolua_function(tolua_S,"setOnEnterCallback",lua_ax_base_Node_setOnEnterCallback);
        tolua_function(tolua_S,"setOnExitCallback",lua_ax_base_Node_setOnExitCallback);
        tolua_function(tolua_S,"setOnEnterTransitionDidFinishCallback",lua_ax_base_Node_setOnEnterTransitionDidFinishCallback);
        tolua_function(tolua_S,"getOnEnterTransitionDidFinishCallback",lua_ax_base_Node_getOnEnterTransitionDidFinishCallback);
        tolua_function(tolua_S,"setOnExitTransitionDidStartCallback",lua_ax_base_Node_setOnExitTransitionDidStartCallback);
        tolua_function(tolua_S,"getOnExitTransitionDidStartCallback",lua_ax_base_Node_getOnExitTransitionDidStartCallback);
        tolua_function(tolua_S,"getCameraMask",lua_ax_base_Node_getCameraMask);
        tolua_function(tolua_S,"setCameraMask",lua_ax_base_Node_setCameraMask);
        tolua_function(tolua_S,"applyMaskOnEnter",lua_ax_base_Node_applyMaskOnEnter);
        tolua_function(tolua_S,"setProgramState",lua_ax_base_Node_setProgramState);
        tolua_function(tolua_S,"setProgramStateWithRegistry",lua_ax_base_Node_setProgramStateWithRegistry);
        tolua_function(tolua_S,"setProgramStateByProgramId",lua_ax_base_Node_setProgramStateByProgramId);
        tolua_function(tolua_S,"getProgramState",lua_ax_base_Node_getProgramState);
        tolua_function(tolua_S,"updateProgramStateTexture",lua_ax_base_Node_updateProgramStateTexture);
        tolua_function(tolua_S,"resetChild",lua_ax_base_Node_resetChild);
        tolua_function(tolua_S,"init",lua_ax_base_Node_init);
        tolua_function(tolua_S,"initLayer",lua_ax_base_Node_initLayer);
        tolua_function(tolua_S,"setPhysicsBody",lua_ax_base_Node_setPhysicsBody);
        tolua_function(tolua_S,"getPhysicsBody",lua_ax_base_Node_getPhysicsBody);
        tolua_function(tolua_S,"create", lua_ax_base_Node_create);
        tolua_function(tolua_S,"getAttachedNodeCount", lua_ax_base_Node_getAttachedNodeCount);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Node).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Node";
    g_typeCast[typeName] = "ax.Node";
    return 1;
}

int lua_ax_base_Scene_getDefaultCamera(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_getDefaultCamera'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_getDefaultCamera'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDefaultCamera();
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:getDefaultCamera",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_getDefaultCamera'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_render(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_render'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Renderer* arg0;
        ax::Mat4 arg1;

        ok &= luaval_to_object<ax::Renderer>(tolua_S, 2, "ax.Renderer",&arg0, "ax.Scene:render");

        ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Scene:render");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_render'", nullptr);
            return 0;
        }
        cobj->render(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 3) 
    {
        ax::Renderer* arg0;
        ax::Mat4 arg1;
        const ax::Mat4* arg2;

        ok &= luaval_to_object<ax::Renderer>(tolua_S, 2, "ax.Renderer",&arg0, "ax.Scene:render");

        ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Scene:render");

        ok &= luaval_to_object<const ax::Mat4>(tolua_S, 4, "ax.Mat4",&arg2, "ax.Scene:render");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_render'", nullptr);
            return 0;
        }
        cobj->render(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:render",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_render'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_initWithSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_initWithSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Scene:initWithSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_initWithSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSize(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:initWithSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_initWithSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_setCameraOrderDirty(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_setCameraOrderDirty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_setCameraOrderDirty'", nullptr);
            return 0;
        }
        cobj->setCameraOrderDirty();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:setCameraOrderDirty",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_setCameraOrderDirty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_onProjectionChanged(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_onProjectionChanged'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventCustom* arg0;

        ok &= luaval_to_object<ax::EventCustom>(tolua_S, 2, "ax.EventCustom",&arg0, "ax.Scene:onProjectionChanged");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_onProjectionChanged'", nullptr);
            return 0;
        }
        cobj->onProjectionChanged(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:onProjectionChanged",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_onProjectionChanged'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_getPhysicsWorld(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_getPhysicsWorld'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_getPhysicsWorld'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPhysicsWorld();
        object_to_luaval<ax::PhysicsWorld>(tolua_S, "ax.PhysicsWorld",(ax::PhysicsWorld*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:getPhysicsWorld",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_getPhysicsWorld'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_initWithPhysics(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_initWithPhysics'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_initWithPhysics'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithPhysics();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:initWithPhysics",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_initWithPhysics'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_initPhysicsWorld(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_initPhysicsWorld'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_initPhysicsWorld'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initPhysicsWorld();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:initPhysicsWorld",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_initPhysicsWorld'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_fixedUpdate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_fixedUpdate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Scene:fixedUpdate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_fixedUpdate'", nullptr);
            return 0;
        }
        cobj->fixedUpdate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:fixedUpdate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_fixedUpdate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_stepPhysicsAndNavigation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scene_stepPhysicsAndNavigation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Scene:stepPhysicsAndNavigation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_stepPhysicsAndNavigation'", nullptr);
            return 0;
        }
        cobj->stepPhysicsAndNavigation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:stepPhysicsAndNavigation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_stepPhysicsAndNavigation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scene_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Scene::create();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Scene:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Scene_createWithSize(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Vec2 arg0;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Scene:createWithSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_createWithSize'", nullptr);
            return 0;
        }
        auto&& ret = ax::Scene::createWithSize(arg0);
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Scene:createWithSize",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_createWithSize'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Scene_createWithPhysics(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Scene",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_createWithPhysics'", nullptr);
            return 0;
        }
        auto&& ret = ax::Scene::createWithPhysics();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Scene:createWithPhysics",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_createWithPhysics'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Scene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scene_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Scene();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Scene");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scene:Scene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scene_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Scene_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Scene)");
    return 0;
}

int lua_register_ax_base_Scene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Scene");
    tolua_cclass(tolua_S,"Scene","ax.Scene","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Scene");
        tolua_function(tolua_S,"new",lua_ax_base_Scene_constructor);
        tolua_function(tolua_S,"getDefaultCamera",lua_ax_base_Scene_getDefaultCamera);
        tolua_function(tolua_S,"render",lua_ax_base_Scene_render);
        tolua_function(tolua_S,"initWithSize",lua_ax_base_Scene_initWithSize);
        tolua_function(tolua_S,"setCameraOrderDirty",lua_ax_base_Scene_setCameraOrderDirty);
        tolua_function(tolua_S,"onProjectionChanged",lua_ax_base_Scene_onProjectionChanged);
        tolua_function(tolua_S,"getPhysicsWorld",lua_ax_base_Scene_getPhysicsWorld);
        tolua_function(tolua_S,"initWithPhysics",lua_ax_base_Scene_initWithPhysics);
        tolua_function(tolua_S,"initPhysicsWorld",lua_ax_base_Scene_initPhysicsWorld);
        tolua_function(tolua_S,"fixedUpdate",lua_ax_base_Scene_fixedUpdate);
        tolua_function(tolua_S,"stepPhysicsAndNavigation",lua_ax_base_Scene_stepPhysicsAndNavigation);
        tolua_function(tolua_S,"create", lua_ax_base_Scene_create);
        tolua_function(tolua_S,"createWithSize", lua_ax_base_Scene_createWithSize);
        tolua_function(tolua_S,"createWithPhysics", lua_ax_base_Scene_createWithPhysics);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Scene).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Scene";
    g_typeCast[typeName] = "ax.Scene";
    return 1;
}

int lua_ax_base_GLView_end(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_end'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_end'", nullptr);
            return 0;
        }
        cobj->end();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:end",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_end'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_isOpenGLReady(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_isOpenGLReady'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_isOpenGLReady'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isOpenGLReady();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:isOpenGLReady",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_isOpenGLReady'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_swapBuffers(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_swapBuffers'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_swapBuffers'", nullptr);
            return 0;
        }
        cobj->swapBuffers();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:swapBuffers",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_swapBuffers'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setIMEKeyboardState(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setIMEKeyboardState'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.GLView:setIMEKeyboardState");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setIMEKeyboardState'", nullptr);
            return 0;
        }
        cobj->setIMEKeyboardState(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setIMEKeyboardState",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setIMEKeyboardState'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_windowShouldClose(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_windowShouldClose'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_windowShouldClose'", nullptr);
            return 0;
        }
        auto&& ret = cobj->windowShouldClose();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:windowShouldClose",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_windowShouldClose'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_pollEvents(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_pollEvents'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_pollEvents'", nullptr);
            return 0;
        }
        cobj->pollEvents();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:pollEvents",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_pollEvents'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getFrameSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getFrameSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getFrameSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFrameSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getFrameSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getFrameSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setFrameSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setFrameSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setFrameSize");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.GLView:setFrameSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setFrameSize'", nullptr);
            return 0;
        }
        cobj->setFrameSize(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setFrameSize",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setFrameSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setFrameZoomFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setFrameZoomFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setFrameZoomFactor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setFrameZoomFactor'", nullptr);
            return 0;
        }
        cobj->setFrameZoomFactor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setFrameZoomFactor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setFrameZoomFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getFrameZoomFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getFrameZoomFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getFrameZoomFactor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFrameZoomFactor();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getFrameZoomFactor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getFrameZoomFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setCursorVisible(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setCursorVisible'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.GLView:setCursorVisible");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setCursorVisible'", nullptr);
            return 0;
        }
        cobj->setCursorVisible(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setCursorVisible",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setCursorVisible'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getRetinaFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getRetinaFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getRetinaFactor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRetinaFactor();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getRetinaFactor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getRetinaFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setContentScaleFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setContentScaleFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setContentScaleFactor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setContentScaleFactor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->setContentScaleFactor(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setContentScaleFactor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setContentScaleFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getContentScaleFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getContentScaleFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getContentScaleFactor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getContentScaleFactor();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getContentScaleFactor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getContentScaleFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_isRetinaDisplay(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_isRetinaDisplay'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_isRetinaDisplay'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isRetinaDisplay();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:isRetinaDisplay",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_isRetinaDisplay'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getVisibleSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getVisibleSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getVisibleSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVisibleSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getVisibleSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getVisibleSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getVisibleOrigin(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getVisibleOrigin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getVisibleOrigin'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVisibleOrigin();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getVisibleOrigin",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getVisibleOrigin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getVisibleRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getVisibleRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getVisibleRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVisibleRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getVisibleRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getVisibleRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getSafeAreaRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getSafeAreaRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getSafeAreaRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSafeAreaRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getSafeAreaRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getSafeAreaRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setDesignResolutionSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setDesignResolutionSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        double arg1;
        ResolutionPolicy arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setDesignResolutionSize");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.GLView:setDesignResolutionSize");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.GLView:setDesignResolutionSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setDesignResolutionSize'", nullptr);
            return 0;
        }
        cobj->setDesignResolutionSize(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setDesignResolutionSize",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setDesignResolutionSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getDesignResolutionSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getDesignResolutionSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getDesignResolutionSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDesignResolutionSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getDesignResolutionSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getDesignResolutionSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setViewPortInPoints(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setViewPortInPoints'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setViewPortInPoints");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.GLView:setViewPortInPoints");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.GLView:setViewPortInPoints");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.GLView:setViewPortInPoints");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setViewPortInPoints'", nullptr);
            return 0;
        }
        cobj->setViewPortInPoints(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setViewPortInPoints",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setViewPortInPoints'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setScissorInPoints(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setScissorInPoints'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GLView:setScissorInPoints");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.GLView:setScissorInPoints");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.GLView:setScissorInPoints");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.GLView:setScissorInPoints");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setScissorInPoints'", nullptr);
            return 0;
        }
        cobj->setScissorInPoints(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setScissorInPoints",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setScissorInPoints'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_isScissorEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_isScissorEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_isScissorEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isScissorEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:isScissorEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_isScissorEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getScissorRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getScissorRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getScissorRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScissorRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getScissorRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getScissorRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setViewName(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setViewName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLView:setViewName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setViewName'", nullptr);
            return 0;
        }
        cobj->setViewName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setViewName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setViewName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getViewName(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getViewName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getViewName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getViewName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getViewName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getViewName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setIcon(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setIcon'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::vector<std::string_view> arg0;
            ok &= luaval_to_std_vector_string_view(tolua_S, 2, &arg0, "ax.GLView:setIcon");

            if (!ok) { break; }
            cobj->setIcon(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLView:setIcon");

            if (!ok) { break; }
            cobj->setIcon(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.GLView:setIcon",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setIcon'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setDefaultIcon(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_setDefaultIcon'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setDefaultIcon'", nullptr);
            return 0;
        }
        cobj->setDefaultIcon();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:setDefaultIcon",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setDefaultIcon'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getViewPortRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getViewPortRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getViewPortRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getViewPortRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getViewPortRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getViewPortRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getScaleX(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getScaleX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getScaleX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScaleX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getScaleX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getScaleX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getScaleY(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getScaleY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getScaleY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScaleY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getScaleY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getScaleY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_getResolutionPolicy(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_getResolutionPolicy'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getResolutionPolicy'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getResolutionPolicy();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:getResolutionPolicy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getResolutionPolicy'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_renderScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::GLView* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GLView*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GLView_renderScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Scene* arg0;
        ax::Renderer* arg1;

        ok &= luaval_to_object<ax::Scene>(tolua_S, 2, "ax.Scene",&arg0, "ax.GLView:renderScene");

        ok &= luaval_to_object<ax::Renderer>(tolua_S, 3, "ax.Renderer",&arg1, "ax.GLView:renderScene");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_renderScene'", nullptr);
            return 0;
        }
        cobj->renderScene(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GLView:renderScene",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_renderScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GLView_setGLContextAttrs(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        GLContextAttrs arg0;
        #pragma warning NO CONVERSION TO NATIVE FOR GLContextAttrs
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_setGLContextAttrs'", nullptr);
            return 0;
        }
        ax::GLView::setGLContextAttrs(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.GLView:setGLContextAttrs",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_setGLContextAttrs'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_GLView_getGLContextAttrs(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.GLView",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLView_getGLContextAttrs'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLView::getGLContextAttrs();
        #pragma warning NO CONVERSION FROM NATIVE FOR GLContextAttrs;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.GLView:getGLContextAttrs",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLView_getGLContextAttrs'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_GLView_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (GLView)");
    return 0;
}

int lua_register_ax_base_GLView(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.GLView");
    tolua_cclass(tolua_S,"GLView","ax.GLView","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"GLView");
        tolua_function(tolua_S,"endToLua",lua_ax_base_GLView_end);
        tolua_function(tolua_S,"isOpenGLReady",lua_ax_base_GLView_isOpenGLReady);
        tolua_function(tolua_S,"swapBuffers",lua_ax_base_GLView_swapBuffers);
        tolua_function(tolua_S,"setIMEKeyboardState",lua_ax_base_GLView_setIMEKeyboardState);
        tolua_function(tolua_S,"windowShouldClose",lua_ax_base_GLView_windowShouldClose);
        tolua_function(tolua_S,"pollEvents",lua_ax_base_GLView_pollEvents);
        tolua_function(tolua_S,"getFrameSize",lua_ax_base_GLView_getFrameSize);
        tolua_function(tolua_S,"setFrameSize",lua_ax_base_GLView_setFrameSize);
        tolua_function(tolua_S,"setFrameZoomFactor",lua_ax_base_GLView_setFrameZoomFactor);
        tolua_function(tolua_S,"getFrameZoomFactor",lua_ax_base_GLView_getFrameZoomFactor);
        tolua_function(tolua_S,"setCursorVisible",lua_ax_base_GLView_setCursorVisible);
        tolua_function(tolua_S,"getRetinaFactor",lua_ax_base_GLView_getRetinaFactor);
        tolua_function(tolua_S,"setContentScaleFactor",lua_ax_base_GLView_setContentScaleFactor);
        tolua_function(tolua_S,"getContentScaleFactor",lua_ax_base_GLView_getContentScaleFactor);
        tolua_function(tolua_S,"isRetinaDisplay",lua_ax_base_GLView_isRetinaDisplay);
        tolua_function(tolua_S,"getVisibleSize",lua_ax_base_GLView_getVisibleSize);
        tolua_function(tolua_S,"getVisibleOrigin",lua_ax_base_GLView_getVisibleOrigin);
        tolua_function(tolua_S,"getVisibleRect",lua_ax_base_GLView_getVisibleRect);
        tolua_function(tolua_S,"getSafeAreaRect",lua_ax_base_GLView_getSafeAreaRect);
        tolua_function(tolua_S,"setDesignResolutionSize",lua_ax_base_GLView_setDesignResolutionSize);
        tolua_function(tolua_S,"getDesignResolutionSize",lua_ax_base_GLView_getDesignResolutionSize);
        tolua_function(tolua_S,"setViewPortInPoints",lua_ax_base_GLView_setViewPortInPoints);
        tolua_function(tolua_S,"setScissorInPoints",lua_ax_base_GLView_setScissorInPoints);
        tolua_function(tolua_S,"isScissorEnabled",lua_ax_base_GLView_isScissorEnabled);
        tolua_function(tolua_S,"getScissorRect",lua_ax_base_GLView_getScissorRect);
        tolua_function(tolua_S,"setViewName",lua_ax_base_GLView_setViewName);
        tolua_function(tolua_S,"getViewName",lua_ax_base_GLView_getViewName);
        tolua_function(tolua_S,"setIcon",lua_ax_base_GLView_setIcon);
        tolua_function(tolua_S,"setDefaultIcon",lua_ax_base_GLView_setDefaultIcon);
        tolua_function(tolua_S,"getViewPortRect",lua_ax_base_GLView_getViewPortRect);
        tolua_function(tolua_S,"getScaleX",lua_ax_base_GLView_getScaleX);
        tolua_function(tolua_S,"getScaleY",lua_ax_base_GLView_getScaleY);
        tolua_function(tolua_S,"getResolutionPolicy",lua_ax_base_GLView_getResolutionPolicy);
        tolua_function(tolua_S,"renderScene",lua_ax_base_GLView_renderScene);
        tolua_function(tolua_S,"setGLContextAttrs", lua_ax_base_GLView_setGLContextAttrs);
        tolua_function(tolua_S,"getGLContextAttrs", lua_ax_base_GLView_getGLContextAttrs);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::GLView).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.GLView";
    g_typeCast[typeName] = "ax.GLView";
    return 1;
}

int lua_ax_base_Director_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getRunningScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getRunningScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getRunningScene'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRunningScene();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getRunningScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getRunningScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getNextScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getNextScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getNextScene'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNextScene();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getNextScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getNextScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getAnimationInterval(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getAnimationInterval'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getAnimationInterval'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnimationInterval();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getAnimationInterval",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getAnimationInterval'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setAnimationInterval(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setAnimationInterval'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Director:setAnimationInterval");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setAnimationInterval'", nullptr);
            return 0;
        }
        cobj->setAnimationInterval(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setAnimationInterval",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setAnimationInterval'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isStatsDisplay(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isStatsDisplay'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isStatsDisplay'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStatsDisplay();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isStatsDisplay",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isStatsDisplay'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setStatsDisplay(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setStatsDisplay'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Director:setStatsDisplay");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setStatsDisplay'", nullptr);
            return 0;
        }
        cobj->setStatsDisplay(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setStatsDisplay",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setStatsDisplay'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getSecondsPerFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getSecondsPerFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getSecondsPerFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSecondsPerFrame();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getSecondsPerFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getSecondsPerFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setStatsAnchor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setStatsAnchor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setStatsAnchor'", nullptr);
            return 0;
        }
        cobj->setStatsAnchor();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        ax::AnchorPreset arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:setStatsAnchor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setStatsAnchor'", nullptr);
            return 0;
        }
        cobj->setStatsAnchor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setStatsAnchor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setStatsAnchor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getGLView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getGLView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getGLView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGLView();
        object_to_luaval<ax::GLView>(tolua_S, "ax.GLView",(ax::GLView*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getGLView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getGLView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setGLView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setGLView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::GLView* arg0;

        ok &= luaval_to_object<ax::GLView>(tolua_S, 2, "ax.GLView",&arg0, "ax.Director:setGLView");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setGLView'", nullptr);
            return 0;
        }
        cobj->setGLView(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setGLView",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setGLView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getTextureCache(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getTextureCache'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getTextureCache'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureCache();
        object_to_luaval<ax::TextureCache>(tolua_S, "ax.TextureCache",(ax::TextureCache*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getTextureCache",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getTextureCache'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isNextDeltaTimeZero(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isNextDeltaTimeZero'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isNextDeltaTimeZero'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isNextDeltaTimeZero();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isNextDeltaTimeZero",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isNextDeltaTimeZero'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setNextDeltaTimeZero(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setNextDeltaTimeZero'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Director:setNextDeltaTimeZero");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setNextDeltaTimeZero'", nullptr);
            return 0;
        }
        cobj->setNextDeltaTimeZero(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setNextDeltaTimeZero",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setNextDeltaTimeZero'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isPaused(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isPaused'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isPaused'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isPaused();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isPaused",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isPaused'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getTotalFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getTotalFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getTotalFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTotalFrames();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getTotalFrames",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getTotalFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setProjection(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setProjection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Director::Projection arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:setProjection");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setProjection'", nullptr);
            return 0;
        }
        cobj->setProjection(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setProjection",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setProjection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setViewport(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setViewport'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setViewport'", nullptr);
            return 0;
        }
        cobj->setViewport();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setViewport",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setViewport'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isSendCleanupToScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isSendCleanupToScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isSendCleanupToScene'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSendCleanupToScene();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isSendCleanupToScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isSendCleanupToScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getNotificationNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getNotificationNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getNotificationNode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNotificationNode();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getNotificationNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getNotificationNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setNotificationNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setNotificationNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Director:setNotificationNode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setNotificationNode'", nullptr);
            return 0;
        }
        cobj->setNotificationNode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setNotificationNode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setNotificationNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getWinSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getWinSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getWinSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWinSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getWinSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getWinSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getWinSizeInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getWinSizeInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getWinSizeInPixels'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWinSizeInPixels();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getWinSizeInPixels",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getWinSizeInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getVisibleSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getVisibleSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getVisibleSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVisibleSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getVisibleSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getVisibleSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getVisibleOrigin(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getVisibleOrigin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getVisibleOrigin'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVisibleOrigin();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getVisibleOrigin",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getVisibleOrigin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getSafeAreaRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getSafeAreaRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getSafeAreaRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSafeAreaRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getSafeAreaRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getSafeAreaRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_convertToGL(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_convertToGL'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Director:convertToGL");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_convertToGL'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToGL(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:convertToGL",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_convertToGL'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_convertToUI(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_convertToUI'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Director:convertToUI");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_convertToUI'", nullptr);
            return 0;
        }
        auto&& ret = cobj->convertToUI(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:convertToUI",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_convertToUI'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getZEye(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getZEye'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getZEye'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getZEye();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getZEye",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getZEye'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_runWithScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_runWithScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scene* arg0;

        ok &= luaval_to_object<ax::Scene>(tolua_S, 2, "ax.Scene",&arg0, "ax.Director:runWithScene");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_runWithScene'", nullptr);
            return 0;
        }
        cobj->runWithScene(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:runWithScene",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_runWithScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_pushScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_pushScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scene* arg0;

        ok &= luaval_to_object<ax::Scene>(tolua_S, 2, "ax.Scene",&arg0, "ax.Director:pushScene");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_pushScene'", nullptr);
            return 0;
        }
        cobj->pushScene(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:pushScene",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_pushScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_popScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_popScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_popScene'", nullptr);
            return 0;
        }
        cobj->popScene();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:popScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_popScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_popToRootScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_popToRootScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_popToRootScene'", nullptr);
            return 0;
        }
        cobj->popToRootScene();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:popToRootScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_popToRootScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_popToSceneStackLevel(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_popToSceneStackLevel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:popToSceneStackLevel");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_popToSceneStackLevel'", nullptr);
            return 0;
        }
        cobj->popToSceneStackLevel(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:popToSceneStackLevel",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_popToSceneStackLevel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_replaceScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_replaceScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scene* arg0;

        ok &= luaval_to_object<ax::Scene>(tolua_S, 2, "ax.Scene",&arg0, "ax.Director:replaceScene");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_replaceScene'", nullptr);
            return 0;
        }
        cobj->replaceScene(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:replaceScene",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_replaceScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_end(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_end'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_end'", nullptr);
            return 0;
        }
        cobj->end();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:end",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_end'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_pause(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_pause'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_pause'", nullptr);
            return 0;
        }
        cobj->pause();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:pause",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_pause'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_resume(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_resume'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_resume'", nullptr);
            return 0;
        }
        cobj->resume();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:resume",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_resume'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_restart(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_restart'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_restart'", nullptr);
            return 0;
        }
        cobj->restart();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:restart",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_restart'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_stopAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_stopAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_stopAnimation'", nullptr);
            return 0;
        }
        cobj->stopAnimation();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:stopAnimation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_stopAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_startAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_startAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_startAnimation'", nullptr);
            return 0;
        }
        cobj->startAnimation();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:startAnimation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_startAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_drawScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_drawScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_drawScene'", nullptr);
            return 0;
        }
        cobj->drawScene();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:drawScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_drawScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_purgeCachedData(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_purgeCachedData'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_purgeCachedData'", nullptr);
            return 0;
        }
        cobj->purgeCachedData();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:purgeCachedData",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_purgeCachedData'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setDefaultValues(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setDefaultValues'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setDefaultValues'", nullptr);
            return 0;
        }
        cobj->setDefaultValues();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setDefaultValues",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setDefaultValues'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setGLDefaultValues(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setGLDefaultValues'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setGLDefaultValues'", nullptr);
            return 0;
        }
        cobj->setGLDefaultValues();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setGLDefaultValues",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setGLDefaultValues'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setClearColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setClearColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.Director:setClearColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setClearColor'", nullptr);
            return 0;
        }
        cobj->setClearColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setClearColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setClearColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_mainLoop(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_mainLoop'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Director:mainLoop");

            if (!ok) { break; }
            cobj->mainLoop(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->mainLoop();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Director:mainLoop",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_mainLoop'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setContentScaleFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setContentScaleFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Director:setContentScaleFactor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setContentScaleFactor'", nullptr);
            return 0;
        }
        cobj->setContentScaleFactor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setContentScaleFactor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setContentScaleFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getContentScaleFactor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getContentScaleFactor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getContentScaleFactor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getContentScaleFactor();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getContentScaleFactor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getContentScaleFactor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getScheduler(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getScheduler'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getScheduler'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScheduler();
        object_to_luaval<ax::Scheduler>(tolua_S, "ax.Scheduler",(ax::Scheduler*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getScheduler",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getScheduler'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setScheduler(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setScheduler'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scheduler* arg0;

        ok &= luaval_to_object<ax::Scheduler>(tolua_S, 2, "ax.Scheduler",&arg0, "ax.Director:setScheduler");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setScheduler'", nullptr);
            return 0;
        }
        cobj->setScheduler(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setScheduler",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setScheduler'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getActionManager(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getActionManager'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getActionManager'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getActionManager();
        object_to_luaval<ax::ActionManager>(tolua_S, "ax.ActionManager",(ax::ActionManager*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getActionManager",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getActionManager'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setActionManager(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setActionManager'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionManager* arg0;

        ok &= luaval_to_object<ax::ActionManager>(tolua_S, 2, "ax.ActionManager",&arg0, "ax.Director:setActionManager");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setActionManager'", nullptr);
            return 0;
        }
        cobj->setActionManager(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setActionManager",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setActionManager'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getEventDispatcher(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getEventDispatcher'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getEventDispatcher'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEventDispatcher();
        object_to_luaval<ax::EventDispatcher>(tolua_S, "ax.EventDispatcher",(ax::EventDispatcher*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getEventDispatcher",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getEventDispatcher'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setEventDispatcher(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setEventDispatcher'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventDispatcher* arg0;

        ok &= luaval_to_object<ax::EventDispatcher>(tolua_S, 2, "ax.EventDispatcher",&arg0, "ax.Director:setEventDispatcher");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setEventDispatcher'", nullptr);
            return 0;
        }
        cobj->setEventDispatcher(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setEventDispatcher",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setEventDispatcher'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getRenderer(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getRenderer'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getRenderer'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderer();
        object_to_luaval<ax::Renderer>(tolua_S, "ax.Renderer",(ax::Renderer*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getRenderer",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getRenderer'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getDeltaTime(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getDeltaTime'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getDeltaTime'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDeltaTime();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getDeltaTime",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getDeltaTime'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getFrameRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getFrameRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getFrameRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFrameRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getFrameRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getFrameRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_pushMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_pushMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MATRIX_STACK_TYPE arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:pushMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_pushMatrix'", nullptr);
            return 0;
        }
        cobj->pushMatrix(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:pushMatrix",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_pushMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_popMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_popMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MATRIX_STACK_TYPE arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:popMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_popMatrix'", nullptr);
            return 0;
        }
        cobj->popMatrix(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:popMatrix",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_popMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_loadIdentityMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_loadIdentityMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MATRIX_STACK_TYPE arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:loadIdentityMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_loadIdentityMatrix'", nullptr);
            return 0;
        }
        cobj->loadIdentityMatrix(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:loadIdentityMatrix",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_loadIdentityMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_loadMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_loadMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::MATRIX_STACK_TYPE arg0;
        ax::Mat4 arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:loadMatrix");

        ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Director:loadMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_loadMatrix'", nullptr);
            return 0;
        }
        cobj->loadMatrix(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:loadMatrix",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_loadMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_multiplyMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_multiplyMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::MATRIX_STACK_TYPE arg0;
        ax::Mat4 arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:multiplyMatrix");

        ok &= luaval_to_mat4(tolua_S, 3, &arg1, "ax.Director:multiplyMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_multiplyMatrix'", nullptr);
            return 0;
        }
        cobj->multiplyMatrix(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:multiplyMatrix",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_multiplyMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MATRIX_STACK_TYPE arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Director:getMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getMatrix'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMatrix(arg0);
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getMatrix",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_resetMatrixStack(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_resetMatrixStack'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_resetMatrixStack'", nullptr);
            return 0;
        }
        cobj->resetMatrixStack();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:resetMatrixStack",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_resetMatrixStack'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getAxmolThreadId(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_getAxmolThreadId'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getAxmolThreadId'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAxmolThreadId();
        std_thread_id_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:getAxmolThreadId",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getAxmolThreadId'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_setChildrenIndexerEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_setChildrenIndexerEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Director:setChildrenIndexerEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_setChildrenIndexerEnabled'", nullptr);
            return 0;
        }
        cobj->setChildrenIndexerEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:setChildrenIndexerEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_setChildrenIndexerEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isChildrenIndexerEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isChildrenIndexerEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isChildrenIndexerEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isChildrenIndexerEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isChildrenIndexerEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isChildrenIndexerEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_isValid(lua_State* tolua_S)
{
    int argc = 0;
    ax::Director* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Director*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Director_isValid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_isValid'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Director:isValid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_isValid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Director_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::Director::getInstance();
        object_to_luaval<ax::Director>(tolua_S, "ax.Director",(ax::Director*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Director:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Director_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Director",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Director_destroyInstance'", nullptr);
            return 0;
        }
        ax::Director::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Director:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Director_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Director_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Director)");
    return 0;
}

int lua_register_ax_base_Director(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Director");
    tolua_cclass(tolua_S,"Director","ax.Director","",nullptr);

    tolua_beginmodule(tolua_S,"Director");
        tolua_function(tolua_S,"init",lua_ax_base_Director_init);
        tolua_function(tolua_S,"getRunningScene",lua_ax_base_Director_getRunningScene);
        tolua_function(tolua_S,"getNextScene",lua_ax_base_Director_getNextScene);
        tolua_function(tolua_S,"getAnimationInterval",lua_ax_base_Director_getAnimationInterval);
        tolua_function(tolua_S,"setAnimationInterval",lua_ax_base_Director_setAnimationInterval);
        tolua_function(tolua_S,"isStatsDisplay",lua_ax_base_Director_isStatsDisplay);
        tolua_function(tolua_S,"setStatsDisplay",lua_ax_base_Director_setStatsDisplay);
        tolua_function(tolua_S,"getSecondsPerFrame",lua_ax_base_Director_getSecondsPerFrame);
        tolua_function(tolua_S,"setStatsAnchor",lua_ax_base_Director_setStatsAnchor);
        tolua_function(tolua_S,"getGLView",lua_ax_base_Director_getGLView);
        tolua_function(tolua_S,"setGLView",lua_ax_base_Director_setGLView);
        tolua_function(tolua_S,"getTextureCache",lua_ax_base_Director_getTextureCache);
        tolua_function(tolua_S,"isNextDeltaTimeZero",lua_ax_base_Director_isNextDeltaTimeZero);
        tolua_function(tolua_S,"setNextDeltaTimeZero",lua_ax_base_Director_setNextDeltaTimeZero);
        tolua_function(tolua_S,"isPaused",lua_ax_base_Director_isPaused);
        tolua_function(tolua_S,"getTotalFrames",lua_ax_base_Director_getTotalFrames);
        tolua_function(tolua_S,"setProjection",lua_ax_base_Director_setProjection);
        tolua_function(tolua_S,"setViewport",lua_ax_base_Director_setViewport);
        tolua_function(tolua_S,"isSendCleanupToScene",lua_ax_base_Director_isSendCleanupToScene);
        tolua_function(tolua_S,"getNotificationNode",lua_ax_base_Director_getNotificationNode);
        tolua_function(tolua_S,"setNotificationNode",lua_ax_base_Director_setNotificationNode);
        tolua_function(tolua_S,"getWinSize",lua_ax_base_Director_getWinSize);
        tolua_function(tolua_S,"getWinSizeInPixels",lua_ax_base_Director_getWinSizeInPixels);
        tolua_function(tolua_S,"getVisibleSize",lua_ax_base_Director_getVisibleSize);
        tolua_function(tolua_S,"getVisibleOrigin",lua_ax_base_Director_getVisibleOrigin);
        tolua_function(tolua_S,"getSafeAreaRect",lua_ax_base_Director_getSafeAreaRect);
        tolua_function(tolua_S,"convertToGL",lua_ax_base_Director_convertToGL);
        tolua_function(tolua_S,"convertToUI",lua_ax_base_Director_convertToUI);
        tolua_function(tolua_S,"getZEye",lua_ax_base_Director_getZEye);
        tolua_function(tolua_S,"runWithScene",lua_ax_base_Director_runWithScene);
        tolua_function(tolua_S,"pushScene",lua_ax_base_Director_pushScene);
        tolua_function(tolua_S,"popScene",lua_ax_base_Director_popScene);
        tolua_function(tolua_S,"popToRootScene",lua_ax_base_Director_popToRootScene);
        tolua_function(tolua_S,"popToSceneStackLevel",lua_ax_base_Director_popToSceneStackLevel);
        tolua_function(tolua_S,"replaceScene",lua_ax_base_Director_replaceScene);
        tolua_function(tolua_S,"endToLua",lua_ax_base_Director_end);
        tolua_function(tolua_S,"pause",lua_ax_base_Director_pause);
        tolua_function(tolua_S,"resume",lua_ax_base_Director_resume);
        tolua_function(tolua_S,"restart",lua_ax_base_Director_restart);
        tolua_function(tolua_S,"stopAnimation",lua_ax_base_Director_stopAnimation);
        tolua_function(tolua_S,"startAnimation",lua_ax_base_Director_startAnimation);
        tolua_function(tolua_S,"drawScene",lua_ax_base_Director_drawScene);
        tolua_function(tolua_S,"purgeCachedData",lua_ax_base_Director_purgeCachedData);
        tolua_function(tolua_S,"setDefaultValues",lua_ax_base_Director_setDefaultValues);
        tolua_function(tolua_S,"setGLDefaultValues",lua_ax_base_Director_setGLDefaultValues);
        tolua_function(tolua_S,"setClearColor",lua_ax_base_Director_setClearColor);
        tolua_function(tolua_S,"mainLoop",lua_ax_base_Director_mainLoop);
        tolua_function(tolua_S,"setContentScaleFactor",lua_ax_base_Director_setContentScaleFactor);
        tolua_function(tolua_S,"getContentScaleFactor",lua_ax_base_Director_getContentScaleFactor);
        tolua_function(tolua_S,"getScheduler",lua_ax_base_Director_getScheduler);
        tolua_function(tolua_S,"setScheduler",lua_ax_base_Director_setScheduler);
        tolua_function(tolua_S,"getActionManager",lua_ax_base_Director_getActionManager);
        tolua_function(tolua_S,"setActionManager",lua_ax_base_Director_setActionManager);
        tolua_function(tolua_S,"getEventDispatcher",lua_ax_base_Director_getEventDispatcher);
        tolua_function(tolua_S,"setEventDispatcher",lua_ax_base_Director_setEventDispatcher);
        tolua_function(tolua_S,"getRenderer",lua_ax_base_Director_getRenderer);
        tolua_function(tolua_S,"getDeltaTime",lua_ax_base_Director_getDeltaTime);
        tolua_function(tolua_S,"getFrameRate",lua_ax_base_Director_getFrameRate);
        tolua_function(tolua_S,"pushMatrix",lua_ax_base_Director_pushMatrix);
        tolua_function(tolua_S,"popMatrix",lua_ax_base_Director_popMatrix);
        tolua_function(tolua_S,"loadIdentityMatrix",lua_ax_base_Director_loadIdentityMatrix);
        tolua_function(tolua_S,"loadMatrix",lua_ax_base_Director_loadMatrix);
        tolua_function(tolua_S,"multiplyMatrix",lua_ax_base_Director_multiplyMatrix);
        tolua_function(tolua_S,"getMatrix",lua_ax_base_Director_getMatrix);
        tolua_function(tolua_S,"resetMatrixStack",lua_ax_base_Director_resetMatrixStack);
        tolua_function(tolua_S,"getAxmolThreadId",lua_ax_base_Director_getAxmolThreadId);
        tolua_function(tolua_S,"setChildrenIndexerEnabled",lua_ax_base_Director_setChildrenIndexerEnabled);
        tolua_function(tolua_S,"isChildrenIndexerEnabled",lua_ax_base_Director_isChildrenIndexerEnabled);
        tolua_function(tolua_S,"isValid",lua_ax_base_Director_isValid);
        tolua_function(tolua_S,"getInstance", lua_ax_base_Director_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_Director_destroyInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Director).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Director";
    g_typeCast[typeName] = "ax.Director";
    return 1;
}

int lua_ax_base_Timer_setupTimerWithInterval(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_setupTimerWithInterval'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        unsigned int arg1;
        double arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Timer:setupTimerWithInterval");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Timer:setupTimerWithInterval");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Timer:setupTimerWithInterval");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_setupTimerWithInterval'", nullptr);
            return 0;
        }
        cobj->setupTimerWithInterval(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:setupTimerWithInterval",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_setupTimerWithInterval'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_setAborted(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_setAborted'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_setAborted'", nullptr);
            return 0;
        }
        cobj->setAborted();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:setAborted",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_setAborted'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_isAborted(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_isAborted'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_isAborted'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAborted();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:isAborted",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_isAborted'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_isExhausted(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_isExhausted'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_isExhausted'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isExhausted();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:isExhausted",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_isExhausted'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_trigger(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_trigger'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Timer:trigger");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_trigger'", nullptr);
            return 0;
        }
        cobj->trigger(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:trigger",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_trigger'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_cancel(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_cancel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_cancel'", nullptr);
            return 0;
        }
        cobj->cancel();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:cancel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_cancel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Timer_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::Timer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Timer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Timer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Timer_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Timer:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Timer_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Timer:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Timer_update'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_Timer_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Timer)");
    return 0;
}

int lua_register_ax_base_Timer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Timer");
    tolua_cclass(tolua_S,"Timer","ax.Timer","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Timer");
        tolua_function(tolua_S,"setupTimerWithInterval",lua_ax_base_Timer_setupTimerWithInterval);
        tolua_function(tolua_S,"setAborted",lua_ax_base_Timer_setAborted);
        tolua_function(tolua_S,"isAborted",lua_ax_base_Timer_isAborted);
        tolua_function(tolua_S,"isExhausted",lua_ax_base_Timer_isExhausted);
        tolua_function(tolua_S,"trigger",lua_ax_base_Timer_trigger);
        tolua_function(tolua_S,"cancel",lua_ax_base_Timer_cancel);
        tolua_function(tolua_S,"update",lua_ax_base_Timer_update);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Timer).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Timer";
    g_typeCast[typeName] = "ax.Timer";
    return 1;
}

int lua_ax_base_Scheduler_getTimeScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scheduler* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scheduler",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scheduler*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scheduler_getTimeScale'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scheduler_getTimeScale'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTimeScale();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scheduler:getTimeScale",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scheduler_getTimeScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scheduler_setTimeScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scheduler* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scheduler",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scheduler*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scheduler_setTimeScale'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Scheduler:setTimeScale");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scheduler_setTimeScale'", nullptr);
            return 0;
        }
        cobj->setTimeScale(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scheduler:setTimeScale",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scheduler_setTimeScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scheduler_runOnAxmolThread(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scheduler* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scheduler",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scheduler*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scheduler_runOnAxmolThread'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scheduler_runOnAxmolThread'", nullptr);
            return 0;
        }
        cobj->runOnAxmolThread(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scheduler:runOnAxmolThread",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scheduler_runOnAxmolThread'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scheduler_removeAllPendingActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scheduler* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Scheduler",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Scheduler*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Scheduler_removeAllPendingActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scheduler_removeAllPendingActions'", nullptr);
            return 0;
        }
        cobj->removeAllPendingActions();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scheduler:removeAllPendingActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scheduler_removeAllPendingActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Scheduler_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Scheduler* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Scheduler_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Scheduler();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Scheduler");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Scheduler:Scheduler",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Scheduler_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Scheduler_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Scheduler)");
    return 0;
}

int lua_register_ax_base_Scheduler(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Scheduler");
    tolua_cclass(tolua_S,"Scheduler","ax.Scheduler","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Scheduler");
        tolua_function(tolua_S,"new",lua_ax_base_Scheduler_constructor);
        tolua_function(tolua_S,"getTimeScale",lua_ax_base_Scheduler_getTimeScale);
        tolua_function(tolua_S,"setTimeScale",lua_ax_base_Scheduler_setTimeScale);
        tolua_function(tolua_S,"runOnAxmolThread",lua_ax_base_Scheduler_runOnAxmolThread);
        tolua_function(tolua_S,"removeAllPendingActions",lua_ax_base_Scheduler_removeAllPendingActions);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Scheduler).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Scheduler";
    g_typeCast[typeName] = "ax.Scheduler";
    return 1;
}

int lua_ax_base_AsyncTaskPool_stopTasks(lua_State* tolua_S)
{
    int argc = 0;
    ax::AsyncTaskPool* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AsyncTaskPool",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AsyncTaskPool*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AsyncTaskPool_stopTasks'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::AsyncTaskPool::TaskType arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.AsyncTaskPool:stopTasks");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AsyncTaskPool_stopTasks'", nullptr);
            return 0;
        }
        cobj->stopTasks(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AsyncTaskPool:stopTasks",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AsyncTaskPool_stopTasks'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AsyncTaskPool_enqueue(lua_State* tolua_S)
{
    int argc = 0;
    ax::AsyncTaskPool* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AsyncTaskPool",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::AsyncTaskPool*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AsyncTaskPool_enqueue'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::AsyncTaskPool::TaskType arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.AsyncTaskPool:enqueue");

            if (!ok) { break; }
            std::function<void ()> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->enqueue(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            ax::AsyncTaskPool::TaskType arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.AsyncTaskPool:enqueue");

            if (!ok) { break; }
            std::function<void (void *)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            void* arg2;
            #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

            if (!ok) { break; }
            std::function<void ()> arg3;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->enqueue(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.AsyncTaskPool:enqueue",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AsyncTaskPool_enqueue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AsyncTaskPool_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AsyncTaskPool",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AsyncTaskPool_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::AsyncTaskPool::getInstance();
        object_to_luaval<ax::AsyncTaskPool>(tolua_S, "ax.AsyncTaskPool",(ax::AsyncTaskPool*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AsyncTaskPool:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AsyncTaskPool_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AsyncTaskPool_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AsyncTaskPool",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AsyncTaskPool_destroyInstance'", nullptr);
            return 0;
        }
        ax::AsyncTaskPool::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AsyncTaskPool:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AsyncTaskPool_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AsyncTaskPool_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AsyncTaskPool* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AsyncTaskPool_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AsyncTaskPool();
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.AsyncTaskPool");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AsyncTaskPool:AsyncTaskPool",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AsyncTaskPool_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AsyncTaskPool_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AsyncTaskPool)");
    return 0;
}

int lua_register_ax_base_AsyncTaskPool(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AsyncTaskPool");
    tolua_cclass(tolua_S,"AsyncTaskPool","ax.AsyncTaskPool","",nullptr);

    tolua_beginmodule(tolua_S,"AsyncTaskPool");
        tolua_function(tolua_S,"new",lua_ax_base_AsyncTaskPool_constructor);
        tolua_function(tolua_S,"stopTasks",lua_ax_base_AsyncTaskPool_stopTasks);
        tolua_function(tolua_S,"enqueue",lua_ax_base_AsyncTaskPool_enqueue);
        tolua_function(tolua_S,"getInstance", lua_ax_base_AsyncTaskPool_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_AsyncTaskPool_destroyInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AsyncTaskPool).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AsyncTaskPool";
    g_typeCast[typeName] = "ax.AsyncTaskPool";
    return 1;
}

int lua_ax_base_Action_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::Action>(tolua_S, "ax.Action",(ax::Action*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_reverse(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_reverse'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_reverse'", nullptr);
            return 0;
        }
        auto&& ret = cobj->reverse();
        object_to_luaval<ax::Action>(tolua_S, "ax.Action",(ax::Action*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:reverse",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_reverse'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_isDone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_isDone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_isDone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isDone();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:isDone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_isDone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_startWithTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_startWithTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Action:startWithTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_startWithTarget'", nullptr);
            return 0;
        }
        cobj->startWithTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:startWithTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_startWithTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_stop(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_stop'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_stop'", nullptr);
            return 0;
        }
        cobj->stop();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:stop",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_stop'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_step(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_step'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Action:step");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_step'", nullptr);
            return 0;
        }
        cobj->step(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:step",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_step'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Action:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_update'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_getTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_getTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_getTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTarget();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:getTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_getTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_setTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_setTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Action:setTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_setTarget'", nullptr);
            return 0;
        }
        cobj->setTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:setTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_setTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_getOriginalTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_getOriginalTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_getOriginalTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOriginalTarget();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:getOriginalTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_getOriginalTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_setOriginalTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_setOriginalTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Action:setOriginalTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_setOriginalTarget'", nullptr);
            return 0;
        }
        cobj->setOriginalTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:setOriginalTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_setOriginalTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_getTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_getTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_getTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:getTag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_getTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_setTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_setTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Action:setTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_setTag'", nullptr);
            return 0;
        }
        cobj->setTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:setTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_setTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_getFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_getFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_getFlags'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFlags();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:getFlags",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_getFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Action_setFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::Action* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Action",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Action*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Action_setFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Action:setFlags");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Action_setFlags'", nullptr);
            return 0;
        }
        cobj->setFlags(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Action:setFlags",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Action_setFlags'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_Action_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Action)");
    return 0;
}

int lua_register_ax_base_Action(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Action");
    tolua_cclass(tolua_S,"Action","ax.Action","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Action");
        tolua_function(tolua_S,"clone",lua_ax_base_Action_clone);
        tolua_function(tolua_S,"reverse",lua_ax_base_Action_reverse);
        tolua_function(tolua_S,"isDone",lua_ax_base_Action_isDone);
        tolua_function(tolua_S,"startWithTarget",lua_ax_base_Action_startWithTarget);
        tolua_function(tolua_S,"stop",lua_ax_base_Action_stop);
        tolua_function(tolua_S,"step",lua_ax_base_Action_step);
        tolua_function(tolua_S,"update",lua_ax_base_Action_update);
        tolua_function(tolua_S,"getTarget",lua_ax_base_Action_getTarget);
        tolua_function(tolua_S,"setTarget",lua_ax_base_Action_setTarget);
        tolua_function(tolua_S,"getOriginalTarget",lua_ax_base_Action_getOriginalTarget);
        tolua_function(tolua_S,"setOriginalTarget",lua_ax_base_Action_setOriginalTarget);
        tolua_function(tolua_S,"getTag",lua_ax_base_Action_getTag);
        tolua_function(tolua_S,"setTag",lua_ax_base_Action_setTag);
        tolua_function(tolua_S,"getFlags",lua_ax_base_Action_getFlags);
        tolua_function(tolua_S,"setFlags",lua_ax_base_Action_setFlags);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Action).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Action";
    g_typeCast[typeName] = "ax.Action";
    return 1;
}

int lua_ax_base_FiniteTimeAction_getDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::FiniteTimeAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FiniteTimeAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FiniteTimeAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FiniteTimeAction_getDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FiniteTimeAction_getDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDuration();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FiniteTimeAction:getDuration",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FiniteTimeAction_getDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FiniteTimeAction_setDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::FiniteTimeAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FiniteTimeAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FiniteTimeAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FiniteTimeAction_setDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FiniteTimeAction:setDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FiniteTimeAction_setDuration'", nullptr);
            return 0;
        }
        cobj->setDuration(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FiniteTimeAction:setDuration",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FiniteTimeAction_setDuration'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_FiniteTimeAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FiniteTimeAction)");
    return 0;
}

int lua_register_ax_base_FiniteTimeAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FiniteTimeAction");
    tolua_cclass(tolua_S,"FiniteTimeAction","ax.FiniteTimeAction","ax.Action",nullptr);

    tolua_beginmodule(tolua_S,"FiniteTimeAction");
        tolua_function(tolua_S,"getDuration",lua_ax_base_FiniteTimeAction_getDuration);
        tolua_function(tolua_S,"setDuration",lua_ax_base_FiniteTimeAction_setDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FiniteTimeAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FiniteTimeAction";
    g_typeCast[typeName] = "ax.FiniteTimeAction";
    return 1;
}

int lua_ax_base_Speed_getSpeed(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Speed*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Speed_getSpeed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_getSpeed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpeed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:getSpeed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_getSpeed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Speed_setSpeed(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Speed*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Speed_setSpeed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Speed:setSpeed");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_setSpeed'", nullptr);
            return 0;
        }
        cobj->setSpeed(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:setSpeed",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_setSpeed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Speed_setInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Speed*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Speed_setInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.Speed:setInnerAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_setInnerAction'", nullptr);
            return 0;
        }
        cobj->setInnerAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:setInnerAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_setInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Speed_getInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Speed*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Speed_getInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_getInnerAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInnerAction();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:getInnerAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_getInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Speed_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Speed*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Speed_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ActionInterval* arg0;
        double arg1;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.Speed:initWithAction");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Speed:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:initWithAction",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_initWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Speed_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Speed",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.Speed:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Speed:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Speed::create(arg0, arg1);
        object_to_luaval<ax::Speed>(tolua_S, "ax.Speed",(ax::Speed*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Speed:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Speed_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Speed* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Speed_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Speed();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Speed");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Speed:Speed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Speed_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Speed_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Speed)");
    return 0;
}

int lua_register_ax_base_Speed(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Speed");
    tolua_cclass(tolua_S,"Speed","ax.Speed","ax.Action",nullptr);

    tolua_beginmodule(tolua_S,"Speed");
        tolua_function(tolua_S,"new",lua_ax_base_Speed_constructor);
        tolua_function(tolua_S,"getSpeed",lua_ax_base_Speed_getSpeed);
        tolua_function(tolua_S,"setSpeed",lua_ax_base_Speed_setSpeed);
        tolua_function(tolua_S,"setInnerAction",lua_ax_base_Speed_setInnerAction);
        tolua_function(tolua_S,"getInnerAction",lua_ax_base_Speed_getInnerAction);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_Speed_initWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_Speed_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Speed).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Speed";
    g_typeCast[typeName] = "ax.Speed";
    return 1;
}

int lua_ax_base_Follow_isBoundarySet(lua_State* tolua_S)
{
    int argc = 0;
    ax::Follow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Follow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Follow_isBoundarySet'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_isBoundarySet'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isBoundarySet();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Follow:isBoundarySet",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_isBoundarySet'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Follow_setBoundarySet(lua_State* tolua_S)
{
    int argc = 0;
    ax::Follow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Follow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Follow_setBoundarySet'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Follow:setBoundarySet");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_setBoundarySet'", nullptr);
            return 0;
        }
        cobj->setBoundarySet(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Follow:setBoundarySet",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_setBoundarySet'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Follow_initWithTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Follow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Follow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Follow_initWithTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:initWithTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_initWithTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTarget(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        ax::Rect arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:initWithTarget");

        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Follow:initWithTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_initWithTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTarget(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Follow:initWithTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_initWithTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Follow_initWithTargetAndOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::Follow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Follow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Follow_initWithTargetAndOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Node* arg0;
        double arg1;
        double arg2;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:initWithTargetAndOffset");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Follow:initWithTargetAndOffset");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Follow:initWithTargetAndOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_initWithTargetAndOffset'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTargetAndOffset(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 4) 
    {
        ax::Node* arg0;
        double arg1;
        double arg2;
        ax::Rect arg3;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:initWithTargetAndOffset");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Follow:initWithTargetAndOffset");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Follow:initWithTargetAndOffset");

        ok &= luaval_to_rect(tolua_S, 5, &arg3, "ax.Follow:initWithTargetAndOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_initWithTargetAndOffset'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTargetAndOffset(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Follow:initWithTargetAndOffset",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_initWithTargetAndOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Follow_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Node* arg0;
        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Follow::create(arg0);
        object_to_luaval<ax::Follow>(tolua_S, "ax.Follow",(ax::Follow*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::Node* arg0;
        ax::Rect arg1;
        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:create");
        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Follow:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Follow::create(arg0, arg1);
        object_to_luaval<ax::Follow>(tolua_S, "ax.Follow",(ax::Follow*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Follow:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Follow_createWithOffset(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Follow",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::Node* arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:createWithOffset");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Follow:createWithOffset");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Follow:createWithOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_createWithOffset'", nullptr);
            return 0;
        }
        auto&& ret = ax::Follow::createWithOffset(arg0, arg1, arg2);
        object_to_luaval<ax::Follow>(tolua_S, "ax.Follow",(ax::Follow*)ret);
        return 1;
    }
    if (argc == 4)
    {
        ax::Node* arg0;
        double arg1;
        double arg2;
        ax::Rect arg3;
        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.Follow:createWithOffset");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Follow:createWithOffset");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Follow:createWithOffset");
        ok &= luaval_to_rect(tolua_S, 5, &arg3, "ax.Follow:createWithOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_createWithOffset'", nullptr);
            return 0;
        }
        auto&& ret = ax::Follow::createWithOffset(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Follow>(tolua_S, "ax.Follow",(ax::Follow*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Follow:createWithOffset",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_createWithOffset'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Follow_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Follow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Follow_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Follow();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Follow");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Follow:Follow",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Follow_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Follow_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Follow)");
    return 0;
}

int lua_register_ax_base_Follow(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Follow");
    tolua_cclass(tolua_S,"Follow","ax.Follow","ax.Action",nullptr);

    tolua_beginmodule(tolua_S,"Follow");
        tolua_function(tolua_S,"new",lua_ax_base_Follow_constructor);
        tolua_function(tolua_S,"isBoundarySet",lua_ax_base_Follow_isBoundarySet);
        tolua_function(tolua_S,"setBoundarySet",lua_ax_base_Follow_setBoundarySet);
        tolua_function(tolua_S,"initWithTarget",lua_ax_base_Follow_initWithTarget);
        tolua_function(tolua_S,"initWithTargetAndOffset",lua_ax_base_Follow_initWithTargetAndOffset);
        tolua_function(tolua_S,"create", lua_ax_base_Follow_create);
        tolua_function(tolua_S,"createWithOffset", lua_ax_base_Follow_createWithOffset);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Follow).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Follow";
    g_typeCast[typeName] = "ax.Follow";
    return 1;
}

int lua_ax_base_Image_initWithImageFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_initWithImageFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Image:initWithImageFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_initWithImageFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithImageFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:initWithImageFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_initWithImageFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getFileType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getFileType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getFileType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getFileType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getFileType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getFileType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getPixelFormat(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getPixelFormat'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getPixelFormat'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getPixelFormat();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getPixelFormat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getPixelFormat'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getWidth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWidth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getWidth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getHeight'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHeight();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getHeight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getNumberOfMipmaps(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getNumberOfMipmaps'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getNumberOfMipmaps'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfMipmaps();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getNumberOfMipmaps",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getNumberOfMipmaps'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_hasPremultipliedAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_hasPremultipliedAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_hasPremultipliedAlpha'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasPremultipliedAlpha();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:hasPremultipliedAlpha",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_hasPremultipliedAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getFilePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getFilePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getFilePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFilePath();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getFilePath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getFilePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_getBitPerPixel(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_getBitPerPixel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_getBitPerPixel'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBitPerPixel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:getBitPerPixel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_getBitPerPixel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_hasAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_hasAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_hasAlpha'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasAlpha();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:hasAlpha",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_hasAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_isCompressed(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_isCompressed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_isCompressed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isCompressed();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:isCompressed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_isCompressed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_saveToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_saveToFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Image:saveToFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_saveToFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->saveToFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        std::string_view arg0;
        bool arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Image:saveToFile");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Image:saveToFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_saveToFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->saveToFile(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:saveToFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_saveToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_premultiplyAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_premultiplyAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_premultiplyAlpha'", nullptr);
            return 0;
        }
        cobj->premultiplyAlpha();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:premultiplyAlpha",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_premultiplyAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_reversePremultipliedAlpha(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Image*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Image_reversePremultipliedAlpha'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_reversePremultipliedAlpha'", nullptr);
            return 0;
        }
        cobj->reversePremultipliedAlpha();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:reversePremultipliedAlpha",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_reversePremultipliedAlpha'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Image_setPNGPremultipliedAlphaEnabled(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Image:setPNGPremultipliedAlphaEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_setPNGPremultipliedAlphaEnabled'", nullptr);
            return 0;
        }
        ax::Image::setPNGPremultipliedAlphaEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Image:setPNGPremultipliedAlphaEnabled",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_setPNGPremultipliedAlphaEnabled'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Image_setCompressedImagesHavePMA(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        unsigned int arg0;
        bool arg1;
        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Image:setCompressedImagesHavePMA");
        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Image:setCompressedImagesHavePMA");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_setCompressedImagesHavePMA'", nullptr);
            return 0;
        }
        ax::Image::setCompressedImagesHavePMA(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Image:setCompressedImagesHavePMA",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_setCompressedImagesHavePMA'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Image_isCompressedImageHavePMA(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Image",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        unsigned int arg0;
        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Image:isCompressedImageHavePMA");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_isCompressedImageHavePMA'", nullptr);
            return 0;
        }
        auto&& ret = ax::Image::isCompressedImageHavePMA(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Image:isCompressedImageHavePMA",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_isCompressedImageHavePMA'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Image_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Image* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Image_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Image();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Image");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Image:Image",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Image_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Image_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Image)");
    return 0;
}

int lua_register_ax_base_Image(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Image");
    tolua_cclass(tolua_S,"Image","ax.Image","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Image");
        tolua_function(tolua_S,"new",lua_ax_base_Image_constructor);
        tolua_function(tolua_S,"initWithImageFile",lua_ax_base_Image_initWithImageFile);
        tolua_function(tolua_S,"getFileType",lua_ax_base_Image_getFileType);
        tolua_function(tolua_S,"getPixelFormat",lua_ax_base_Image_getPixelFormat);
        tolua_function(tolua_S,"getWidth",lua_ax_base_Image_getWidth);
        tolua_function(tolua_S,"getHeight",lua_ax_base_Image_getHeight);
        tolua_function(tolua_S,"getNumberOfMipmaps",lua_ax_base_Image_getNumberOfMipmaps);
        tolua_function(tolua_S,"hasPremultipliedAlpha",lua_ax_base_Image_hasPremultipliedAlpha);
        tolua_function(tolua_S,"getFilePath",lua_ax_base_Image_getFilePath);
        tolua_function(tolua_S,"getBitPerPixel",lua_ax_base_Image_getBitPerPixel);
        tolua_function(tolua_S,"hasAlpha",lua_ax_base_Image_hasAlpha);
        tolua_function(tolua_S,"isCompressed",lua_ax_base_Image_isCompressed);
        tolua_function(tolua_S,"saveToFile",lua_ax_base_Image_saveToFile);
        tolua_function(tolua_S,"premultiplyAlpha",lua_ax_base_Image_premultiplyAlpha);
        tolua_function(tolua_S,"reversePremultipliedAlpha",lua_ax_base_Image_reversePremultipliedAlpha);
        tolua_function(tolua_S,"setPNGPremultipliedAlphaEnabled", lua_ax_base_Image_setPNGPremultipliedAlphaEnabled);
        tolua_function(tolua_S,"setCompressedImagesHavePMA", lua_ax_base_Image_setCompressedImagesHavePMA);
        tolua_function(tolua_S,"isCompressedImageHavePMA", lua_ax_base_Image_isCompressedImageHavePMA);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Image).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Image";
    g_typeCast[typeName] = "ax.Image";
    return 1;
}

int lua_ax_base_PolygonInfo_setQuad(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_setQuad'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::V3F_C4B_T2F_Quad* arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR V3F_C4B_T2F_Quad*
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_setQuad'", nullptr);
            return 0;
        }
        cobj->setQuad(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:setQuad",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_setQuad'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_setQuads(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_setQuads'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::V3F_C4B_T2F_Quad* arg0;
        int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR V3F_C4B_T2F_Quad*
		ok = false;

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.PolygonInfo:setQuads");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_setQuads'", nullptr);
            return 0;
        }
        cobj->setQuads(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:setQuads",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_setQuads'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_setTriangles(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_setTriangles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TrianglesCommand::Triangles arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR Triangles
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_setTriangles'", nullptr);
            return 0;
        }
        cobj->setTriangles(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:setTriangles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_setTriangles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_getVertCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_getVertCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_getVertCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVertCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:getVertCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_getVertCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_getTrianglesCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_getTrianglesCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_getTrianglesCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTrianglesCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:getTrianglesCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_getTrianglesCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_getArea(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_getArea'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_getArea'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getArea();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:getArea",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_getArea'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_getRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_getRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_getRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:getRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_getRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_setRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_setRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.PolygonInfo:setRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_setRect'", nullptr);
            return 0;
        }
        cobj->setRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:setRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_setRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_getFilename(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_getFilename'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_getFilename'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFilename();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:getFilename",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_getFilename'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_setFilename(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PolygonInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PolygonInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PolygonInfo_setFilename'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.PolygonInfo:setFilename");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_setFilename'", nullptr);
            return 0;
        }
        cobj->setFilename(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:setFilename",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_setFilename'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PolygonInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::PolygonInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PolygonInfo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::PolygonInfo();
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.PolygonInfo");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PolygonInfo:PolygonInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PolygonInfo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_PolygonInfo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (PolygonInfo)");
    return 0;
}

int lua_register_ax_base_PolygonInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.PolygonInfo");
    tolua_cclass(tolua_S,"PolygonInfo","ax.PolygonInfo","",nullptr);

    tolua_beginmodule(tolua_S,"PolygonInfo");
        tolua_function(tolua_S,"new",lua_ax_base_PolygonInfo_constructor);
        tolua_function(tolua_S,"setQuad",lua_ax_base_PolygonInfo_setQuad);
        tolua_function(tolua_S,"setQuads",lua_ax_base_PolygonInfo_setQuads);
        tolua_function(tolua_S,"setTriangles",lua_ax_base_PolygonInfo_setTriangles);
        tolua_function(tolua_S,"getVertCount",lua_ax_base_PolygonInfo_getVertCount);
        tolua_function(tolua_S,"getTrianglesCount",lua_ax_base_PolygonInfo_getTrianglesCount);
        tolua_function(tolua_S,"getArea",lua_ax_base_PolygonInfo_getArea);
        tolua_function(tolua_S,"getRect",lua_ax_base_PolygonInfo_getRect);
        tolua_function(tolua_S,"setRect",lua_ax_base_PolygonInfo_setRect);
        tolua_function(tolua_S,"getFilename",lua_ax_base_PolygonInfo_getFilename);
        tolua_function(tolua_S,"setFilename",lua_ax_base_PolygonInfo_setFilename);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::PolygonInfo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.PolygonInfo";
    g_typeCast[typeName] = "ax.PolygonInfo";
    return 1;
}

int lua_ax_base_AutoPolygon_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AutoPolygon* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AutoPolygon:AutoPolygon");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AutoPolygon_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AutoPolygon(arg0);
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.AutoPolygon");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AutoPolygon:AutoPolygon",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AutoPolygon_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AutoPolygon_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AutoPolygon)");
    return 0;
}

int lua_register_ax_base_AutoPolygon(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AutoPolygon");
    tolua_cclass(tolua_S,"AutoPolygon","ax.AutoPolygon","",nullptr);

    tolua_beginmodule(tolua_S,"AutoPolygon");
        tolua_function(tolua_S,"new",lua_ax_base_AutoPolygon_constructor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AutoPolygon).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AutoPolygon";
    g_typeCast[typeName] = "ax.AutoPolygon";
    return 1;
}

int lua_ax_base_SpriteFrame_getRectInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getRectInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getRectInPixels'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRectInPixels();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getRectInPixels",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getRectInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setRectInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setRectInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.SpriteFrame:setRectInPixels");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setRectInPixels'", nullptr);
            return 0;
        }
        cobj->setRectInPixels(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setRectInPixels",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setRectInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_isRotated(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_isRotated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_isRotated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isRotated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:isRotated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_isRotated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setRotated(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setRotated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.SpriteFrame:setRotated");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setRotated'", nullptr);
            return 0;
        }
        cobj->setRotated(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setRotated",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setRotated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.SpriteFrame:setRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setRect'", nullptr);
            return 0;
        }
        cobj->setRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getCenterRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getCenterRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getCenterRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCenterRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getCenterRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getCenterRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setCenterRectInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setCenterRectInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.SpriteFrame:setCenterRectInPixels");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setCenterRectInPixels'", nullptr);
            return 0;
        }
        cobj->setCenterRectInPixels(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setCenterRectInPixels",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setCenterRectInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_hasCenterRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_hasCenterRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_hasCenterRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasCenterRect();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:hasCenterRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_hasCenterRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getOffsetInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getOffsetInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getOffsetInPixels'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOffsetInPixels();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getOffsetInPixels",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getOffsetInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setOffsetInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setOffsetInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.SpriteFrame:setOffsetInPixels");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setOffsetInPixels'", nullptr);
            return 0;
        }
        cobj->setOffsetInPixels(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setOffsetInPixels",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setOffsetInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getOriginalSizeInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getOriginalSizeInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getOriginalSizeInPixels'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOriginalSizeInPixels();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getOriginalSizeInPixels",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getOriginalSizeInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setOriginalSizeInPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setOriginalSizeInPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.SpriteFrame:setOriginalSizeInPixels");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setOriginalSizeInPixels'", nullptr);
            return 0;
        }
        cobj->setOriginalSizeInPixels(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setOriginalSizeInPixels",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setOriginalSizeInPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getOriginalSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getOriginalSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getOriginalSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOriginalSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getOriginalSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getOriginalSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setOriginalSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setOriginalSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.SpriteFrame:setOriginalSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setOriginalSize'", nullptr);
            return 0;
        }
        cobj->setOriginalSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setOriginalSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setOriginalSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrame:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getOffset'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOffset();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getOffset",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.SpriteFrame:setOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setOffset'", nullptr);
            return 0;
        }
        cobj->setOffset(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setOffset",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_getAnchorPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_getAnchorPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_getAnchorPoint'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnchorPoint();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:getAnchorPoint",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_getAnchorPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_setAnchorPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_setAnchorPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.SpriteFrame:setAnchorPoint");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_setAnchorPoint'", nullptr);
            return 0;
        }
        cobj->setAnchorPoint(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:setAnchorPoint",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_setAnchorPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_hasAnchorPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_hasAnchorPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_hasAnchorPoint'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasAnchorPoint();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:hasAnchorPoint",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_hasAnchorPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_initWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_initWithTexture'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            ax::Vec2 arg4;
            ok &= luaval_to_vec2(tolua_S, 6, &arg4, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            bool ret = cobj->initWithTexture(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:initWithTexture");

            if (!ok) { break; }
            bool ret = cobj->initWithTexture(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.SpriteFrame:initWithTexture",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_initWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_initWithTextureFilename(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::SpriteFrame*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrame_initWithTextureFilename'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            ax::Vec2 arg4;
            ok &= luaval_to_vec2(tolua_S, 6, &arg4, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            bool ret = cobj->initWithTextureFilename(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:initWithTextureFilename");

            if (!ok) { break; }
            bool ret = cobj->initWithTextureFilename(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.SpriteFrame:initWithTextureFilename",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_initWithTextureFilename'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrame_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 5)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::Vec2 arg4;
            ok &= luaval_to_vec2(tolua_S, 6, &arg4, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::SpriteFrame* ret = ax::SpriteFrame::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:create");
            if (!ok) { break; }
            ax::SpriteFrame* ret = ax::SpriteFrame::create(arg0, arg1);
            object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.SpriteFrame:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpriteFrame_createWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 5)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::Vec2 arg4;
            ok &= luaval_to_vec2(tolua_S, 6, &arg4, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::SpriteFrame* ret = ax::SpriteFrame::createWithTexture(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrame:createWithTexture");
            if (!ok) { break; }
            ax::SpriteFrame* ret = ax::SpriteFrame::createWithTexture(arg0, arg1);
            object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.SpriteFrame:createWithTexture",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_createWithTexture'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpriteFrame_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrame_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SpriteFrame();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SpriteFrame");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrame:SpriteFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrame_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SpriteFrame_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SpriteFrame)");
    return 0;
}

int lua_register_ax_base_SpriteFrame(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SpriteFrame");
    tolua_cclass(tolua_S,"SpriteFrame","ax.SpriteFrame","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"SpriteFrame");
        tolua_function(tolua_S,"new",lua_ax_base_SpriteFrame_constructor);
        tolua_function(tolua_S,"getRectInPixels",lua_ax_base_SpriteFrame_getRectInPixels);
        tolua_function(tolua_S,"setRectInPixels",lua_ax_base_SpriteFrame_setRectInPixels);
        tolua_function(tolua_S,"isRotated",lua_ax_base_SpriteFrame_isRotated);
        tolua_function(tolua_S,"setRotated",lua_ax_base_SpriteFrame_setRotated);
        tolua_function(tolua_S,"getRect",lua_ax_base_SpriteFrame_getRect);
        tolua_function(tolua_S,"setRect",lua_ax_base_SpriteFrame_setRect);
        tolua_function(tolua_S,"getCenterRect",lua_ax_base_SpriteFrame_getCenterRect);
        tolua_function(tolua_S,"setCenterRectInPixels",lua_ax_base_SpriteFrame_setCenterRectInPixels);
        tolua_function(tolua_S,"hasCenterRect",lua_ax_base_SpriteFrame_hasCenterRect);
        tolua_function(tolua_S,"getOffsetInPixels",lua_ax_base_SpriteFrame_getOffsetInPixels);
        tolua_function(tolua_S,"setOffsetInPixels",lua_ax_base_SpriteFrame_setOffsetInPixels);
        tolua_function(tolua_S,"getOriginalSizeInPixels",lua_ax_base_SpriteFrame_getOriginalSizeInPixels);
        tolua_function(tolua_S,"setOriginalSizeInPixels",lua_ax_base_SpriteFrame_setOriginalSizeInPixels);
        tolua_function(tolua_S,"getOriginalSize",lua_ax_base_SpriteFrame_getOriginalSize);
        tolua_function(tolua_S,"setOriginalSize",lua_ax_base_SpriteFrame_setOriginalSize);
        tolua_function(tolua_S,"getTexture",lua_ax_base_SpriteFrame_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_SpriteFrame_setTexture);
        tolua_function(tolua_S,"getOffset",lua_ax_base_SpriteFrame_getOffset);
        tolua_function(tolua_S,"setOffset",lua_ax_base_SpriteFrame_setOffset);
        tolua_function(tolua_S,"getAnchorPoint",lua_ax_base_SpriteFrame_getAnchorPoint);
        tolua_function(tolua_S,"setAnchorPoint",lua_ax_base_SpriteFrame_setAnchorPoint);
        tolua_function(tolua_S,"hasAnchorPoint",lua_ax_base_SpriteFrame_hasAnchorPoint);
        tolua_function(tolua_S,"clone",lua_ax_base_SpriteFrame_clone);
        tolua_function(tolua_S,"initWithTexture",lua_ax_base_SpriteFrame_initWithTexture);
        tolua_function(tolua_S,"initWithTextureFilename",lua_ax_base_SpriteFrame_initWithTextureFilename);
        tolua_function(tolua_S,"create", lua_ax_base_SpriteFrame_create);
        tolua_function(tolua_S,"createWithTexture", lua_ax_base_SpriteFrame_createWithTexture);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SpriteFrame).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SpriteFrame";
    g_typeCast[typeName] = "ax.SpriteFrame";
    return 1;
}

int lua_ax_base_AnimationFrame_getSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_getSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_getSpriteFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpriteFrame();
        object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:getSpriteFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_getSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_setSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_setSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.AnimationFrame:setSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_setSpriteFrame'", nullptr);
            return 0;
        }
        cobj->setSpriteFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:setSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_setSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_getDelayUnits(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_getDelayUnits'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_getDelayUnits'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDelayUnits();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:getDelayUnits",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_getDelayUnits'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_setDelayUnits(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_setDelayUnits'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.AnimationFrame:setDelayUnits");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_setDelayUnits'", nullptr);
            return 0;
        }
        cobj->setDelayUnits(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:setDelayUnits",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_setDelayUnits'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_getUserInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_getUserInfo'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::ValueMap& ret = cobj->getUserInfo();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::ValueMap& ret = cobj->getUserInfo();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.AnimationFrame:getUserInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_getUserInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_setUserInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_setUserInfo'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.AnimationFrame:setUserInfo");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_setUserInfo'", nullptr);
            return 0;
        }
        cobj->setUserInfo(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:setUserInfo",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_setUserInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::AnimationFrame>(tolua_S, "ax.AnimationFrame",(ax::AnimationFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_initWithSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationFrame*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationFrame_initWithSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::SpriteFrame* arg0;
        double arg1;
        ax::ValueMap arg2;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.AnimationFrame:initWithSpriteFrame");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.AnimationFrame:initWithSpriteFrame");

        ok &= luaval_to_ccvaluemap(tolua_S, 4, &arg2, "ax.AnimationFrame:initWithSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_initWithSpriteFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrame(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:initWithSpriteFrame",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_initWithSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationFrame_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AnimationFrame",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::SpriteFrame* arg0;
        double arg1;
        ax::ValueMap arg2;
        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.AnimationFrame:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.AnimationFrame:create");
        ok &= luaval_to_ccvaluemap(tolua_S, 4, &arg2, "ax.AnimationFrame:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::AnimationFrame::create(arg0, arg1, arg2);
        object_to_luaval<ax::AnimationFrame>(tolua_S, "ax.AnimationFrame",(ax::AnimationFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AnimationFrame:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AnimationFrame_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationFrame* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationFrame_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AnimationFrame();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.AnimationFrame");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationFrame:AnimationFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationFrame_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AnimationFrame_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AnimationFrame)");
    return 0;
}

int lua_register_ax_base_AnimationFrame(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AnimationFrame");
    tolua_cclass(tolua_S,"AnimationFrame","ax.AnimationFrame","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"AnimationFrame");
        tolua_function(tolua_S,"new",lua_ax_base_AnimationFrame_constructor);
        tolua_function(tolua_S,"getSpriteFrame",lua_ax_base_AnimationFrame_getSpriteFrame);
        tolua_function(tolua_S,"setSpriteFrame",lua_ax_base_AnimationFrame_setSpriteFrame);
        tolua_function(tolua_S,"getDelayUnits",lua_ax_base_AnimationFrame_getDelayUnits);
        tolua_function(tolua_S,"setDelayUnits",lua_ax_base_AnimationFrame_setDelayUnits);
        tolua_function(tolua_S,"getUserInfo",lua_ax_base_AnimationFrame_getUserInfo);
        tolua_function(tolua_S,"setUserInfo",lua_ax_base_AnimationFrame_setUserInfo);
        tolua_function(tolua_S,"clone",lua_ax_base_AnimationFrame_clone);
        tolua_function(tolua_S,"initWithSpriteFrame",lua_ax_base_AnimationFrame_initWithSpriteFrame);
        tolua_function(tolua_S,"create", lua_ax_base_AnimationFrame_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AnimationFrame).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AnimationFrame";
    g_typeCast[typeName] = "ax.AnimationFrame";
    return 1;
}

int lua_ax_base_Animation_addSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_addSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.Animation:addSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_addSpriteFrame'", nullptr);
            return 0;
        }
        cobj->addSpriteFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:addSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_addSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_addSpriteFrameWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_addSpriteFrameWithFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Animation:addSpriteFrameWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_addSpriteFrameWithFile'", nullptr);
            return 0;
        }
        cobj->addSpriteFrameWithFile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:addSpriteFrameWithFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_addSpriteFrameWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_addSpriteFrameWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_addSpriteFrameWithTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Texture2D* arg0;
        ax::Rect arg1;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Animation:addSpriteFrameWithTexture");

        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Animation:addSpriteFrameWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_addSpriteFrameWithTexture'", nullptr);
            return 0;
        }
        cobj->addSpriteFrameWithTexture(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:addSpriteFrameWithTexture",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_addSpriteFrameWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getTotalDelayUnits(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getTotalDelayUnits'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getTotalDelayUnits'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTotalDelayUnits();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getTotalDelayUnits",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getTotalDelayUnits'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_setDelayPerUnit(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_setDelayPerUnit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Animation:setDelayPerUnit");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_setDelayPerUnit'", nullptr);
            return 0;
        }
        cobj->setDelayPerUnit(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:setDelayPerUnit",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_setDelayPerUnit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getDelayPerUnit(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getDelayPerUnit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getDelayPerUnit'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDelayPerUnit();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getDelayPerUnit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getDelayPerUnit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDuration();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getDuration",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFrames();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getFrames",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_setFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_setFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::AnimationFrame *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:setFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_setFrames'", nullptr);
            return 0;
        }
        cobj->setFrames(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:setFrames",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_setFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getRestoreOriginalFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getRestoreOriginalFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getRestoreOriginalFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRestoreOriginalFrame();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getRestoreOriginalFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getRestoreOriginalFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_setRestoreOriginalFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_setRestoreOriginalFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Animation:setRestoreOriginalFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_setRestoreOriginalFrame'", nullptr);
            return 0;
        }
        cobj->setRestoreOriginalFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:setRestoreOriginalFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_setRestoreOriginalFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_getLoops(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_getLoops'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_getLoops'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLoops();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:getLoops",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_getLoops'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_setLoops(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_setLoops'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Animation:setLoops");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_setLoops'", nullptr);
            return 0;
        }
        cobj->setLoops(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:setLoops",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_setLoops'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_initWithSpriteFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_initWithSpriteFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::SpriteFrame *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:initWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_initWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrames(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Vector<ax::SpriteFrame *> arg0;
        double arg1;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:initWithSpriteFrames");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:initWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_initWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrames(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 3) 
    {
        ax::Vector<ax::SpriteFrame *> arg0;
        double arg1;
        unsigned int arg2;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:initWithSpriteFrames");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:initWithSpriteFrames");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Animation:initWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_initWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrames(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:initWithSpriteFrames",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_initWithSpriteFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_initWithAnimationFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animation*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animation_initWithAnimationFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vector<ax::AnimationFrame *> arg0;
        double arg1;
        unsigned int arg2;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:initWithAnimationFrames");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:initWithAnimationFrames");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Animation:initWithAnimationFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_initWithAnimationFrames'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAnimationFrames(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:initWithAnimationFrames",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_initWithAnimationFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animation_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            ax::Vector<ax::AnimationFrame *> arg0;
            ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:create");
            if (!ok) { break; }
            ax::Animation* ret = ax::Animation::create(arg0, arg1);
            object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            ax::Vector<ax::AnimationFrame *> arg0;
            ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:create");
            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Animation:create");
            if (!ok) { break; }
            ax::Animation* ret = ax::Animation::create(arg0, arg1, arg2);
            object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::Animation* ret = ax::Animation::create();
            object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Animation:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Animation_createWithSpriteFrames(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Animation",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Vector<ax::SpriteFrame *> arg0;
        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:createWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_createWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = ax::Animation::createWithSpriteFrames(arg0);
        object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::Vector<ax::SpriteFrame *> arg0;
        double arg1;
        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:createWithSpriteFrames");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:createWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_createWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = ax::Animation::createWithSpriteFrames(arg0, arg1);
        object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
        return 1;
    }
    if (argc == 3)
    {
        ax::Vector<ax::SpriteFrame *> arg0;
        double arg1;
        unsigned int arg2;
        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Animation:createWithSpriteFrames");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Animation:createWithSpriteFrames");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Animation:createWithSpriteFrames");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_createWithSpriteFrames'", nullptr);
            return 0;
        }
        auto&& ret = ax::Animation::createWithSpriteFrames(arg0, arg1, arg2);
        object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Animation:createWithSpriteFrames",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_createWithSpriteFrames'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Animation_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animation* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animation_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Animation();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Animation");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animation:Animation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animation_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Animation_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Animation)");
    return 0;
}

int lua_register_ax_base_Animation(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Animation");
    tolua_cclass(tolua_S,"Animation","ax.Animation","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Animation");
        tolua_function(tolua_S,"new",lua_ax_base_Animation_constructor);
        tolua_function(tolua_S,"addSpriteFrame",lua_ax_base_Animation_addSpriteFrame);
        tolua_function(tolua_S,"addSpriteFrameWithFile",lua_ax_base_Animation_addSpriteFrameWithFile);
        tolua_function(tolua_S,"addSpriteFrameWithTexture",lua_ax_base_Animation_addSpriteFrameWithTexture);
        tolua_function(tolua_S,"getTotalDelayUnits",lua_ax_base_Animation_getTotalDelayUnits);
        tolua_function(tolua_S,"setDelayPerUnit",lua_ax_base_Animation_setDelayPerUnit);
        tolua_function(tolua_S,"getDelayPerUnit",lua_ax_base_Animation_getDelayPerUnit);
        tolua_function(tolua_S,"getDuration",lua_ax_base_Animation_getDuration);
        tolua_function(tolua_S,"getFrames",lua_ax_base_Animation_getFrames);
        tolua_function(tolua_S,"setFrames",lua_ax_base_Animation_setFrames);
        tolua_function(tolua_S,"getRestoreOriginalFrame",lua_ax_base_Animation_getRestoreOriginalFrame);
        tolua_function(tolua_S,"setRestoreOriginalFrame",lua_ax_base_Animation_setRestoreOriginalFrame);
        tolua_function(tolua_S,"getLoops",lua_ax_base_Animation_getLoops);
        tolua_function(tolua_S,"setLoops",lua_ax_base_Animation_setLoops);
        tolua_function(tolua_S,"clone",lua_ax_base_Animation_clone);
        tolua_function(tolua_S,"init",lua_ax_base_Animation_init);
        tolua_function(tolua_S,"initWithSpriteFrames",lua_ax_base_Animation_initWithSpriteFrames);
        tolua_function(tolua_S,"initWithAnimationFrames",lua_ax_base_Animation_initWithAnimationFrames);
        tolua_function(tolua_S,"create", lua_ax_base_Animation_create);
        tolua_function(tolua_S,"createWithSpriteFrames", lua_ax_base_Animation_createWithSpriteFrames);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Animation).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Animation";
    g_typeCast[typeName] = "ax.Animation";
    return 1;
}

int lua_ax_base_ActionInterval_getElapsed(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionInterval* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionInterval",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionInterval*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionInterval_getElapsed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionInterval_getElapsed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getElapsed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionInterval:getElapsed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionInterval_getElapsed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionInterval_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionInterval* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionInterval",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionInterval*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionInterval_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionInterval:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionInterval_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionInterval:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionInterval_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionInterval_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionInterval* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionInterval",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionInterval*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionInterval_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionInterval_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionInterval:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionInterval_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionInterval_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionInterval* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionInterval",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionInterval*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionInterval_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionInterval:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionInterval_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionInterval:initWithDuration",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionInterval_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_ActionInterval_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionInterval)");
    return 0;
}

int lua_register_ax_base_ActionInterval(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionInterval");
    tolua_cclass(tolua_S,"ActionInterval","ax.ActionInterval","ax.FiniteTimeAction",nullptr);

    tolua_beginmodule(tolua_S,"ActionInterval");
        tolua_function(tolua_S,"getElapsed",lua_ax_base_ActionInterval_getElapsed);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_ActionInterval_setAmplitudeRate);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_ActionInterval_getAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ActionInterval_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionInterval).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionInterval";
    g_typeCast[typeName] = "ax.ActionInterval";
    return 1;
}

int lua_ax_base_Sequence_initWithTwoActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sequence* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sequence",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sequence*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sequence_initWithTwoActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::FiniteTimeAction* arg0;
        ax::FiniteTimeAction* arg1;

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 2, "ax.FiniteTimeAction",&arg0, "ax.Sequence:initWithTwoActions");

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 3, "ax.FiniteTimeAction",&arg1, "ax.Sequence:initWithTwoActions");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sequence_initWithTwoActions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTwoActions(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sequence:initWithTwoActions",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sequence_initWithTwoActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sequence_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sequence* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sequence",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sequence*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sequence_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::FiniteTimeAction *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Sequence:init");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sequence_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sequence:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sequence_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sequence_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sequence* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sequence_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Sequence();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Sequence");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sequence:Sequence",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sequence_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Sequence_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Sequence)");
    return 0;
}

int lua_register_ax_base_Sequence(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Sequence");
    tolua_cclass(tolua_S,"Sequence","ax.Sequence","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"Sequence");
        tolua_function(tolua_S,"new",lua_ax_base_Sequence_constructor);
        tolua_function(tolua_S,"initWithTwoActions",lua_ax_base_Sequence_initWithTwoActions);
        tolua_function(tolua_S,"init",lua_ax_base_Sequence_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Sequence).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Sequence";
    g_typeCast[typeName] = "ax.Sequence";
    return 1;
}

int lua_ax_base_Repeat_setInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Repeat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Repeat",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Repeat*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Repeat_setInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::FiniteTimeAction* arg0;

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 2, "ax.FiniteTimeAction",&arg0, "ax.Repeat:setInnerAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Repeat_setInnerAction'", nullptr);
            return 0;
        }
        cobj->setInnerAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Repeat:setInnerAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Repeat_setInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Repeat_getInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Repeat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Repeat",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Repeat*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Repeat_getInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Repeat_getInnerAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInnerAction();
        object_to_luaval<ax::FiniteTimeAction>(tolua_S, "ax.FiniteTimeAction",(ax::FiniteTimeAction*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Repeat:getInnerAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Repeat_getInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Repeat_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Repeat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Repeat",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Repeat*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Repeat_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::FiniteTimeAction* arg0;
        unsigned int arg1;

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 2, "ax.FiniteTimeAction",&arg0, "ax.Repeat:initWithAction");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Repeat:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Repeat_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Repeat:initWithAction",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Repeat_initWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Repeat_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Repeat",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::FiniteTimeAction* arg0;
        unsigned int arg1;
        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 2, "ax.FiniteTimeAction",&arg0, "ax.Repeat:create");
        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Repeat:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Repeat_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Repeat::create(arg0, arg1);
        object_to_luaval<ax::Repeat>(tolua_S, "ax.Repeat",(ax::Repeat*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Repeat:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Repeat_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Repeat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Repeat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Repeat_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Repeat();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Repeat");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Repeat:Repeat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Repeat_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Repeat_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Repeat)");
    return 0;
}

int lua_register_ax_base_Repeat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Repeat");
    tolua_cclass(tolua_S,"Repeat","ax.Repeat","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"Repeat");
        tolua_function(tolua_S,"new",lua_ax_base_Repeat_constructor);
        tolua_function(tolua_S,"setInnerAction",lua_ax_base_Repeat_setInnerAction);
        tolua_function(tolua_S,"getInnerAction",lua_ax_base_Repeat_getInnerAction);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_Repeat_initWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_Repeat_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Repeat).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Repeat";
    g_typeCast[typeName] = "ax.Repeat";
    return 1;
}

int lua_ax_base_RepeatForever_setInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::RepeatForever* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RepeatForever",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RepeatForever*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RepeatForever_setInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.RepeatForever:setInnerAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RepeatForever_setInnerAction'", nullptr);
            return 0;
        }
        cobj->setInnerAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RepeatForever:setInnerAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RepeatForever_setInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RepeatForever_getInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::RepeatForever* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RepeatForever",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RepeatForever*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RepeatForever_getInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RepeatForever_getInnerAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInnerAction();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RepeatForever:getInnerAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RepeatForever_getInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RepeatForever_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::RepeatForever* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RepeatForever",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RepeatForever*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RepeatForever_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.RepeatForever:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RepeatForever_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RepeatForever:initWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RepeatForever_initWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RepeatForever_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.RepeatForever",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.RepeatForever:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RepeatForever_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::RepeatForever::create(arg0);
        object_to_luaval<ax::RepeatForever>(tolua_S, "ax.RepeatForever",(ax::RepeatForever*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.RepeatForever:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RepeatForever_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_RepeatForever_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RepeatForever* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RepeatForever_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::RepeatForever();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.RepeatForever");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RepeatForever:RepeatForever",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RepeatForever_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_RepeatForever_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RepeatForever)");
    return 0;
}

int lua_register_ax_base_RepeatForever(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RepeatForever");
    tolua_cclass(tolua_S,"RepeatForever","ax.RepeatForever","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"RepeatForever");
        tolua_function(tolua_S,"new",lua_ax_base_RepeatForever_constructor);
        tolua_function(tolua_S,"setInnerAction",lua_ax_base_RepeatForever_setInnerAction);
        tolua_function(tolua_S,"getInnerAction",lua_ax_base_RepeatForever_getInnerAction);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_RepeatForever_initWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_RepeatForever_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RepeatForever).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RepeatForever";
    g_typeCast[typeName] = "ax.RepeatForever";
    return 1;
}

int lua_ax_base_Spawn_initWithTwoActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Spawn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Spawn",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Spawn*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Spawn_initWithTwoActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::FiniteTimeAction* arg0;
        ax::FiniteTimeAction* arg1;

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 2, "ax.FiniteTimeAction",&arg0, "ax.Spawn:initWithTwoActions");

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 3, "ax.FiniteTimeAction",&arg1, "ax.Spawn:initWithTwoActions");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Spawn_initWithTwoActions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTwoActions(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Spawn:initWithTwoActions",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Spawn_initWithTwoActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Spawn_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Spawn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Spawn",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Spawn*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Spawn_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::FiniteTimeAction *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Spawn:init");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Spawn_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Spawn:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Spawn_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Spawn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Spawn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Spawn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Spawn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Spawn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Spawn:Spawn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Spawn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Spawn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Spawn)");
    return 0;
}

int lua_register_ax_base_Spawn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Spawn");
    tolua_cclass(tolua_S,"Spawn","ax.Spawn","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"Spawn");
        tolua_function(tolua_S,"new",lua_ax_base_Spawn_constructor);
        tolua_function(tolua_S,"initWithTwoActions",lua_ax_base_Spawn_initWithTwoActions);
        tolua_function(tolua_S,"init",lua_ax_base_Spawn_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Spawn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Spawn";
    g_typeCast[typeName] = "ax.Spawn";
    return 1;
}

int lua_ax_base_RotateTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::RotateTo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RotateTo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RotateTo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RotateTo_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateTo:initWithDuration");

            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.RotateTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateTo:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateTo:initWithDuration");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RotateTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RotateTo:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RotateTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.RotateTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateTo:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateTo:create");
            if (!ok) { break; }
            ax::RotateTo* ret = ax::RotateTo::create(arg0, arg1);
            object_to_luaval<ax::RotateTo>(tolua_S, "ax.RotateTo",(ax::RotateTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateTo:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateTo:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RotateTo:create");
            if (!ok) { break; }
            ax::RotateTo* ret = ax::RotateTo::create(arg0, arg1, arg2);
            object_to_luaval<ax::RotateTo>(tolua_S, "ax.RotateTo",(ax::RotateTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateTo:create");
            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.RotateTo:create");
            if (!ok) { break; }
            ax::RotateTo* ret = ax::RotateTo::create(arg0, arg1);
            object_to_luaval<ax::RotateTo>(tolua_S, "ax.RotateTo",(ax::RotateTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.RotateTo:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_RotateTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RotateTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RotateTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::RotateTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.RotateTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RotateTo:RotateTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_RotateTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RotateTo)");
    return 0;
}

int lua_register_ax_base_RotateTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RotateTo");
    tolua_cclass(tolua_S,"RotateTo","ax.RotateTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"RotateTo");
        tolua_function(tolua_S,"new",lua_ax_base_RotateTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_RotateTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_RotateTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RotateTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RotateTo";
    g_typeCast[typeName] = "ax.RotateTo";
    return 1;
}

int lua_ax_base_RotateBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::RotateBy* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RotateBy",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RotateBy*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RotateBy_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.RotateBy:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RotateBy:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RotateBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.RotateBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateBy:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RotateBy:create");
            if (!ok) { break; }
            ax::RotateBy* ret = ax::RotateBy::create(arg0, arg1, arg2);
            object_to_luaval<ax::RotateBy>(tolua_S, "ax.RotateBy",(ax::RotateBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RotateBy:create");
            if (!ok) { break; }
            ax::RotateBy* ret = ax::RotateBy::create(arg0, arg1);
            object_to_luaval<ax::RotateBy>(tolua_S, "ax.RotateBy",(ax::RotateBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RotateBy:create");
            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.RotateBy:create");
            if (!ok) { break; }
            ax::RotateBy* ret = ax::RotateBy::create(arg0, arg1);
            object_to_luaval<ax::RotateBy>(tolua_S, "ax.RotateBy",(ax::RotateBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.RotateBy:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_RotateBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RotateBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RotateBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::RotateBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.RotateBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RotateBy:RotateBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RotateBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_RotateBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RotateBy)");
    return 0;
}

int lua_register_ax_base_RotateBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RotateBy");
    tolua_cclass(tolua_S,"RotateBy","ax.RotateBy","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"RotateBy");
        tolua_function(tolua_S,"new",lua_ax_base_RotateBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_RotateBy_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_RotateBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RotateBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RotateBy";
    g_typeCast[typeName] = "ax.RotateBy";
    return 1;
}

int lua_ax_base_MoveBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::MoveBy* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MoveBy",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::MoveBy*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MoveBy_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveBy:initWithDuration");

            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.MoveBy:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveBy:initWithDuration");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.MoveBy:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.MoveBy:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MoveBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MoveBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveBy:create");
            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.MoveBy:create");
            if (!ok) { break; }
            ax::MoveBy* ret = ax::MoveBy::create(arg0, arg1);
            object_to_luaval<ax::MoveBy>(tolua_S, "ax.MoveBy",(ax::MoveBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveBy:create");
            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.MoveBy:create");
            if (!ok) { break; }
            ax::MoveBy* ret = ax::MoveBy::create(arg0, arg1);
            object_to_luaval<ax::MoveBy>(tolua_S, "ax.MoveBy",(ax::MoveBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.MoveBy:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MoveBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MoveBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MoveBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MoveBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MoveBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MoveBy:MoveBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MoveBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MoveBy)");
    return 0;
}

int lua_register_ax_base_MoveBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MoveBy");
    tolua_cclass(tolua_S,"MoveBy","ax.MoveBy","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"MoveBy");
        tolua_function(tolua_S,"new",lua_ax_base_MoveBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_MoveBy_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_MoveBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MoveBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MoveBy";
    g_typeCast[typeName] = "ax.MoveBy";
    return 1;
}

int lua_ax_base_MoveTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::MoveTo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MoveTo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::MoveTo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MoveTo_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveTo:initWithDuration");

            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.MoveTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveTo:initWithDuration");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.MoveTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.MoveTo:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MoveTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MoveTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveTo:create");
            if (!ok) { break; }
            ax::Vec3 arg1;
            ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.MoveTo:create");
            if (!ok) { break; }
            ax::MoveTo* ret = ax::MoveTo::create(arg0, arg1);
            object_to_luaval<ax::MoveTo>(tolua_S, "ax.MoveTo",(ax::MoveTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MoveTo:create");
            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.MoveTo:create");
            if (!ok) { break; }
            ax::MoveTo* ret = ax::MoveTo::create(arg0, arg1);
            object_to_luaval<ax::MoveTo>(tolua_S, "ax.MoveTo",(ax::MoveTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.MoveTo:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MoveTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MoveTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MoveTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MoveTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MoveTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MoveTo:MoveTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MoveTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MoveTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MoveTo)");
    return 0;
}

int lua_register_ax_base_MoveTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MoveTo");
    tolua_cclass(tolua_S,"MoveTo","ax.MoveTo","ax.MoveBy",nullptr);

    tolua_beginmodule(tolua_S,"MoveTo");
        tolua_function(tolua_S,"new",lua_ax_base_MoveTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_MoveTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_MoveTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MoveTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MoveTo";
    g_typeCast[typeName] = "ax.MoveTo";
    return 1;
}

int lua_ax_base_SkewTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::SkewTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SkewTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SkewTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SkewTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        double arg1;
        double arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SkewTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.SkewTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.SkewTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SkewTo:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SkewTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SkewTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SkewTo:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.SkewTo:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.SkewTo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewTo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SkewTo::create(arg0, arg1, arg2);
        object_to_luaval<ax::SkewTo>(tolua_S, "ax.SkewTo",(ax::SkewTo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SkewTo:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SkewTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SkewTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SkewTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SkewTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SkewTo:SkewTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SkewTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SkewTo)");
    return 0;
}

int lua_register_ax_base_SkewTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SkewTo");
    tolua_cclass(tolua_S,"SkewTo","ax.SkewTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"SkewTo");
        tolua_function(tolua_S,"new",lua_ax_base_SkewTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_SkewTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_SkewTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SkewTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SkewTo";
    g_typeCast[typeName] = "ax.SkewTo";
    return 1;
}

int lua_ax_base_SkewBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::SkewBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SkewBy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SkewBy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SkewBy_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        double arg1;
        double arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SkewBy:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.SkewBy:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.SkewBy:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewBy_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SkewBy:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SkewBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SkewBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SkewBy:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.SkewBy:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.SkewBy:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewBy_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SkewBy::create(arg0, arg1, arg2);
        object_to_luaval<ax::SkewBy>(tolua_S, "ax.SkewBy",(ax::SkewBy*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SkewBy:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SkewBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SkewBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SkewBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SkewBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SkewBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SkewBy:SkewBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SkewBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SkewBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SkewBy)");
    return 0;
}

int lua_register_ax_base_SkewBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SkewBy");
    tolua_cclass(tolua_S,"SkewBy","ax.SkewBy","ax.SkewTo",nullptr);

    tolua_beginmodule(tolua_S,"SkewBy");
        tolua_function(tolua_S,"new",lua_ax_base_SkewBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_SkewBy_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_SkewBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SkewBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SkewBy";
    g_typeCast[typeName] = "ax.SkewBy";
    return 1;
}

int lua_ax_base_JumpBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpBy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpBy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpBy_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        double arg2;
        int arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpBy:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpBy:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.JumpBy:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.JumpBy:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpBy_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpBy:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.JumpBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        double arg2;
        int arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpBy:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpBy:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.JumpBy:create");
        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.JumpBy:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpBy_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::JumpBy::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::JumpBy>(tolua_S, "ax.JumpBy",(ax::JumpBy*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.JumpBy:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_JumpBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::JumpBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.JumpBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpBy:JumpBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_JumpBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (JumpBy)");
    return 0;
}

int lua_register_ax_base_JumpBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.JumpBy");
    tolua_cclass(tolua_S,"JumpBy","ax.JumpBy","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"JumpBy");
        tolua_function(tolua_S,"new",lua_ax_base_JumpBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_JumpBy_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_JumpBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::JumpBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.JumpBy";
    g_typeCast[typeName] = "ax.JumpBy";
    return 1;
}

int lua_ax_base_JumpTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        double arg2;
        int arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTo:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.JumpTo:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.JumpTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTo:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.JumpTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        double arg2;
        int arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTo:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpTo:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.JumpTo:create");
        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.JumpTo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::JumpTo::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::JumpTo>(tolua_S, "ax.JumpTo",(ax::JumpTo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.JumpTo:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_JumpTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::JumpTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.JumpTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTo:JumpTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_JumpTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (JumpTo)");
    return 0;
}

int lua_register_ax_base_JumpTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.JumpTo");
    tolua_cclass(tolua_S,"JumpTo","ax.JumpTo","ax.JumpBy",nullptr);

    tolua_beginmodule(tolua_S,"JumpTo");
        tolua_function(tolua_S,"new",lua_ax_base_JumpTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_JumpTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_JumpTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::JumpTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.JumpTo";
    g_typeCast[typeName] = "ax.JumpTo";
    return 1;
}

int lua_ax_base_BezierBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::BezierBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BezierBy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BezierBy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BezierBy_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::_ccBezierConfig arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.BezierBy:initWithDuration");

        #pragma warning NO CONVERSION TO NATIVE FOR _ccBezierConfig
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BezierBy_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BezierBy:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BezierBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BezierBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::BezierBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BezierBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::BezierBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.BezierBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BezierBy:BezierBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BezierBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_BezierBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (BezierBy)");
    return 0;
}

int lua_register_ax_base_BezierBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.BezierBy");
    tolua_cclass(tolua_S,"BezierBy","ax.BezierBy","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"BezierBy");
        tolua_function(tolua_S,"new",lua_ax_base_BezierBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_BezierBy_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::BezierBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.BezierBy";
    g_typeCast[typeName] = "ax.BezierBy";
    return 1;
}

int lua_ax_base_BezierTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::BezierTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BezierTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BezierTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BezierTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::_ccBezierConfig arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.BezierTo:initWithDuration");

        #pragma warning NO CONVERSION TO NATIVE FOR _ccBezierConfig
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BezierTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BezierTo:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BezierTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BezierTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::BezierTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BezierTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::BezierTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.BezierTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BezierTo:BezierTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BezierTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_BezierTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (BezierTo)");
    return 0;
}

int lua_register_ax_base_BezierTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.BezierTo");
    tolua_cclass(tolua_S,"BezierTo","ax.BezierTo","ax.BezierBy",nullptr);

    tolua_beginmodule(tolua_S,"BezierTo");
        tolua_function(tolua_S,"new",lua_ax_base_BezierTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_BezierTo_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::BezierTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.BezierTo";
    g_typeCast[typeName] = "ax.BezierTo";
    return 1;
}

int lua_ax_base_ScaleTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ScaleTo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ScaleTo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ScaleTo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ScaleTo_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ScaleTo:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ScaleTo:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ScaleTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ScaleTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ScaleTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleTo:create");
            if (!ok) { break; }
            ax::ScaleTo* ret = ax::ScaleTo::create(arg0, arg1, arg2);
            object_to_luaval<ax::ScaleTo>(tolua_S, "ax.ScaleTo",(ax::ScaleTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:create");
            if (!ok) { break; }
            ax::ScaleTo* ret = ax::ScaleTo::create(arg0, arg1);
            object_to_luaval<ax::ScaleTo>(tolua_S, "ax.ScaleTo",(ax::ScaleTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleTo:create");
            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ScaleTo:create");
            if (!ok) { break; }
            ax::ScaleTo* ret = ax::ScaleTo::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::ScaleTo>(tolua_S, "ax.ScaleTo",(ax::ScaleTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.ScaleTo:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ScaleTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ScaleTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ScaleTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ScaleTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ScaleTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ScaleTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ScaleTo:ScaleTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ScaleTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ScaleTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ScaleTo)");
    return 0;
}

int lua_register_ax_base_ScaleTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ScaleTo");
    tolua_cclass(tolua_S,"ScaleTo","ax.ScaleTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ScaleTo");
        tolua_function(tolua_S,"new",lua_ax_base_ScaleTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ScaleTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ScaleTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ScaleTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ScaleTo";
    g_typeCast[typeName] = "ax.ScaleTo";
    return 1;
}

int lua_ax_base_ScaleBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ScaleBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleBy:create");
            if (!ok) { break; }
            ax::ScaleBy* ret = ax::ScaleBy::create(arg0, arg1, arg2);
            object_to_luaval<ax::ScaleBy>(tolua_S, "ax.ScaleBy",(ax::ScaleBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleBy:create");
            if (!ok) { break; }
            ax::ScaleBy* ret = ax::ScaleBy::create(arg0, arg1);
            object_to_luaval<ax::ScaleBy>(tolua_S, "ax.ScaleBy",(ax::ScaleBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ScaleBy:create");
            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ScaleBy:create");
            if (!ok) { break; }
            ax::ScaleBy* ret = ax::ScaleBy::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::ScaleBy>(tolua_S, "ax.ScaleBy",(ax::ScaleBy*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.ScaleBy:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ScaleBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ScaleBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ScaleBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ScaleBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ScaleBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ScaleBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ScaleBy:ScaleBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ScaleBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ScaleBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ScaleBy)");
    return 0;
}

int lua_register_ax_base_ScaleBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ScaleBy");
    tolua_cclass(tolua_S,"ScaleBy","ax.ScaleBy","ax.ScaleTo",nullptr);

    tolua_beginmodule(tolua_S,"ScaleBy");
        tolua_function(tolua_S,"new",lua_ax_base_ScaleBy_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_ScaleBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ScaleBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ScaleBy";
    g_typeCast[typeName] = "ax.ScaleBy";
    return 1;
}

int lua_ax_base_Blink_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Blink* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Blink",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Blink*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Blink_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        int arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Blink:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Blink:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Blink_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Blink:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Blink_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Blink_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Blink",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        int arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Blink:create");
        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Blink:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Blink_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Blink::create(arg0, arg1);
        object_to_luaval<ax::Blink>(tolua_S, "ax.Blink",(ax::Blink*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Blink:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Blink_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Blink_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Blink* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Blink_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Blink();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Blink");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Blink:Blink",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Blink_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Blink_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Blink)");
    return 0;
}

int lua_register_ax_base_Blink(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Blink");
    tolua_cclass(tolua_S,"Blink","ax.Blink","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"Blink");
        tolua_function(tolua_S,"new",lua_ax_base_Blink_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Blink_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Blink_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Blink).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Blink";
    g_typeCast[typeName] = "ax.Blink";
    return 1;
}

int lua_ax_base_FadeTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        uint16_t arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeTo:initWithDuration");

        ok &= luaval_to_uint16(tolua_S, 3,&arg1, "ax.FadeTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeTo:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        uint16_t arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeTo:create");
        ok &= luaval_to_uint16(tolua_S, 3,&arg1, "ax.FadeTo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeTo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeTo::create(arg0, arg1);
        object_to_luaval<ax::FadeTo>(tolua_S, "ax.FadeTo",(ax::FadeTo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeTo:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeTo:FadeTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeTo)");
    return 0;
}

int lua_register_ax_base_FadeTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeTo");
    tolua_cclass(tolua_S,"FadeTo","ax.FadeTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"FadeTo");
        tolua_function(tolua_S,"new",lua_ax_base_FadeTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_FadeTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_FadeTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeTo";
    g_typeCast[typeName] = "ax.FadeTo";
    return 1;
}

int lua_ax_base_FadeIn_setReverseAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeIn",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeIn*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeIn_setReverseAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::FadeTo* arg0;

        ok &= luaval_to_object<ax::FadeTo>(tolua_S, 2, "ax.FadeTo",&arg0, "ax.FadeIn:setReverseAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeIn_setReverseAction'", nullptr);
            return 0;
        }
        cobj->setReverseAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeIn:setReverseAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeIn_setReverseAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeIn::create(arg0);
        object_to_luaval<ax::FadeIn>(tolua_S, "ax.FadeIn",(ax::FadeIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeIn:FadeIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeIn)");
    return 0;
}

int lua_register_ax_base_FadeIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeIn");
    tolua_cclass(tolua_S,"FadeIn","ax.FadeIn","ax.FadeTo",nullptr);

    tolua_beginmodule(tolua_S,"FadeIn");
        tolua_function(tolua_S,"new",lua_ax_base_FadeIn_constructor);
        tolua_function(tolua_S,"setReverseAction",lua_ax_base_FadeIn_setReverseAction);
        tolua_function(tolua_S,"create", lua_ax_base_FadeIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeIn";
    g_typeCast[typeName] = "ax.FadeIn";
    return 1;
}

int lua_ax_base_FadeOut_setReverseAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeOut",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeOut*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeOut_setReverseAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::FadeTo* arg0;

        ok &= luaval_to_object<ax::FadeTo>(tolua_S, 2, "ax.FadeTo",&arg0, "ax.FadeOut:setReverseAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOut_setReverseAction'", nullptr);
            return 0;
        }
        cobj->setReverseAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOut:setReverseAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOut_setReverseAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeOut::create(arg0);
        object_to_luaval<ax::FadeOut>(tolua_S, "ax.FadeOut",(ax::FadeOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOut:FadeOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeOut)");
    return 0;
}

int lua_register_ax_base_FadeOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeOut");
    tolua_cclass(tolua_S,"FadeOut","ax.FadeOut","ax.FadeTo",nullptr);

    tolua_beginmodule(tolua_S,"FadeOut");
        tolua_function(tolua_S,"new",lua_ax_base_FadeOut_constructor);
        tolua_function(tolua_S,"setReverseAction",lua_ax_base_FadeOut_setReverseAction);
        tolua_function(tolua_S,"create", lua_ax_base_FadeOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeOut";
    g_typeCast[typeName] = "ax.FadeOut";
    return 1;
}

int lua_ax_base_TintTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TintTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TintTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TintTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TintTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        uint16_t arg1;
        uint16_t arg2;
        uint16_t arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TintTo:initWithDuration");

        ok &= luaval_to_uint16(tolua_S, 3,&arg1, "ax.TintTo:initWithDuration");

        ok &= luaval_to_uint16(tolua_S, 4,&arg2, "ax.TintTo:initWithDuration");

        ok &= luaval_to_uint16(tolua_S, 5,&arg3, "ax.TintTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TintTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TintTo:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TintTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TintTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TintTo:create");
            if (!ok) { break; }
            ax::Color3B arg1;
            ok &= luaval_to_color3b(tolua_S, 3, &arg1, "ax.TintTo:create");
            if (!ok) { break; }
            ax::TintTo* ret = ax::TintTo::create(arg0, arg1);
            object_to_luaval<ax::TintTo>(tolua_S, "ax.TintTo",(ax::TintTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TintTo:create");
            if (!ok) { break; }
            uint16_t arg1;
            ok &= luaval_to_uint16(tolua_S, 3,&arg1, "ax.TintTo:create");
            if (!ok) { break; }
            uint16_t arg2;
            ok &= luaval_to_uint16(tolua_S, 4,&arg2, "ax.TintTo:create");
            if (!ok) { break; }
            uint16_t arg3;
            ok &= luaval_to_uint16(tolua_S, 5,&arg3, "ax.TintTo:create");
            if (!ok) { break; }
            ax::TintTo* ret = ax::TintTo::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::TintTo>(tolua_S, "ax.TintTo",(ax::TintTo*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TintTo:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TintTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TintTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TintTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TintTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TintTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TintTo:TintTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TintTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TintTo)");
    return 0;
}

int lua_register_ax_base_TintTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TintTo");
    tolua_cclass(tolua_S,"TintTo","ax.TintTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"TintTo");
        tolua_function(tolua_S,"new",lua_ax_base_TintTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TintTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TintTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TintTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TintTo";
    g_typeCast[typeName] = "ax.TintTo";
    return 1;
}

int lua_ax_base_TintBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TintBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TintBy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TintBy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TintBy_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        int32_t arg1;
        int32_t arg2;
        int32_t arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TintBy:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 3,&arg1, "ax.TintBy:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 4,&arg2, "ax.TintBy:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 5,&arg3, "ax.TintBy:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TintBy_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TintBy:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TintBy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TintBy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        int32_t arg1;
        int32_t arg2;
        int32_t arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TintBy:create");
        ok &= luaval_to_int32(tolua_S, 3,&arg1, "ax.TintBy:create");
        ok &= luaval_to_int32(tolua_S, 4,&arg2, "ax.TintBy:create");
        ok &= luaval_to_int32(tolua_S, 5,&arg3, "ax.TintBy:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TintBy_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TintBy::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::TintBy>(tolua_S, "ax.TintBy",(ax::TintBy*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TintBy:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintBy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TintBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TintBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TintBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TintBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TintBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TintBy:TintBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TintBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TintBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TintBy)");
    return 0;
}

int lua_register_ax_base_TintBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TintBy");
    tolua_cclass(tolua_S,"TintBy","ax.TintBy","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"TintBy");
        tolua_function(tolua_S,"new",lua_ax_base_TintBy_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TintBy_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TintBy_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TintBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TintBy";
    g_typeCast[typeName] = "ax.TintBy";
    return 1;
}

int lua_ax_base_DelayTime_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.DelayTime",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.DelayTime:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DelayTime_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::DelayTime::create(arg0);
        object_to_luaval<ax::DelayTime>(tolua_S, "ax.DelayTime",(ax::DelayTime*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.DelayTime:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DelayTime_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_DelayTime_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::DelayTime* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DelayTime_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::DelayTime();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.DelayTime");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DelayTime:DelayTime",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DelayTime_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_DelayTime_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (DelayTime)");
    return 0;
}

int lua_register_ax_base_DelayTime(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.DelayTime");
    tolua_cclass(tolua_S,"DelayTime","ax.DelayTime","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"DelayTime");
        tolua_function(tolua_S,"new",lua_ax_base_DelayTime_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_DelayTime_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::DelayTime).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.DelayTime";
    g_typeCast[typeName] = "ax.DelayTime";
    return 1;
}

int lua_ax_base_Animate_setAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animate* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animate",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animate*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animate_setAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Animation* arg0;

        ok &= luaval_to_object<ax::Animation>(tolua_S, 2, "ax.Animation",&arg0, "ax.Animate:setAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animate_setAnimation'", nullptr);
            return 0;
        }
        cobj->setAnimation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animate:setAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_setAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animate_getAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animate* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animate",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Animate*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animate_getAnimation'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::Animation* ret = cobj->getAnimation();
            object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Animation* ret = cobj->getAnimation();
            object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Animate:getAnimation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_getAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animate_getCurrentFrameIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animate* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animate",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animate*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animate_getCurrentFrameIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animate_getCurrentFrameIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCurrentFrameIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animate:getCurrentFrameIndex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_getCurrentFrameIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animate_initWithAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animate* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Animate",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Animate*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Animate_initWithAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Animation* arg0;

        ok &= luaval_to_object<ax::Animation>(tolua_S, 2, "ax.Animation",&arg0, "ax.Animate:initWithAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animate_initWithAnimation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAnimation(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animate:initWithAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_initWithAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Animate_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Animate",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Animation* arg0;
        ok &= luaval_to_object<ax::Animation>(tolua_S, 2, "ax.Animation",&arg0, "ax.Animate:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animate_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Animate::create(arg0);
        object_to_luaval<ax::Animate>(tolua_S, "ax.Animate",(ax::Animate*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Animate:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Animate_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Animate* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Animate_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Animate();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Animate");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Animate:Animate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Animate_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Animate_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Animate)");
    return 0;
}

int lua_register_ax_base_Animate(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Animate");
    tolua_cclass(tolua_S,"Animate","ax.Animate","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"Animate");
        tolua_function(tolua_S,"new",lua_ax_base_Animate_constructor);
        tolua_function(tolua_S,"setAnimation",lua_ax_base_Animate_setAnimation);
        tolua_function(tolua_S,"getAnimation",lua_ax_base_Animate_getAnimation);
        tolua_function(tolua_S,"getCurrentFrameIndex",lua_ax_base_Animate_getCurrentFrameIndex);
        tolua_function(tolua_S,"initWithAnimation",lua_ax_base_Animate_initWithAnimation);
        tolua_function(tolua_S,"create", lua_ax_base_Animate_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Animate).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Animate";
    g_typeCast[typeName] = "ax.Animate";
    return 1;
}

int lua_ax_base_TargetedAction_setForcedTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::TargetedAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TargetedAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TargetedAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TargetedAction_setForcedTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.TargetedAction:setForcedTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TargetedAction_setForcedTarget'", nullptr);
            return 0;
        }
        cobj->setForcedTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TargetedAction:setForcedTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TargetedAction_setForcedTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TargetedAction_getForcedTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::TargetedAction* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TargetedAction",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TargetedAction*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TargetedAction_getForcedTarget'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::Node* ret = cobj->getForcedTarget();
            object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Node* ret = cobj->getForcedTarget();
            object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TargetedAction:getForcedTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TargetedAction_getForcedTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TargetedAction_initWithTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::TargetedAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TargetedAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TargetedAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TargetedAction_initWithTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Node* arg0;
        ax::FiniteTimeAction* arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.TargetedAction:initWithTarget");

        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 3, "ax.FiniteTimeAction",&arg1, "ax.TargetedAction:initWithTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TargetedAction_initWithTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTarget(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TargetedAction:initWithTarget",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TargetedAction_initWithTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TargetedAction_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TargetedAction",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Node* arg0;
        ax::FiniteTimeAction* arg1;
        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.TargetedAction:create");
        ok &= luaval_to_object<ax::FiniteTimeAction>(tolua_S, 3, "ax.FiniteTimeAction",&arg1, "ax.TargetedAction:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TargetedAction_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TargetedAction::create(arg0, arg1);
        object_to_luaval<ax::TargetedAction>(tolua_S, "ax.TargetedAction",(ax::TargetedAction*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TargetedAction:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TargetedAction_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TargetedAction_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TargetedAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TargetedAction_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TargetedAction();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TargetedAction");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TargetedAction:TargetedAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TargetedAction_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TargetedAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TargetedAction)");
    return 0;
}

int lua_register_ax_base_TargetedAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TargetedAction");
    tolua_cclass(tolua_S,"TargetedAction","ax.TargetedAction","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"TargetedAction");
        tolua_function(tolua_S,"new",lua_ax_base_TargetedAction_constructor);
        tolua_function(tolua_S,"setForcedTarget",lua_ax_base_TargetedAction_setForcedTarget);
        tolua_function(tolua_S,"getForcedTarget",lua_ax_base_TargetedAction_getForcedTarget);
        tolua_function(tolua_S,"initWithTarget",lua_ax_base_TargetedAction_initWithTarget);
        tolua_function(tolua_S,"create", lua_ax_base_TargetedAction_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TargetedAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TargetedAction";
    g_typeCast[typeName] = "ax.TargetedAction";
    return 1;
}

int lua_ax_base_ActionFloat_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionFloat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionFloat",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionFloat*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionFloat_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        std::function<void (float)> arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionFloat:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ActionFloat:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ActionFloat:initWithDuration");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionFloat_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionFloat:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionFloat_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionFloat_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ActionFloat",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        double arg1;
        double arg2;
        std::function<void (float)> arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionFloat:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ActionFloat:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ActionFloat:create");
        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionFloat_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ActionFloat::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::ActionFloat>(tolua_S, "ax.ActionFloat",(ax::ActionFloat*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ActionFloat:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionFloat_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ActionFloat_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionFloat* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionFloat_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ActionFloat();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ActionFloat");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionFloat:ActionFloat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionFloat_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ActionFloat_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionFloat)");
    return 0;
}

int lua_register_ax_base_ActionFloat(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionFloat");
    tolua_cclass(tolua_S,"ActionFloat","ax.ActionFloat","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ActionFloat");
        tolua_function(tolua_S,"new",lua_ax_base_ActionFloat_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ActionFloat_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ActionFloat_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionFloat).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionFloat";
    g_typeCast[typeName] = "ax.ActionFloat";
    return 1;
}

int lua_ax_base_Properties_getNextProperty(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getNextProperty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getNextProperty'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNextProperty();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getNextProperty",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getNextProperty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getNextNamespace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getNextNamespace'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getNextNamespace'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNextNamespace();
        object_to_luaval<ax::Properties>(tolua_S, "ax.Properties",(ax::Properties*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getNextNamespace",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getNextNamespace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_rewind(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_rewind'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_rewind'", nullptr);
            return 0;
        }
        cobj->rewind();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:rewind",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_rewind'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getNamespace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getNamespace'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const char* ret = cobj->getNamespace();
            tolua_pushstring(tolua_S,(const char*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Properties:getNamespace");

            if (!ok) { break; }
            ax::Properties* ret = cobj->getNamespace(arg0);
            object_to_luaval<ax::Properties>(tolua_S, "ax.Properties",(ax::Properties*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Properties:getNamespace");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Properties:getNamespace");

            if (!ok) { break; }
            ax::Properties* ret = cobj->getNamespace(arg0, arg1);
            object_to_luaval<ax::Properties>(tolua_S, "ax.Properties",(ax::Properties*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Properties:getNamespace");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Properties:getNamespace");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Properties:getNamespace");

            if (!ok) { break; }
            ax::Properties* ret = cobj->getNamespace(arg0, arg1, arg2);
            object_to_luaval<ax::Properties>(tolua_S, "ax.Properties",(ax::Properties*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Properties:getNamespace",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getNamespace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getId(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getId'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getId'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getId();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getId",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getId'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_exists(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_exists'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:exists"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_exists'", nullptr);
            return 0;
        }
        auto&& ret = cobj->exists(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:exists",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_exists'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getType"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getType(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getString(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getString"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getString"); arg0 = arg0_tmp.c_str();

        std::string arg1_tmp; ok &= luaval_to_std_string(tolua_S, 3, &arg1_tmp, "ax.Properties:getString"); arg1 = arg1_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString(arg0, arg1);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getString",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_setString(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_setString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:setString"); arg0 = arg0_tmp.c_str();

        std::string arg1_tmp; ok &= luaval_to_std_string(tolua_S, 3, &arg1_tmp, "ax.Properties:setString"); arg1 = arg1_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_setString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->setString(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:setString",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_setString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getBool(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getBool'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getBool'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBool();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getBool"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getBool'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBool(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        const char* arg0;
        bool arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getBool"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Properties:getBool");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getBool'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBool(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getBool",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getBool'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getInt(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getInt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getInt'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInt();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getInt"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getInt'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInt(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getInt",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getInt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getFloat(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getFloat'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getFloat'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFloat();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getFloat"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getFloat'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFloat(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getFloat",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getFloat'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getMat4(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getMat4'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        ax::Mat4* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getMat4"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_object<ax::Mat4>(tolua_S, 3, "ax.Mat4",&arg1, "ax.Properties:getMat4");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getMat4'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMat4(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getMat4",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getMat4'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getVec2(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getVec2'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        ax::Vec2* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getVec2"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_object<ax::Vec2>(tolua_S, 3, "ax.Vec2",&arg1, "ax.Properties:getVec2");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getVec2'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVec2(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getVec2",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getVec2'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getVec3(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getVec3'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        ax::Vec3* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getVec3"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_object<ax::Vec3>(tolua_S, 3, "ax.Vec3",&arg1, "ax.Properties:getVec3");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getVec3'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVec3(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getVec3",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getVec3'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getVec4(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getVec4'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        ax::Vec4* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getVec4"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_object<ax::Vec4>(tolua_S, 3, "ax.Vec4",&arg1, "ax.Properties:getVec4");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getVec4'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVec4(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getVec4",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getVec4'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getQuaternionFromAxisAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getQuaternionFromAxisAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        ax::Quaternion* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getQuaternionFromAxisAngle"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_object<ax::Quaternion>(tolua_S, 3, "ax.Quaternion",&arg1, "ax.Properties:getQuaternionFromAxisAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getQuaternionFromAxisAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getQuaternionFromAxisAngle(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getQuaternionFromAxisAngle",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getQuaternionFromAxisAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getColor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getColor"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            ax::Vec4* arg1;
            ok &= luaval_to_object<ax::Vec4>(tolua_S, 3, "ax.Vec4",&arg1, "ax.Properties:getColor");

            if (!ok) { break; }
            bool ret = cobj->getColor(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getColor"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            ax::Vec3* arg1;
            ok &= luaval_to_object<ax::Vec3>(tolua_S, 3, "ax.Vec3",&arg1, "ax.Properties:getColor");

            if (!ok) { break; }
            bool ret = cobj->getColor(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Properties:getColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getPath(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getPath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        std::string* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getPath"); arg0 = arg0_tmp.c_str();

        #pragma warning NO CONVERSION TO NATIVE FOR basic_string*
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getPath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPath(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getPath",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getPath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_getVariable(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_getVariable'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getVariable"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getVariable'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVariable(arg0);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:getVariable"); arg0 = arg0_tmp.c_str();

        std::string arg1_tmp; ok &= luaval_to_std_string(tolua_S, 3, &arg1_tmp, "ax.Properties:getVariable"); arg1 = arg1_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_getVariable'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVariable(arg0, arg1);
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:getVariable",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_getVariable'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_setVariable(lua_State* tolua_S)
{
    int argc = 0;
    ax::Properties* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Properties*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Properties_setVariable'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        const char* arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:setVariable"); arg0 = arg0_tmp.c_str();

        std::string arg1_tmp; ok &= luaval_to_std_string(tolua_S, 3, &arg1_tmp, "ax.Properties:setVariable"); arg1 = arg1_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_setVariable'", nullptr);
            return 0;
        }
        cobj->setVariable(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Properties:setVariable",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_setVariable'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Properties_parseVec2(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        const char* arg0;
        ax::Vec2* arg1;
        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseVec2"); arg0 = arg0_tmp.c_str();
        ok &= luaval_to_object<ax::Vec2>(tolua_S, 3, "ax.Vec2",&arg1, "ax.Properties:parseVec2");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_parseVec2'", nullptr);
            return 0;
        }
        auto&& ret = ax::Properties::parseVec2(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Properties:parseVec2",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_parseVec2'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Properties_parseVec3(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        const char* arg0;
        ax::Vec3* arg1;
        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseVec3"); arg0 = arg0_tmp.c_str();
        ok &= luaval_to_object<ax::Vec3>(tolua_S, 3, "ax.Vec3",&arg1, "ax.Properties:parseVec3");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_parseVec3'", nullptr);
            return 0;
        }
        auto&& ret = ax::Properties::parseVec3(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Properties:parseVec3",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_parseVec3'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Properties_parseVec4(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        const char* arg0;
        ax::Vec4* arg1;
        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseVec4"); arg0 = arg0_tmp.c_str();
        ok &= luaval_to_object<ax::Vec4>(tolua_S, 3, "ax.Vec4",&arg1, "ax.Properties:parseVec4");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_parseVec4'", nullptr);
            return 0;
        }
        auto&& ret = ax::Properties::parseVec4(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Properties:parseVec4",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_parseVec4'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Properties_parseAxisAngle(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        const char* arg0;
        ax::Quaternion* arg1;
        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseAxisAngle"); arg0 = arg0_tmp.c_str();
        ok &= luaval_to_object<ax::Quaternion>(tolua_S, 3, "ax.Quaternion",&arg1, "ax.Properties:parseAxisAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Properties_parseAxisAngle'", nullptr);
            return 0;
        }
        auto&& ret = ax::Properties::parseAxisAngle(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Properties:parseAxisAngle",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_parseAxisAngle'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Properties_parseColor(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Properties",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseColor"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            ax::Vec4* arg1;
            ok &= luaval_to_object<ax::Vec4>(tolua_S, 3, "ax.Vec4",&arg1, "ax.Properties:parseColor");
            if (!ok) { break; }
            bool ret = ax::Properties::parseColor(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.Properties:parseColor"); arg0 = arg0_tmp.c_str();
            if (!ok) { break; }
            ax::Vec3* arg1;
            ok &= luaval_to_object<ax::Vec3>(tolua_S, 3, "ax.Vec3",&arg1, "ax.Properties:parseColor");
            if (!ok) { break; }
            bool ret = ax::Properties::parseColor(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Properties:parseColor",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Properties_parseColor'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Properties_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Properties)");
    return 0;
}

int lua_register_ax_base_Properties(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Properties");
    tolua_cclass(tolua_S,"Properties","ax.Properties","",nullptr);

    tolua_beginmodule(tolua_S,"Properties");
        tolua_function(tolua_S,"getNextProperty",lua_ax_base_Properties_getNextProperty);
        tolua_function(tolua_S,"getNextNamespace",lua_ax_base_Properties_getNextNamespace);
        tolua_function(tolua_S,"rewind",lua_ax_base_Properties_rewind);
        tolua_function(tolua_S,"getNamespace",lua_ax_base_Properties_getNamespace);
        tolua_function(tolua_S,"getId",lua_ax_base_Properties_getId);
        tolua_function(tolua_S,"exists",lua_ax_base_Properties_exists);
        tolua_function(tolua_S,"getType",lua_ax_base_Properties_getType);
        tolua_function(tolua_S,"getString",lua_ax_base_Properties_getString);
        tolua_function(tolua_S,"setString",lua_ax_base_Properties_setString);
        tolua_function(tolua_S,"getBool",lua_ax_base_Properties_getBool);
        tolua_function(tolua_S,"getInt",lua_ax_base_Properties_getInt);
        tolua_function(tolua_S,"getFloat",lua_ax_base_Properties_getFloat);
        tolua_function(tolua_S,"getMat4",lua_ax_base_Properties_getMat4);
        tolua_function(tolua_S,"getVec2",lua_ax_base_Properties_getVec2);
        tolua_function(tolua_S,"getVec3",lua_ax_base_Properties_getVec3);
        tolua_function(tolua_S,"getVec4",lua_ax_base_Properties_getVec4);
        tolua_function(tolua_S,"getQuaternionFromAxisAngle",lua_ax_base_Properties_getQuaternionFromAxisAngle);
        tolua_function(tolua_S,"getColor",lua_ax_base_Properties_getColor);
        tolua_function(tolua_S,"getPath",lua_ax_base_Properties_getPath);
        tolua_function(tolua_S,"getVariable",lua_ax_base_Properties_getVariable);
        tolua_function(tolua_S,"setVariable",lua_ax_base_Properties_setVariable);
        tolua_function(tolua_S,"parseVec2", lua_ax_base_Properties_parseVec2);
        tolua_function(tolua_S,"parseVec3", lua_ax_base_Properties_parseVec3);
        tolua_function(tolua_S,"parseVec4", lua_ax_base_Properties_parseVec4);
        tolua_function(tolua_S,"parseAxisAngle", lua_ax_base_Properties_parseAxisAngle);
        tolua_function(tolua_S,"parseColor", lua_ax_base_Properties_parseColor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Properties).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Properties";
    g_typeCast[typeName] = "ax.Properties";
    return 1;
}

int lua_ax_base_UserDefault_getBoolForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getBoolForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getBoolForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.UserDefault:getBoolForKey");

            if (!ok) { break; }
            bool ret = cobj->getBoolForKey(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getBoolForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            bool ret = cobj->getBoolForKey(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getBoolForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getBoolForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_getIntegerForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getIntegerForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getIntegerForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.UserDefault:getIntegerForKey");

            if (!ok) { break; }
            int ret = cobj->getIntegerForKey(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getIntegerForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            int ret = cobj->getIntegerForKey(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getIntegerForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getIntegerForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_getLargeIntForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getLargeIntForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getLargeIntForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            long long arg1;
            ok &= luaval_to_long_long(tolua_S, 3,&arg1, "ax.UserDefault:getLargeIntForKey");

            if (!ok) { break; }
            long long ret = cobj->getLargeIntForKey(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getLargeIntForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            long long ret = cobj->getLargeIntForKey(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getLargeIntForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getLargeIntForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_getFloatForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getFloatForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getFloatForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.UserDefault:getFloatForKey");

            if (!ok) { break; }
            double ret = cobj->getFloatForKey(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getFloatForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            double ret = cobj->getFloatForKey(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getFloatForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getFloatForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_getDoubleForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getDoubleForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getDoubleForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.UserDefault:getDoubleForKey");

            if (!ok) { break; }
            double ret = cobj->getDoubleForKey(arg0, arg1);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getDoubleForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            double ret = cobj->getDoubleForKey(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getDoubleForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getDoubleForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_getStringForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_getStringForKey'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getStringForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.UserDefault:getStringForKey");

            if (!ok) { break; }
            std::string_view ret = cobj->getStringForKey(arg0, arg1);
            lua_pushlstring(tolua_S,ret.data(),ret.length());
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            const char* arg0;
            std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:getStringForKey"); arg0 = arg0_tmp.c_str();

            if (!ok) { break; }
            std::string_view ret = cobj->getStringForKey(arg0);
            lua_pushlstring(tolua_S,ret.data(),ret.length());
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.UserDefault:getStringForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_getStringForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setBoolForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setBoolForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        bool arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setBoolForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.UserDefault:setBoolForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setBoolForKey'", nullptr);
            return 0;
        }
        cobj->setBoolForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setBoolForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setBoolForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setIntegerForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setIntegerForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setIntegerForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.UserDefault:setIntegerForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setIntegerForKey'", nullptr);
            return 0;
        }
        cobj->setIntegerForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setIntegerForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setIntegerForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setLargeIntForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setLargeIntForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        long long arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setLargeIntForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_long_long(tolua_S, 3,&arg1, "ax.UserDefault:setLargeIntForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setLargeIntForKey'", nullptr);
            return 0;
        }
        cobj->setLargeIntForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setLargeIntForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setLargeIntForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setFloatForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setFloatForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        double arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setFloatForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.UserDefault:setFloatForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setFloatForKey'", nullptr);
            return 0;
        }
        cobj->setFloatForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setFloatForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setFloatForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setDoubleForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setDoubleForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        double arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setDoubleForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.UserDefault:setDoubleForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setDoubleForKey'", nullptr);
            return 0;
        }
        cobj->setDoubleForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setDoubleForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setDoubleForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setStringForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setStringForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        std::string_view arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:setStringForKey"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.UserDefault:setStringForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setStringForKey'", nullptr);
            return 0;
        }
        cobj->setStringForKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setStringForKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setStringForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_flush(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_flush'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_flush'", nullptr);
            return 0;
        }
        cobj->flush();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:flush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_flush'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_deleteValueForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_deleteValueForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const char* arg0;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.UserDefault:deleteValueForKey"); arg0 = arg0_tmp.c_str();
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_deleteValueForKey'", nullptr);
            return 0;
        }
        cobj->deleteValueForKey(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:deleteValueForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_deleteValueForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_setEncryptEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::UserDefault* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::UserDefault*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_UserDefault_setEncryptEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        bool arg0;
        std::string_view arg1;
        std::string_view arg2;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.UserDefault:setEncryptEnabled");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.UserDefault:setEncryptEnabled");

        ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.UserDefault:setEncryptEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setEncryptEnabled'", nullptr);
            return 0;
        }
        cobj->setEncryptEnabled(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.UserDefault:setEncryptEnabled",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setEncryptEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_UserDefault_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_destroyInstance'", nullptr);
            return 0;
        }
        ax::UserDefault::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.UserDefault:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_UserDefault_setFileName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.UserDefault",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setFileName'", nullptr);
            return 0;
        }
        ax::UserDefault::setFileName();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.UserDefault:setFileName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_UserDefault_setFileName'", nullptr);
            return 0;
        }
        ax::UserDefault::setFileName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.UserDefault:setFileName",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_UserDefault_setFileName'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_UserDefault_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (UserDefault)");
    return 0;
}

int lua_register_ax_base_UserDefault(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.UserDefault");
    tolua_cclass(tolua_S,"UserDefault","ax.UserDefault","",nullptr);

    tolua_beginmodule(tolua_S,"UserDefault");
        tolua_function(tolua_S,"getBoolForKey",lua_ax_base_UserDefault_getBoolForKey);
        tolua_function(tolua_S,"getIntegerForKey",lua_ax_base_UserDefault_getIntegerForKey);
        tolua_function(tolua_S,"getLargeIntForKey",lua_ax_base_UserDefault_getLargeIntForKey);
        tolua_function(tolua_S,"getFloatForKey",lua_ax_base_UserDefault_getFloatForKey);
        tolua_function(tolua_S,"getDoubleForKey",lua_ax_base_UserDefault_getDoubleForKey);
        tolua_function(tolua_S,"getStringForKey",lua_ax_base_UserDefault_getStringForKey);
        tolua_function(tolua_S,"setBoolForKey",lua_ax_base_UserDefault_setBoolForKey);
        tolua_function(tolua_S,"setIntegerForKey",lua_ax_base_UserDefault_setIntegerForKey);
        tolua_function(tolua_S,"setLargeIntForKey",lua_ax_base_UserDefault_setLargeIntForKey);
        tolua_function(tolua_S,"setFloatForKey",lua_ax_base_UserDefault_setFloatForKey);
        tolua_function(tolua_S,"setDoubleForKey",lua_ax_base_UserDefault_setDoubleForKey);
        tolua_function(tolua_S,"setStringForKey",lua_ax_base_UserDefault_setStringForKey);
        tolua_function(tolua_S,"flush",lua_ax_base_UserDefault_flush);
        tolua_function(tolua_S,"deleteValueForKey",lua_ax_base_UserDefault_deleteValueForKey);
        tolua_function(tolua_S,"setEncryptEnabled",lua_ax_base_UserDefault_setEncryptEnabled);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_UserDefault_destroyInstance);
        tolua_function(tolua_S,"setFileName", lua_ax_base_UserDefault_setFileName);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::UserDefault).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.UserDefault";
    g_typeCast[typeName] = "ax.UserDefault";
    return 1;
}

int lua_ax_base_FileUtils_purgeCachedEntries(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_purgeCachedEntries'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_purgeCachedEntries'", nullptr);
            return 0;
        }
        cobj->purgeCachedEntries();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:purgeCachedEntries",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_purgeCachedEntries'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getStringFromFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getStringFromFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getStringFromFile");

            if (!ok) { break; }
            std::function<void (std::string)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->getStringFromFile(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getStringFromFile");

            if (!ok) { break; }
            std::string ret = cobj->getStringFromFile(arg0);
            lua_pushlstring(tolua_S,ret.c_str(),ret.length());
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:getStringFromFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getStringFromFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_fullPathForFilename(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_fullPathForFilename'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:fullPathForFilename");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_fullPathForFilename'", nullptr);
            return 0;
        }
        auto&& ret = cobj->fullPathForFilename(arg0);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:fullPathForFilename",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_fullPathForFilename'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_fullPathFromRelativeFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_fullPathFromRelativeFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::string_view arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:fullPathFromRelativeFile");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:fullPathFromRelativeFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_fullPathFromRelativeFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->fullPathFromRelativeFile(arg0, arg1);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:fullPathFromRelativeFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_fullPathFromRelativeFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_fullPathForDirectory(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_fullPathForDirectory'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:fullPathForDirectory");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_fullPathForDirectory'", nullptr);
            return 0;
        }
        auto&& ret = cobj->fullPathForDirectory(arg0);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:fullPathForDirectory",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_fullPathForDirectory'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_setSearchPaths(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_setSearchPaths'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::vector<std::string> arg0;

        ok &= luaval_to_std_vector_string(tolua_S, 2, &arg0, "ax.FileUtils:setSearchPaths");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_setSearchPaths'", nullptr);
            return 0;
        }
        cobj->setSearchPaths(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:setSearchPaths",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_setSearchPaths'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getDefaultResourceRootPath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getDefaultResourceRootPath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getDefaultResourceRootPath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDefaultResourceRootPath();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getDefaultResourceRootPath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getDefaultResourceRootPath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_setDefaultResourceRootPath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_setDefaultResourceRootPath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:setDefaultResourceRootPath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_setDefaultResourceRootPath'", nullptr);
            return 0;
        }
        cobj->setDefaultResourceRootPath(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:setDefaultResourceRootPath",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_setDefaultResourceRootPath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_addSearchPath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_addSearchPath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:addSearchPath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_addSearchPath'", nullptr);
            return 0;
        }
        cobj->addSearchPath(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        std::string_view arg0;
        bool arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:addSearchPath");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.FileUtils:addSearchPath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_addSearchPath'", nullptr);
            return 0;
        }
        cobj->addSearchPath(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:addSearchPath",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_addSearchPath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getSearchPaths(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getSearchPaths'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getSearchPaths'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSearchPaths();
        ccvector_std_string_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getSearchPaths",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getSearchPaths'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getOriginalSearchPaths(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getOriginalSearchPaths'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getOriginalSearchPaths'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOriginalSearchPaths();
        ccvector_std_string_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getOriginalSearchPaths",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getOriginalSearchPaths'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getWritablePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getWritablePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getWritablePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWritablePath();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getWritablePath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getWritablePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getNativeWritableAbsolutePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getNativeWritableAbsolutePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getNativeWritableAbsolutePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNativeWritableAbsolutePath();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getNativeWritableAbsolutePath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getNativeWritableAbsolutePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_setWritablePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_setWritablePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:setWritablePath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_setWritablePath'", nullptr);
            return 0;
        }
        cobj->setWritablePath(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:setWritablePath",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_setWritablePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_setPopupNotify(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_setPopupNotify'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FileUtils:setPopupNotify");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_setPopupNotify'", nullptr);
            return 0;
        }
        cobj->setPopupNotify(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:setPopupNotify",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_setPopupNotify'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isPopupNotify(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isPopupNotify'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_isPopupNotify'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isPopupNotify();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:isPopupNotify",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isPopupNotify'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getValueMapFromFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getValueMapFromFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getValueMapFromFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getValueMapFromFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getValueMapFromFile(arg0);
        ccvaluemap_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getValueMapFromFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getValueMapFromFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getValueMapFromData(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getValueMapFromData'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const char* arg0;
        int arg1;

        std::string arg0_tmp; ok &= luaval_to_std_string(tolua_S, 2, &arg0_tmp, "ax.FileUtils:getValueMapFromData"); arg0 = arg0_tmp.c_str();

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.FileUtils:getValueMapFromData");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getValueMapFromData'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getValueMapFromData(arg0, arg1);
        ccvaluemap_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getValueMapFromData",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getValueMapFromData'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_writeToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_writeToFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ValueMap arg0;
        std::string_view arg1;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.FileUtils:writeToFile");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeToFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_writeToFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->writeToFile(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:writeToFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_writeToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_writeStringToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_writeStringToFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            std::string arg0;
            ok &= luaval_to_std_string(tolua_S, 2,&arg0, "ax.FileUtils:writeStringToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeStringToFile");

            if (!ok) { break; }
            std::function<void (bool)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->writeStringToFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:writeStringToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeStringToFile");

            if (!ok) { break; }
            bool ret = cobj->writeStringToFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:writeStringToFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_writeStringToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_writeValueMapToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_writeValueMapToFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            ax::ValueMap arg0;
            ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.FileUtils:writeValueMapToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeValueMapToFile");

            if (!ok) { break; }
            std::function<void (bool)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->writeValueMapToFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::ValueMap arg0;
            ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.FileUtils:writeValueMapToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeValueMapToFile");

            if (!ok) { break; }
            bool ret = cobj->writeValueMapToFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:writeValueMapToFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_writeValueMapToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_writeValueVectorToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_writeValueVectorToFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            ax::ValueVector arg0;
            ok &= luaval_to_ccvaluevector(tolua_S, 2, &arg0, "ax.FileUtils:writeValueVectorToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeValueVectorToFile");

            if (!ok) { break; }
            std::function<void (bool)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->writeValueVectorToFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::ValueVector arg0;
            ok &= luaval_to_ccvaluevector(tolua_S, 2, &arg0, "ax.FileUtils:writeValueVectorToFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:writeValueVectorToFile");

            if (!ok) { break; }
            bool ret = cobj->writeValueVectorToFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:writeValueVectorToFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_writeValueVectorToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getValueVectorFromFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getValueVectorFromFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getValueVectorFromFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getValueVectorFromFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getValueVectorFromFile(arg0);
        ccvaluevector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getValueVectorFromFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getValueVectorFromFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isFileExist(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isFileExist'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isFileExist");

            if (!ok) { break; }
            std::function<void (bool)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->isFileExist(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isFileExist");

            if (!ok) { break; }
            bool ret = cobj->isFileExist(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:isFileExist",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isFileExist'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getFileExtension(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getFileExtension'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getFileExtension");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getFileExtension'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFileExtension(arg0);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:getFileExtension",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getFileExtension'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isAbsolutePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isAbsolutePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isAbsolutePath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_isAbsolutePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAbsolutePath(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:isAbsolutePath",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isAbsolutePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isDirectoryExist(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isDirectoryExist'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isDirectoryExist");

            if (!ok) { break; }
            std::function<void (bool)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->isDirectoryExist(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isDirectoryExist");

            if (!ok) { break; }
            bool ret = cobj->isDirectoryExist(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:isDirectoryExist",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isDirectoryExist'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_createDirectory(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_createDirectory'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:createDirectory");

            if (!ok) { break; }
            std::function<void (bool)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->createDirectory(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:createDirectory");

            if (!ok) { break; }
            bool ret = cobj->createDirectory(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:createDirectory",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_createDirectory'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_removeDirectory(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_removeDirectory'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:removeDirectory");

            if (!ok) { break; }
            std::function<void (bool)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->removeDirectory(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:removeDirectory");

            if (!ok) { break; }
            bool ret = cobj->removeDirectory(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:removeDirectory",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_removeDirectory'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_removeFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_removeFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:removeFile");

            if (!ok) { break; }
            std::function<void (bool)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->removeFile(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:removeFile");

            if (!ok) { break; }
            bool ret = cobj->removeFile(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:removeFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_removeFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_renameFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_renameFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg2;
            ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::function<void (bool)> arg3;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->renameFile(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg2;
            ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            bool ret = cobj->renameFile(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            bool ret = cobj->renameFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FileUtils:renameFile");

            if (!ok) { break; }
            std::function<void (bool)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->renameFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:renameFile",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_renameFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getFileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_getFileSize'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getFileSize");

            if (!ok) { break; }
            std::function<void (long long)> arg1;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            cobj->getFileSize(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getFileSize");

            if (!ok) { break; }
            long long ret = cobj->getFileSize(arg0);
            tolua_pushnumber(tolua_S,(lua_Number)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FileUtils:getFileSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getFileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_listFiles(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_listFiles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:listFiles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_listFiles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->listFiles(arg0);
        ccvector_std_string_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:listFiles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_listFiles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_listFilesAsync(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_listFilesAsync'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::function<void (std::vector<std::string>)> arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:listFilesAsync");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_listFilesAsync'", nullptr);
            return 0;
        }
        cobj->listFilesAsync(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:listFilesAsync",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_listFilesAsync'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_listFilesRecursively(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_listFilesRecursively'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::vector<std::string>* arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:listFilesRecursively");

        ok &= luaval_to_object<std::vector<std::string>>(tolua_S, 3, "std::vector<std::string>*",&arg1, "ax.FileUtils:listFilesRecursively");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_listFilesRecursively'", nullptr);
            return 0;
        }
        cobj->listFilesRecursively(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:listFilesRecursively",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_listFilesRecursively'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_listFilesRecursivelyAsync(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_listFilesRecursivelyAsync'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::function<void (std::vector<std::string>)> arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:listFilesRecursivelyAsync");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_listFilesRecursivelyAsync'", nullptr);
            return 0;
        }
        cobj->listFilesRecursivelyAsync(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:listFilesRecursivelyAsync",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_listFilesRecursivelyAsync'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isFileExistInternal(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isFileExistInternal'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isFileExistInternal");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_isFileExistInternal'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFileExistInternal(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:isFileExistInternal",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isFileExistInternal'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_isDirectoryExistInternal(lua_State* tolua_S)
{
    int argc = 0;
    ax::FileUtils* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FileUtils*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FileUtils_isDirectoryExistInternal'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isDirectoryExistInternal");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_isDirectoryExistInternal'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isDirectoryExistInternal(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FileUtils:isDirectoryExistInternal",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isDirectoryExistInternal'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FileUtils_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::FileUtils::getInstance();
        object_to_luaval<ax::FileUtils>(tolua_S, "ax.FileUtils",(ax::FileUtils*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FileUtils:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FileUtils_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_destroyInstance'", nullptr);
            return 0;
        }
        ax::FileUtils::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FileUtils:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FileUtils_writeBinaryToFile(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        const void* arg0;
        unsigned int arg1;
        std::string_view arg2;
        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;
        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.FileUtils:writeBinaryToFile");
        ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.FileUtils:writeBinaryToFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_writeBinaryToFile'", nullptr);
            return 0;
        }
        auto&& ret = ax::FileUtils::writeBinaryToFile(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FileUtils:writeBinaryToFile",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_writeBinaryToFile'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FileUtils_getFileShortName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:getFileShortName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_getFileShortName'", nullptr);
            return 0;
        }
        auto&& ret = ax::FileUtils::getFileShortName(arg0);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FileUtils:getFileShortName",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_getFileShortName'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FileUtils_isAbsolutePathInternal(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FileUtils",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FileUtils:isAbsolutePathInternal");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FileUtils_isAbsolutePathInternal'", nullptr);
            return 0;
        }
        auto&& ret = ax::FileUtils::isAbsolutePathInternal(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FileUtils:isAbsolutePathInternal",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FileUtils_isAbsolutePathInternal'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_FileUtils_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FileUtils)");
    return 0;
}

int lua_register_ax_base_FileUtils(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FileUtils");
    tolua_cclass(tolua_S,"FileUtils","ax.FileUtils","",nullptr);

    tolua_beginmodule(tolua_S,"FileUtils");
        tolua_function(tolua_S,"purgeCachedEntries",lua_ax_base_FileUtils_purgeCachedEntries);
        tolua_function(tolua_S,"getStringFromFile",lua_ax_base_FileUtils_getStringFromFile);
        tolua_function(tolua_S,"fullPathForFilename",lua_ax_base_FileUtils_fullPathForFilename);
        tolua_function(tolua_S,"fullPathFromRelativeFile",lua_ax_base_FileUtils_fullPathFromRelativeFile);
        tolua_function(tolua_S,"fullPathForDirectory",lua_ax_base_FileUtils_fullPathForDirectory);
        tolua_function(tolua_S,"setSearchPaths",lua_ax_base_FileUtils_setSearchPaths);
        tolua_function(tolua_S,"getDefaultResourceRootPath",lua_ax_base_FileUtils_getDefaultResourceRootPath);
        tolua_function(tolua_S,"setDefaultResourceRootPath",lua_ax_base_FileUtils_setDefaultResourceRootPath);
        tolua_function(tolua_S,"addSearchPath",lua_ax_base_FileUtils_addSearchPath);
        tolua_function(tolua_S,"getSearchPaths",lua_ax_base_FileUtils_getSearchPaths);
        tolua_function(tolua_S,"getOriginalSearchPaths",lua_ax_base_FileUtils_getOriginalSearchPaths);
        tolua_function(tolua_S,"getWritablePath",lua_ax_base_FileUtils_getWritablePath);
        tolua_function(tolua_S,"getNativeWritableAbsolutePath",lua_ax_base_FileUtils_getNativeWritableAbsolutePath);
        tolua_function(tolua_S,"setWritablePath",lua_ax_base_FileUtils_setWritablePath);
        tolua_function(tolua_S,"setPopupNotify",lua_ax_base_FileUtils_setPopupNotify);
        tolua_function(tolua_S,"isPopupNotify",lua_ax_base_FileUtils_isPopupNotify);
        tolua_function(tolua_S,"getValueMapFromFile",lua_ax_base_FileUtils_getValueMapFromFile);
        tolua_function(tolua_S,"getValueMapFromData",lua_ax_base_FileUtils_getValueMapFromData);
        tolua_function(tolua_S,"writeToFile",lua_ax_base_FileUtils_writeToFile);
        tolua_function(tolua_S,"writeStringToFile",lua_ax_base_FileUtils_writeStringToFile);
        tolua_function(tolua_S,"writeValueMapToFile",lua_ax_base_FileUtils_writeValueMapToFile);
        tolua_function(tolua_S,"writeValueVectorToFile",lua_ax_base_FileUtils_writeValueVectorToFile);
        tolua_function(tolua_S,"getValueVectorFromFile",lua_ax_base_FileUtils_getValueVectorFromFile);
        tolua_function(tolua_S,"isFileExist",lua_ax_base_FileUtils_isFileExist);
        tolua_function(tolua_S,"getFileExtension",lua_ax_base_FileUtils_getFileExtension);
        tolua_function(tolua_S,"isAbsolutePath",lua_ax_base_FileUtils_isAbsolutePath);
        tolua_function(tolua_S,"isDirectoryExist",lua_ax_base_FileUtils_isDirectoryExist);
        tolua_function(tolua_S,"createDirectory",lua_ax_base_FileUtils_createDirectory);
        tolua_function(tolua_S,"removeDirectory",lua_ax_base_FileUtils_removeDirectory);
        tolua_function(tolua_S,"removeFile",lua_ax_base_FileUtils_removeFile);
        tolua_function(tolua_S,"renameFile",lua_ax_base_FileUtils_renameFile);
        tolua_function(tolua_S,"getFileSize",lua_ax_base_FileUtils_getFileSize);
        tolua_function(tolua_S,"listFiles",lua_ax_base_FileUtils_listFiles);
        tolua_function(tolua_S,"listFilesAsync",lua_ax_base_FileUtils_listFilesAsync);
        tolua_function(tolua_S,"listFilesRecursively",lua_ax_base_FileUtils_listFilesRecursively);
        tolua_function(tolua_S,"listFilesRecursivelyAsync",lua_ax_base_FileUtils_listFilesRecursivelyAsync);
        tolua_function(tolua_S,"isFileExistInternal",lua_ax_base_FileUtils_isFileExistInternal);
        tolua_function(tolua_S,"isDirectoryExistInternal",lua_ax_base_FileUtils_isDirectoryExistInternal);
        tolua_function(tolua_S,"getInstance", lua_ax_base_FileUtils_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_FileUtils_destroyInstance);
        tolua_function(tolua_S,"writeBinaryToFile", lua_ax_base_FileUtils_writeBinaryToFile);
        tolua_function(tolua_S,"getFileShortName", lua_ax_base_FileUtils_getFileShortName);
        tolua_function(tolua_S,"isAbsolutePathInternal", lua_ax_base_FileUtils_isAbsolutePathInternal);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FileUtils).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FileUtils";
    g_typeCast[typeName] = "ax.FileUtils";
    return 1;
}

static int lua_ax_base_EventAcceleration_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventAcceleration)");
    return 0;
}

int lua_register_ax_base_EventAcceleration(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventAcceleration");
    tolua_cclass(tolua_S,"EventAcceleration","ax.EventAcceleration","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventAcceleration");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventAcceleration).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventAcceleration";
    g_typeCast[typeName] = "ax.EventAcceleration";
    return 1;
}

int lua_ax_base_EventCustom_getEventName(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventCustom* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventCustom",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventCustom*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventCustom_getEventName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventCustom_getEventName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEventName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventCustom:getEventName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventCustom_getEventName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventCustom_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventCustom* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventCustom:EventCustom");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventCustom_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventCustom(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventCustom");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventCustom:EventCustom",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventCustom_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventCustom_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventCustom)");
    return 0;
}

int lua_register_ax_base_EventCustom(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventCustom");
    tolua_cclass(tolua_S,"EventCustom","ax.EventCustom","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventCustom");
        tolua_function(tolua_S,"new",lua_ax_base_EventCustom_constructor);
        tolua_function(tolua_S,"getEventName",lua_ax_base_EventCustom_getEventName);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventCustom).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventCustom";
    g_typeCast[typeName] = "ax.EventCustom";
    return 1;
}

int lua_ax_base_EventDispatcher_addEventListenerWithSceneGraphPriority(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_addEventListenerWithSceneGraphPriority'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::EventListener* arg0;
        ax::Node* arg1;

        ok &= luaval_to_object<ax::EventListener>(tolua_S, 2, "ax.EventListener",&arg0, "ax.EventDispatcher:addEventListenerWithSceneGraphPriority");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.EventDispatcher:addEventListenerWithSceneGraphPriority");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_addEventListenerWithSceneGraphPriority'", nullptr);
            return 0;
        }
        cobj->addEventListenerWithSceneGraphPriority(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:addEventListenerWithSceneGraphPriority",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_addEventListenerWithSceneGraphPriority'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_addEventListenerWithFixedPriority(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_addEventListenerWithFixedPriority'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::EventListener* arg0;
        int arg1;

        ok &= luaval_to_object<ax::EventListener>(tolua_S, 2, "ax.EventListener",&arg0, "ax.EventDispatcher:addEventListenerWithFixedPriority");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.EventDispatcher:addEventListenerWithFixedPriority");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_addEventListenerWithFixedPriority'", nullptr);
            return 0;
        }
        cobj->addEventListenerWithFixedPriority(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:addEventListenerWithFixedPriority",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_addEventListenerWithFixedPriority'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_addCustomEventListener(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_addCustomEventListener'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::function<void (ax::EventCustom *)> arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventDispatcher:addCustomEventListener");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_addCustomEventListener'", nullptr);
            return 0;
        }
        auto&& ret = cobj->addCustomEventListener(arg0, arg1);
        object_to_luaval<ax::EventListenerCustom>(tolua_S, "ax.EventListenerCustom",(ax::EventListenerCustom*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:addCustomEventListener",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_addCustomEventListener'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_removeEventListener(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_removeEventListener'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventListener* arg0;

        ok &= luaval_to_object<ax::EventListener>(tolua_S, 2, "ax.EventListener",&arg0, "ax.EventDispatcher:removeEventListener");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeEventListener'", nullptr);
            return 0;
        }
        cobj->removeEventListener(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:removeEventListener",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_removeEventListener'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_removeEventListenersForType(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_removeEventListenersForType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventListener::Type arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventDispatcher:removeEventListenersForType");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeEventListenersForType'", nullptr);
            return 0;
        }
        cobj->removeEventListenersForType(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:removeEventListenersForType",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_removeEventListenersForType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_removeEventListenersForTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_removeEventListenersForTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:removeEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->removeEventListenersForTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:removeEventListenersForTarget");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.EventDispatcher:removeEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->removeEventListenersForTarget(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:removeEventListenersForTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_removeEventListenersForTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_removeCustomEventListeners(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_removeCustomEventListeners'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventDispatcher:removeCustomEventListeners");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeCustomEventListeners'", nullptr);
            return 0;
        }
        cobj->removeCustomEventListeners(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:removeCustomEventListeners",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_removeCustomEventListeners'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_removeAllEventListeners(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_removeAllEventListeners'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_removeAllEventListeners'", nullptr);
            return 0;
        }
        cobj->removeAllEventListeners();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:removeAllEventListeners",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_removeAllEventListeners'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_pauseEventListenersForTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_pauseEventListenersForTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:pauseEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_pauseEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->pauseEventListenersForTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:pauseEventListenersForTarget");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.EventDispatcher:pauseEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_pauseEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->pauseEventListenersForTarget(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:pauseEventListenersForTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_pauseEventListenersForTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_resumeEventListenersForTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_resumeEventListenersForTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:resumeEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_resumeEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->resumeEventListenersForTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.EventDispatcher:resumeEventListenersForTarget");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.EventDispatcher:resumeEventListenersForTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_resumeEventListenersForTarget'", nullptr);
            return 0;
        }
        cobj->resumeEventListenersForTarget(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:resumeEventListenersForTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_resumeEventListenersForTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_setPriority(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_setPriority'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::EventListener* arg0;
        int arg1;

        ok &= luaval_to_object<ax::EventListener>(tolua_S, 2, "ax.EventListener",&arg0, "ax.EventDispatcher:setPriority");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.EventDispatcher:setPriority");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_setPriority'", nullptr);
            return 0;
        }
        cobj->setPriority(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:setPriority",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_setPriority'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.EventDispatcher:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_isEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_dispatchEvent(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_dispatchEvent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Event* arg0;

        ok &= luaval_to_object<ax::Event>(tolua_S, 2, "ax.Event",&arg0, "ax.EventDispatcher:dispatchEvent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_dispatchEvent'", nullptr);
            return 0;
        }
        cobj->dispatchEvent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:dispatchEvent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_dispatchEvent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_dispatchCustomEvent(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_dispatchCustomEvent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventDispatcher:dispatchCustomEvent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_dispatchCustomEvent'", nullptr);
            return 0;
        }
        cobj->dispatchCustomEvent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        std::string_view arg0;
        void* arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventDispatcher:dispatchCustomEvent");

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_dispatchCustomEvent'", nullptr);
            return 0;
        }
        cobj->dispatchCustomEvent(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:dispatchCustomEvent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_dispatchCustomEvent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_hasEventListener(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventDispatcher",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventDispatcher*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventDispatcher_hasEventListener'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.EventDispatcher:hasEventListener");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_hasEventListener'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasEventListener(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:hasEventListener",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_hasEventListener'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventDispatcher_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventDispatcher* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventDispatcher_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventDispatcher();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventDispatcher");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventDispatcher:EventDispatcher",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventDispatcher_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventDispatcher_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventDispatcher)");
    return 0;
}

int lua_register_ax_base_EventDispatcher(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventDispatcher");
    tolua_cclass(tolua_S,"EventDispatcher","ax.EventDispatcher","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"EventDispatcher");
        tolua_function(tolua_S,"new",lua_ax_base_EventDispatcher_constructor);
        tolua_function(tolua_S,"addEventListenerWithSceneGraphPriority",lua_ax_base_EventDispatcher_addEventListenerWithSceneGraphPriority);
        tolua_function(tolua_S,"addEventListenerWithFixedPriority",lua_ax_base_EventDispatcher_addEventListenerWithFixedPriority);
        tolua_function(tolua_S,"addCustomEventListener",lua_ax_base_EventDispatcher_addCustomEventListener);
        tolua_function(tolua_S,"removeEventListener",lua_ax_base_EventDispatcher_removeEventListener);
        tolua_function(tolua_S,"removeEventListenersForType",lua_ax_base_EventDispatcher_removeEventListenersForType);
        tolua_function(tolua_S,"removeEventListenersForTarget",lua_ax_base_EventDispatcher_removeEventListenersForTarget);
        tolua_function(tolua_S,"removeCustomEventListeners",lua_ax_base_EventDispatcher_removeCustomEventListeners);
        tolua_function(tolua_S,"removeAllEventListeners",lua_ax_base_EventDispatcher_removeAllEventListeners);
        tolua_function(tolua_S,"pauseEventListenersForTarget",lua_ax_base_EventDispatcher_pauseEventListenersForTarget);
        tolua_function(tolua_S,"resumeEventListenersForTarget",lua_ax_base_EventDispatcher_resumeEventListenersForTarget);
        tolua_function(tolua_S,"setPriority",lua_ax_base_EventDispatcher_setPriority);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_EventDispatcher_setEnabled);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_EventDispatcher_isEnabled);
        tolua_function(tolua_S,"dispatchEvent",lua_ax_base_EventDispatcher_dispatchEvent);
        tolua_function(tolua_S,"dispatchCustomEvent",lua_ax_base_EventDispatcher_dispatchCustomEvent);
        tolua_function(tolua_S,"hasEventListener",lua_ax_base_EventDispatcher_hasEventListener);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventDispatcher).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventDispatcher";
    g_typeCast[typeName] = "ax.EventDispatcher";
    return 1;
}

int lua_ax_base_EventFocus_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventFocus* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ui::Widget* arg0;
        ax::ui::Widget* arg1;

        ok &= luaval_to_object<ax::ui::Widget>(tolua_S, 2, "axui.Widget",&arg0, "ax.EventFocus:EventFocus");

        ok &= luaval_to_object<ax::ui::Widget>(tolua_S, 3, "axui.Widget",&arg1, "ax.EventFocus:EventFocus");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventFocus_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventFocus(arg0, arg1);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventFocus");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventFocus:EventFocus",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventFocus_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventFocus_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventFocus)");
    return 0;
}

int lua_register_ax_base_EventFocus(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventFocus");
    tolua_cclass(tolua_S,"EventFocus","ax.EventFocus","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventFocus");
        tolua_function(tolua_S,"new",lua_ax_base_EventFocus_constructor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventFocus).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventFocus";
    g_typeCast[typeName] = "ax.EventFocus";
    return 1;
}

int lua_ax_base_EventListenerAcceleration_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerAcceleration* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerAcceleration",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerAcceleration*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerAcceleration_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void (ax::Acceleration *, ax::Event *)> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerAcceleration_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerAcceleration:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerAcceleration_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerAcceleration_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerAcceleration* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerAcceleration_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerAcceleration();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerAcceleration");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerAcceleration:EventListenerAcceleration",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerAcceleration_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerAcceleration_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerAcceleration)");
    return 0;
}

int lua_register_ax_base_EventListenerAcceleration(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerAcceleration");
    tolua_cclass(tolua_S,"EventListenerAcceleration","ax.EventListenerAcceleration","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerAcceleration");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerAcceleration_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerAcceleration_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerAcceleration).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerAcceleration";
    g_typeCast[typeName] = "ax.EventListenerAcceleration";
    return 1;
}

int lua_ax_base_EventListenerFocus_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerFocus* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerFocus",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerFocus*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerFocus_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerFocus_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerFocus:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerFocus_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerFocus_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerFocus* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerFocus_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerFocus();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerFocus");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerFocus:EventListenerFocus",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerFocus_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerFocus_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerFocus)");
    return 0;
}

int lua_register_ax_base_EventListenerFocus(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerFocus");
    tolua_cclass(tolua_S,"EventListenerFocus","ax.EventListenerFocus","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerFocus");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerFocus_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerFocus_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerFocus).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerFocus";
    g_typeCast[typeName] = "ax.EventListenerFocus";
    return 1;
}

int lua_ax_base_EventListenerKeyboard_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerKeyboard* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerKeyboard",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerKeyboard*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerKeyboard_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerKeyboard_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerKeyboard:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerKeyboard_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerKeyboard_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerKeyboard* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerKeyboard_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerKeyboard();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerKeyboard");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerKeyboard:EventListenerKeyboard",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerKeyboard_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerKeyboard_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerKeyboard)");
    return 0;
}

int lua_register_ax_base_EventListenerKeyboard(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerKeyboard");
    tolua_cclass(tolua_S,"EventListenerKeyboard","ax.EventListenerKeyboard","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerKeyboard");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerKeyboard_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerKeyboard_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerKeyboard).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerKeyboard";
    g_typeCast[typeName] = "ax.EventListenerKeyboard";
    return 1;
}

int lua_ax_base_EventMouse_setScrollData(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_setScrollData'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.EventMouse:setScrollData");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EventMouse:setScrollData");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_setScrollData'", nullptr);
            return 0;
        }
        cobj->setScrollData(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:setScrollData",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_setScrollData'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getScrollX(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getScrollX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getScrollX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScrollX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getScrollX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getScrollX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getScrollY(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getScrollY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getScrollY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScrollY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getScrollY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getScrollY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_setCursorPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_setCursorPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.EventMouse:setCursorPosition");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EventMouse:setCursorPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_setCursorPosition'", nullptr);
            return 0;
        }
        cobj->setCursorPosition(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:setCursorPosition",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_setCursorPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_setMouseButton(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_setMouseButton'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventMouse::MouseButton arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventMouse:setMouseButton");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_setMouseButton'", nullptr);
            return 0;
        }
        cobj->setMouseButton(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:setMouseButton",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_setMouseButton'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getMouseButton(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getMouseButton'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getMouseButton'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getMouseButton();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getMouseButton",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getMouseButton'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getCursorX(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getCursorX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getCursorX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCursorX();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getCursorX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getCursorX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getCursorY(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getCursorY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getCursorY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCursorY();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getCursorY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getCursorY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getPreviousLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getPreviousLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getPreviousLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPreviousLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getPreviousLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getPreviousLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getStartLocation(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getStartLocation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getStartLocation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartLocation();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getStartLocation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getStartLocation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getDelta(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getDelta'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getDelta'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDelta();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getDelta",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getDelta'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getPreviousLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getPreviousLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getPreviousLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPreviousLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getPreviousLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getPreviousLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_getStartLocationInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventMouse_getStartLocationInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_getStartLocationInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartLocationInView();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:getStartLocationInView",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_getStartLocationInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventMouse_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventMouse::MouseEventType arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventMouse:EventMouse");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventMouse_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventMouse(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventMouse");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventMouse:EventMouse",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventMouse_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventMouse_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventMouse)");
    return 0;
}

int lua_register_ax_base_EventMouse(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventMouse");
    tolua_cclass(tolua_S,"EventMouse","ax.EventMouse","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventMouse");
        tolua_function(tolua_S,"new",lua_ax_base_EventMouse_constructor);
        tolua_function(tolua_S,"setScrollData",lua_ax_base_EventMouse_setScrollData);
        tolua_function(tolua_S,"getScrollX",lua_ax_base_EventMouse_getScrollX);
        tolua_function(tolua_S,"getScrollY",lua_ax_base_EventMouse_getScrollY);
        tolua_function(tolua_S,"setCursorPosition",lua_ax_base_EventMouse_setCursorPosition);
        tolua_function(tolua_S,"setMouseButton",lua_ax_base_EventMouse_setMouseButton);
        tolua_function(tolua_S,"getMouseButton",lua_ax_base_EventMouse_getMouseButton);
        tolua_function(tolua_S,"getCursorX",lua_ax_base_EventMouse_getCursorX);
        tolua_function(tolua_S,"getCursorY",lua_ax_base_EventMouse_getCursorY);
        tolua_function(tolua_S,"getLocation",lua_ax_base_EventMouse_getLocation);
        tolua_function(tolua_S,"getPreviousLocation",lua_ax_base_EventMouse_getPreviousLocation);
        tolua_function(tolua_S,"getStartLocation",lua_ax_base_EventMouse_getStartLocation);
        tolua_function(tolua_S,"getDelta",lua_ax_base_EventMouse_getDelta);
        tolua_function(tolua_S,"getLocationInView",lua_ax_base_EventMouse_getLocationInView);
        tolua_function(tolua_S,"getPreviousLocationInView",lua_ax_base_EventMouse_getPreviousLocationInView);
        tolua_function(tolua_S,"getStartLocationInView",lua_ax_base_EventMouse_getStartLocationInView);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventMouse).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventMouse";
    g_typeCast[typeName] = "ax.EventMouse";
    return 1;
}

int lua_ax_base_EventListenerMouse_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerMouse",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerMouse*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerMouse_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerMouse_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerMouse:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerMouse_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerMouse_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerMouse* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerMouse_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerMouse();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerMouse");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerMouse:EventListenerMouse",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerMouse_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerMouse_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerMouse)");
    return 0;
}

int lua_register_ax_base_EventListenerMouse(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerMouse");
    tolua_cclass(tolua_S,"EventListenerMouse","ax.EventListenerMouse","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerMouse");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerMouse_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerMouse_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerMouse).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerMouse";
    g_typeCast[typeName] = "ax.EventListenerMouse";
    return 1;
}

static int lua_ax_base_EventListenerController_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerController)");
    return 0;
}

int lua_register_ax_base_EventListenerController(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerController");
    tolua_cclass(tolua_S,"EventListenerController","ax.EventListenerController","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerController");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerController).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerController";
    g_typeCast[typeName] = "ax.EventListenerController";
    return 1;
}

int lua_ax_base_EventListenerTouchOneByOne_setSwallowTouches(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchOneByOne* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerTouchOneByOne",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerTouchOneByOne*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerTouchOneByOne_setSwallowTouches'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.EventListenerTouchOneByOne:setSwallowTouches");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchOneByOne_setSwallowTouches'", nullptr);
            return 0;
        }
        cobj->setSwallowTouches(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchOneByOne:setSwallowTouches",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchOneByOne_setSwallowTouches'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerTouchOneByOne_isSwallowTouches(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchOneByOne* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerTouchOneByOne",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerTouchOneByOne*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerTouchOneByOne_isSwallowTouches'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchOneByOne_isSwallowTouches'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSwallowTouches();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchOneByOne:isSwallowTouches",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchOneByOne_isSwallowTouches'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerTouchOneByOne_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchOneByOne* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerTouchOneByOne",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerTouchOneByOne*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerTouchOneByOne_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchOneByOne_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchOneByOne:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchOneByOne_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerTouchOneByOne_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchOneByOne* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchOneByOne_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerTouchOneByOne();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerTouchOneByOne");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchOneByOne:EventListenerTouchOneByOne",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchOneByOne_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerTouchOneByOne_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerTouchOneByOne)");
    return 0;
}

int lua_register_ax_base_EventListenerTouchOneByOne(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerTouchOneByOne");
    tolua_cclass(tolua_S,"EventListenerTouchOneByOne","ax.EventListenerTouchOneByOne","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerTouchOneByOne");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerTouchOneByOne_constructor);
        tolua_function(tolua_S,"setSwallowTouches",lua_ax_base_EventListenerTouchOneByOne_setSwallowTouches);
        tolua_function(tolua_S,"isSwallowTouches",lua_ax_base_EventListenerTouchOneByOne_isSwallowTouches);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerTouchOneByOne_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerTouchOneByOne).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerTouchOneByOne";
    g_typeCast[typeName] = "ax.EventListenerTouchOneByOne";
    return 1;
}

int lua_ax_base_EventListenerTouchAllAtOnce_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchAllAtOnce* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventListenerTouchAllAtOnce",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventListenerTouchAllAtOnce*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventListenerTouchAllAtOnce_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchAllAtOnce_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchAllAtOnce:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchAllAtOnce_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventListenerTouchAllAtOnce_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventListenerTouchAllAtOnce* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventListenerTouchAllAtOnce_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EventListenerTouchAllAtOnce();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventListenerTouchAllAtOnce");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventListenerTouchAllAtOnce:EventListenerTouchAllAtOnce",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventListenerTouchAllAtOnce_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventListenerTouchAllAtOnce_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventListenerTouchAllAtOnce)");
    return 0;
}

int lua_register_ax_base_EventListenerTouchAllAtOnce(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventListenerTouchAllAtOnce");
    tolua_cclass(tolua_S,"EventListenerTouchAllAtOnce","ax.EventListenerTouchAllAtOnce","ax.EventListener",nullptr);

    tolua_beginmodule(tolua_S,"EventListenerTouchAllAtOnce");
        tolua_function(tolua_S,"new",lua_ax_base_EventListenerTouchAllAtOnce_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_EventListenerTouchAllAtOnce_init);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventListenerTouchAllAtOnce).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventListenerTouchAllAtOnce";
    g_typeCast[typeName] = "ax.EventListenerTouchAllAtOnce";
    return 1;
}

int lua_ax_base_EventController_getControllerEventType(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_getControllerEventType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_getControllerEventType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getControllerEventType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:getControllerEventType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_getControllerEventType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_getController(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_getController'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_getController'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getController();
        object_to_luaval<ax::Controller>(tolua_S, "ax.Controller",(ax::Controller*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:getController",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_getController'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_getKeyCode(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_getKeyCode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_getKeyCode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getKeyCode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:getKeyCode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_getKeyCode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_setKeyCode(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_setKeyCode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventController:setKeyCode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_setKeyCode'", nullptr);
            return 0;
        }
        cobj->setKeyCode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:setKeyCode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_setKeyCode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_setConnectStatus(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_setConnectStatus'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.EventController:setConnectStatus");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_setConnectStatus'", nullptr);
            return 0;
        }
        cobj->setConnectStatus(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:setConnectStatus",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_setConnectStatus'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_isConnected(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EventController",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EventController*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EventController_isConnected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EventController_isConnected'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isConnected();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EventController:isConnected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_isConnected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EventController_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EventController* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            ax::EventController::ControllerEventType arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventController:EventController");

            if (!ok) { break; }
            ax::Controller* arg1;
            ok &= luaval_to_object<ax::Controller>(tolua_S, 3, "ax.Controller",&arg1, "ax.EventController:EventController");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.EventController:EventController");

            if (!ok) { break; }
            cobj = new ax::EventController(arg0, arg1, arg2);
            cobj->autorelease();
            int ID =  (int)cobj->_ID ;
            int* luaID =  &cobj->_luaID ;
            toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventController");
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::EventController::ControllerEventType arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.EventController:EventController");

            if (!ok) { break; }
            ax::Controller* arg1;
            ok &= luaval_to_object<ax::Controller>(tolua_S, 3, "ax.Controller",&arg1, "ax.EventController:EventController");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.EventController:EventController");

            if (!ok) { break; }
            cobj = new ax::EventController(arg0, arg1, arg2);
            cobj->autorelease();
            int ID =  (int)cobj->_ID ;
            int* luaID =  &cobj->_luaID ;
            toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EventController");
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.EventController:EventController",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EventController_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EventController_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EventController)");
    return 0;
}

int lua_register_ax_base_EventController(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EventController");
    tolua_cclass(tolua_S,"EventController","ax.EventController","ax.Event",nullptr);

    tolua_beginmodule(tolua_S,"EventController");
        tolua_function(tolua_S,"new",lua_ax_base_EventController_constructor);
        tolua_function(tolua_S,"getControllerEventType",lua_ax_base_EventController_getControllerEventType);
        tolua_function(tolua_S,"getController",lua_ax_base_EventController_getController);
        tolua_function(tolua_S,"getKeyCode",lua_ax_base_EventController_getKeyCode);
        tolua_function(tolua_S,"setKeyCode",lua_ax_base_EventController_setKeyCode);
        tolua_function(tolua_S,"setConnectStatus",lua_ax_base_EventController_setConnectStatus);
        tolua_function(tolua_S,"isConnected",lua_ax_base_EventController_isConnected);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EventController).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EventController";
    g_typeCast[typeName] = "ax.EventController";
    return 1;
}

int lua_ax_base_ActionCamera_setEye(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_setEye'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionCamera:setEye");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ActionCamera:setEye");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ActionCamera:setEye");

            if (!ok) { break; }
            cobj->setEye(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Vec3 arg0;
            ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.ActionCamera:setEye");

            if (!ok) { break; }
            cobj->setEye(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ActionCamera:setEye",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_setEye'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_getEye(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_getEye'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_getEye'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEye();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:getEye",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_getEye'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_setCenter(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_setCenter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.ActionCamera:setCenter");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_setCenter'", nullptr);
            return 0;
        }
        cobj->setCenter(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:setCenter",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_setCenter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_getCenter(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_getCenter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_getCenter'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCenter();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:getCenter",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_getCenter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_setUp(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_setUp'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.ActionCamera:setUp");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_setUp'", nullptr);
            return 0;
        }
        cobj->setUp(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:setUp",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_setUp'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_getUp(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCamera_getUp'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_getUp'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getUp();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:getUp",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_getUp'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCamera_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCamera_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ActionCamera();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ActionCamera");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCamera:ActionCamera",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCamera_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ActionCamera_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionCamera)");
    return 0;
}

int lua_register_ax_base_ActionCamera(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionCamera");
    tolua_cclass(tolua_S,"ActionCamera","ax.ActionCamera","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ActionCamera");
        tolua_function(tolua_S,"new",lua_ax_base_ActionCamera_constructor);
        tolua_function(tolua_S,"setEye",lua_ax_base_ActionCamera_setEye);
        tolua_function(tolua_S,"getEye",lua_ax_base_ActionCamera_getEye);
        tolua_function(tolua_S,"setCenter",lua_ax_base_ActionCamera_setCenter);
        tolua_function(tolua_S,"getCenter",lua_ax_base_ActionCamera_getCenter);
        tolua_function(tolua_S,"setUp",lua_ax_base_ActionCamera_setUp);
        tolua_function(tolua_S,"getUp",lua_ax_base_ActionCamera_getUp);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionCamera).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionCamera";
    g_typeCast[typeName] = "ax.ActionCamera";
    return 1;
}

int lua_ax_base_OrbitCamera_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::OrbitCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.OrbitCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::OrbitCamera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_OrbitCamera_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 7) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;
        double arg4;
        double arg5;
        double arg6;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.OrbitCamera:initWithDuration");

        ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.OrbitCamera:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_OrbitCamera_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.OrbitCamera:initWithDuration",argc, 7);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_OrbitCamera_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_OrbitCamera_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.OrbitCamera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 7)
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;
        double arg4;
        double arg5;
        double arg6;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.OrbitCamera:create");
        ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.OrbitCamera:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_OrbitCamera_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::OrbitCamera::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        object_to_luaval<ax::OrbitCamera>(tolua_S, "ax.OrbitCamera",(ax::OrbitCamera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.OrbitCamera:create",argc, 7);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_OrbitCamera_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_OrbitCamera_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::OrbitCamera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_OrbitCamera_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::OrbitCamera();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.OrbitCamera");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.OrbitCamera:OrbitCamera",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_OrbitCamera_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_OrbitCamera_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (OrbitCamera)");
    return 0;
}

int lua_register_ax_base_OrbitCamera(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.OrbitCamera");
    tolua_cclass(tolua_S,"OrbitCamera","ax.OrbitCamera","ax.ActionCamera",nullptr);

    tolua_beginmodule(tolua_S,"OrbitCamera");
        tolua_function(tolua_S,"new",lua_ax_base_OrbitCamera_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_OrbitCamera_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_OrbitCamera_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::OrbitCamera).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.OrbitCamera";
    g_typeCast[typeName] = "ax.OrbitCamera";
    return 1;
}

int lua_ax_base_CardinalSplineTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::CardinalSplineTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CardinalSplineTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CardinalSplineTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CardinalSplineTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        ax::PointArray* arg1;
        double arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CardinalSplineTo:initWithDuration");

        ok &= luaval_to_object<ax::PointArray>(tolua_S, 3, "ax.PointArray",&arg1, "ax.CardinalSplineTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.CardinalSplineTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CardinalSplineTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CardinalSplineTo:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CardinalSplineTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CardinalSplineTo_updatePosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::CardinalSplineTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CardinalSplineTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CardinalSplineTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CardinalSplineTo_updatePosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.CardinalSplineTo:updatePosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CardinalSplineTo_updatePosition'", nullptr);
            return 0;
        }
        cobj->updatePosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CardinalSplineTo:updatePosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CardinalSplineTo_updatePosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CardinalSplineTo_getPoints(lua_State* tolua_S)
{
    int argc = 0;
    ax::CardinalSplineTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CardinalSplineTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CardinalSplineTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CardinalSplineTo_getPoints'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CardinalSplineTo_getPoints'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPoints();
        object_to_luaval<ax::PointArray>(tolua_S, "ax.PointArray",(ax::PointArray*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CardinalSplineTo:getPoints",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CardinalSplineTo_getPoints'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CardinalSplineTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CardinalSplineTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CardinalSplineTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CardinalSplineTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CardinalSplineTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CardinalSplineTo:CardinalSplineTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CardinalSplineTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CardinalSplineTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CardinalSplineTo)");
    return 0;
}

int lua_register_ax_base_CardinalSplineTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CardinalSplineTo");
    tolua_cclass(tolua_S,"CardinalSplineTo","ax.CardinalSplineTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"CardinalSplineTo");
        tolua_function(tolua_S,"new",lua_ax_base_CardinalSplineTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_CardinalSplineTo_initWithDuration);
        tolua_function(tolua_S,"updatePosition",lua_ax_base_CardinalSplineTo_updatePosition);
        tolua_function(tolua_S,"getPoints",lua_ax_base_CardinalSplineTo_getPoints);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CardinalSplineTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CardinalSplineTo";
    g_typeCast[typeName] = "ax.CardinalSplineTo";
    return 1;
}

int lua_ax_base_CardinalSplineBy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CardinalSplineBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CardinalSplineBy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CardinalSplineBy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CardinalSplineBy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CardinalSplineBy:CardinalSplineBy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CardinalSplineBy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CardinalSplineBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CardinalSplineBy)");
    return 0;
}

int lua_register_ax_base_CardinalSplineBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CardinalSplineBy");
    tolua_cclass(tolua_S,"CardinalSplineBy","ax.CardinalSplineBy","ax.CardinalSplineTo",nullptr);

    tolua_beginmodule(tolua_S,"CardinalSplineBy");
        tolua_function(tolua_S,"new",lua_ax_base_CardinalSplineBy_constructor);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CardinalSplineBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CardinalSplineBy";
    g_typeCast[typeName] = "ax.CardinalSplineBy";
    return 1;
}

int lua_ax_base_CatmullRomTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::CatmullRomTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CatmullRomTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CatmullRomTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CatmullRomTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::PointArray* arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CatmullRomTo:initWithDuration");

        ok &= luaval_to_object<ax::PointArray>(tolua_S, 3, "ax.PointArray",&arg1, "ax.CatmullRomTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CatmullRomTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CatmullRomTo:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CatmullRomTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_CatmullRomTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CatmullRomTo)");
    return 0;
}

int lua_register_ax_base_CatmullRomTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CatmullRomTo");
    tolua_cclass(tolua_S,"CatmullRomTo","ax.CatmullRomTo","ax.CardinalSplineTo",nullptr);

    tolua_beginmodule(tolua_S,"CatmullRomTo");
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_CatmullRomTo_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CatmullRomTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CatmullRomTo";
    g_typeCast[typeName] = "ax.CatmullRomTo";
    return 1;
}

int lua_ax_base_CatmullRomBy_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::CatmullRomBy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CatmullRomBy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CatmullRomBy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CatmullRomBy_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::PointArray* arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CatmullRomBy:initWithDuration");

        ok &= luaval_to_object<ax::PointArray>(tolua_S, 3, "ax.PointArray",&arg1, "ax.CatmullRomBy:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CatmullRomBy_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CatmullRomBy:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CatmullRomBy_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_CatmullRomBy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CatmullRomBy)");
    return 0;
}

int lua_register_ax_base_CatmullRomBy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CatmullRomBy");
    tolua_cclass(tolua_S,"CatmullRomBy","ax.CatmullRomBy","ax.CardinalSplineBy",nullptr);

    tolua_beginmodule(tolua_S,"CatmullRomBy");
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_CatmullRomBy_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CatmullRomBy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CatmullRomBy";
    g_typeCast[typeName] = "ax.CatmullRomBy";
    return 1;
}

int lua_ax_base_ActionEase_getInnerAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionEase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionEase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionEase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionEase_getInnerAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionEase_getInnerAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInnerAction();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionEase:getInnerAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionEase_getInnerAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionEase_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionEase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionEase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionEase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionEase_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.ActionEase:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionEase_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionEase:initWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionEase_initWithAction'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_ActionEase_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionEase)");
    return 0;
}

int lua_register_ax_base_ActionEase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionEase");
    tolua_cclass(tolua_S,"ActionEase","ax.ActionEase","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ActionEase");
        tolua_function(tolua_S,"getInnerAction",lua_ax_base_ActionEase_getInnerAction);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_ActionEase_initWithAction);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionEase).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionEase";
    g_typeCast[typeName] = "ax.ActionEase";
    return 1;
}

int lua_ax_base_EaseRateAction_setRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseRateAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseRateAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseRateAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseRateAction_setRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.EaseRateAction:setRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseRateAction_setRate'", nullptr);
            return 0;
        }
        cobj->setRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseRateAction:setRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseRateAction_setRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseRateAction_getRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseRateAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseRateAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseRateAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseRateAction_getRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseRateAction_getRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseRateAction:getRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseRateAction_getRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseRateAction_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseRateAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseRateAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseRateAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseRateAction_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ActionInterval* arg0;
        double arg1;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseRateAction:initWithAction");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseRateAction:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseRateAction_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseRateAction:initWithAction",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseRateAction_initWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseRateAction_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseRateAction",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseRateAction:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseRateAction:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseRateAction_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseRateAction::create(arg0, arg1);
        object_to_luaval<ax::EaseRateAction>(tolua_S, "ax.EaseRateAction",(ax::EaseRateAction*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseRateAction:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseRateAction_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_EaseRateAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseRateAction)");
    return 0;
}

int lua_register_ax_base_EaseRateAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseRateAction");
    tolua_cclass(tolua_S,"EaseRateAction","ax.EaseRateAction","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseRateAction");
        tolua_function(tolua_S,"setRate",lua_ax_base_EaseRateAction_setRate);
        tolua_function(tolua_S,"getRate",lua_ax_base_EaseRateAction_getRate);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_EaseRateAction_initWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_EaseRateAction_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseRateAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseRateAction";
    g_typeCast[typeName] = "ax.EaseRateAction";
    return 1;
}

int lua_ax_base_EaseExponentialIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseExponentialIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseExponentialIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseExponentialIn::create(arg0);
        object_to_luaval<ax::EaseExponentialIn>(tolua_S, "ax.EaseExponentialIn",(ax::EaseExponentialIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseExponentialIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseExponentialIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseExponentialIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseExponentialIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseExponentialIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseExponentialIn:EaseExponentialIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseExponentialIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseExponentialIn)");
    return 0;
}

int lua_register_ax_base_EaseExponentialIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseExponentialIn");
    tolua_cclass(tolua_S,"EaseExponentialIn","ax.EaseExponentialIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseExponentialIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseExponentialIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseExponentialIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseExponentialIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseExponentialIn";
    g_typeCast[typeName] = "ax.EaseExponentialIn";
    return 1;
}

int lua_ax_base_EaseExponentialOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseExponentialOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseExponentialOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseExponentialOut::create(arg0);
        object_to_luaval<ax::EaseExponentialOut>(tolua_S, "ax.EaseExponentialOut",(ax::EaseExponentialOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseExponentialOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseExponentialOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseExponentialOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseExponentialOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseExponentialOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseExponentialOut:EaseExponentialOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseExponentialOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseExponentialOut)");
    return 0;
}

int lua_register_ax_base_EaseExponentialOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseExponentialOut");
    tolua_cclass(tolua_S,"EaseExponentialOut","ax.EaseExponentialOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseExponentialOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseExponentialOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseExponentialOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseExponentialOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseExponentialOut";
    g_typeCast[typeName] = "ax.EaseExponentialOut";
    return 1;
}

int lua_ax_base_EaseExponentialInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseExponentialInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseExponentialInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseExponentialInOut::create(arg0);
        object_to_luaval<ax::EaseExponentialInOut>(tolua_S, "ax.EaseExponentialInOut",(ax::EaseExponentialInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseExponentialInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseExponentialInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseExponentialInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseExponentialInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseExponentialInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseExponentialInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseExponentialInOut:EaseExponentialInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseExponentialInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseExponentialInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseExponentialInOut)");
    return 0;
}

int lua_register_ax_base_EaseExponentialInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseExponentialInOut");
    tolua_cclass(tolua_S,"EaseExponentialInOut","ax.EaseExponentialInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseExponentialInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseExponentialInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseExponentialInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseExponentialInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseExponentialInOut";
    g_typeCast[typeName] = "ax.EaseExponentialInOut";
    return 1;
}

int lua_ax_base_EaseSineIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseSineIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseSineIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseSineIn::create(arg0);
        object_to_luaval<ax::EaseSineIn>(tolua_S, "ax.EaseSineIn",(ax::EaseSineIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseSineIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseSineIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseSineIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseSineIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseSineIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseSineIn:EaseSineIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseSineIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseSineIn)");
    return 0;
}

int lua_register_ax_base_EaseSineIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseSineIn");
    tolua_cclass(tolua_S,"EaseSineIn","ax.EaseSineIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseSineIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseSineIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseSineIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseSineIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseSineIn";
    g_typeCast[typeName] = "ax.EaseSineIn";
    return 1;
}

int lua_ax_base_EaseSineOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseSineOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseSineOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseSineOut::create(arg0);
        object_to_luaval<ax::EaseSineOut>(tolua_S, "ax.EaseSineOut",(ax::EaseSineOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseSineOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseSineOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseSineOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseSineOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseSineOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseSineOut:EaseSineOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseSineOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseSineOut)");
    return 0;
}

int lua_register_ax_base_EaseSineOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseSineOut");
    tolua_cclass(tolua_S,"EaseSineOut","ax.EaseSineOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseSineOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseSineOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseSineOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseSineOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseSineOut";
    g_typeCast[typeName] = "ax.EaseSineOut";
    return 1;
}

int lua_ax_base_EaseSineInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseSineInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseSineInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseSineInOut::create(arg0);
        object_to_luaval<ax::EaseSineInOut>(tolua_S, "ax.EaseSineInOut",(ax::EaseSineInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseSineInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseSineInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseSineInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseSineInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseSineInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseSineInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseSineInOut:EaseSineInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseSineInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseSineInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseSineInOut)");
    return 0;
}

int lua_register_ax_base_EaseSineInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseSineInOut");
    tolua_cclass(tolua_S,"EaseSineInOut","ax.EaseSineInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseSineInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseSineInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseSineInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseSineInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseSineInOut";
    g_typeCast[typeName] = "ax.EaseSineInOut";
    return 1;
}

static int lua_ax_base_EaseBounce_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBounce)");
    return 0;
}

int lua_register_ax_base_EaseBounce(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBounce");
    tolua_cclass(tolua_S,"EaseBounce","ax.EaseBounce","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBounce");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBounce).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBounce";
    g_typeCast[typeName] = "ax.EaseBounce";
    return 1;
}

int lua_ax_base_EaseBounceIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBounceIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBounceIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBounceIn::create(arg0);
        object_to_luaval<ax::EaseBounceIn>(tolua_S, "ax.EaseBounceIn",(ax::EaseBounceIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBounceIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBounceIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBounceIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBounceIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBounceIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBounceIn:EaseBounceIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBounceIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBounceIn)");
    return 0;
}

int lua_register_ax_base_EaseBounceIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBounceIn");
    tolua_cclass(tolua_S,"EaseBounceIn","ax.EaseBounceIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBounceIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBounceIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBounceIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBounceIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBounceIn";
    g_typeCast[typeName] = "ax.EaseBounceIn";
    return 1;
}

int lua_ax_base_EaseBounceOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBounceOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBounceOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBounceOut::create(arg0);
        object_to_luaval<ax::EaseBounceOut>(tolua_S, "ax.EaseBounceOut",(ax::EaseBounceOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBounceOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBounceOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBounceOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBounceOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBounceOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBounceOut:EaseBounceOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBounceOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBounceOut)");
    return 0;
}

int lua_register_ax_base_EaseBounceOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBounceOut");
    tolua_cclass(tolua_S,"EaseBounceOut","ax.EaseBounceOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBounceOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBounceOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBounceOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBounceOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBounceOut";
    g_typeCast[typeName] = "ax.EaseBounceOut";
    return 1;
}

int lua_ax_base_EaseBounceInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBounceInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBounceInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBounceInOut::create(arg0);
        object_to_luaval<ax::EaseBounceInOut>(tolua_S, "ax.EaseBounceInOut",(ax::EaseBounceInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBounceInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBounceInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBounceInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBounceInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBounceInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBounceInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBounceInOut:EaseBounceInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBounceInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBounceInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBounceInOut)");
    return 0;
}

int lua_register_ax_base_EaseBounceInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBounceInOut");
    tolua_cclass(tolua_S,"EaseBounceInOut","ax.EaseBounceInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBounceInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBounceInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBounceInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBounceInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBounceInOut";
    g_typeCast[typeName] = "ax.EaseBounceInOut";
    return 1;
}

int lua_ax_base_EaseBackIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBackIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBackIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBackIn::create(arg0);
        object_to_luaval<ax::EaseBackIn>(tolua_S, "ax.EaseBackIn",(ax::EaseBackIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBackIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBackIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBackIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBackIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBackIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBackIn:EaseBackIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBackIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBackIn)");
    return 0;
}

int lua_register_ax_base_EaseBackIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBackIn");
    tolua_cclass(tolua_S,"EaseBackIn","ax.EaseBackIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBackIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBackIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBackIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBackIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBackIn";
    g_typeCast[typeName] = "ax.EaseBackIn";
    return 1;
}

int lua_ax_base_EaseBackOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBackOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBackOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBackOut::create(arg0);
        object_to_luaval<ax::EaseBackOut>(tolua_S, "ax.EaseBackOut",(ax::EaseBackOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBackOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBackOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBackOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBackOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBackOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBackOut:EaseBackOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBackOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBackOut)");
    return 0;
}

int lua_register_ax_base_EaseBackOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBackOut");
    tolua_cclass(tolua_S,"EaseBackOut","ax.EaseBackOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBackOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBackOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBackOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBackOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBackOut";
    g_typeCast[typeName] = "ax.EaseBackOut";
    return 1;
}

int lua_ax_base_EaseBackInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBackInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBackInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBackInOut::create(arg0);
        object_to_luaval<ax::EaseBackInOut>(tolua_S, "ax.EaseBackInOut",(ax::EaseBackInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBackInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBackInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBackInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBackInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBackInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBackInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBackInOut:EaseBackInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBackInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBackInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBackInOut)");
    return 0;
}

int lua_register_ax_base_EaseBackInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBackInOut");
    tolua_cclass(tolua_S,"EaseBackInOut","ax.EaseBackInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBackInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBackInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBackInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBackInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBackInOut";
    g_typeCast[typeName] = "ax.EaseBackInOut";
    return 1;
}

int lua_ax_base_EaseQuadraticActionIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuadraticActionIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuadraticActionIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuadraticActionIn::create(arg0);
        object_to_luaval<ax::EaseQuadraticActionIn>(tolua_S, "ax.EaseQuadraticActionIn",(ax::EaseQuadraticActionIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuadraticActionIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuadraticActionIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuadraticActionIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuadraticActionIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuadraticActionIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuadraticActionIn:EaseQuadraticActionIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuadraticActionIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuadraticActionIn)");
    return 0;
}

int lua_register_ax_base_EaseQuadraticActionIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuadraticActionIn");
    tolua_cclass(tolua_S,"EaseQuadraticActionIn","ax.EaseQuadraticActionIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuadraticActionIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuadraticActionIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuadraticActionIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuadraticActionIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuadraticActionIn";
    g_typeCast[typeName] = "ax.EaseQuadraticActionIn";
    return 1;
}

int lua_ax_base_EaseQuadraticActionOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuadraticActionOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuadraticActionOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuadraticActionOut::create(arg0);
        object_to_luaval<ax::EaseQuadraticActionOut>(tolua_S, "ax.EaseQuadraticActionOut",(ax::EaseQuadraticActionOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuadraticActionOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuadraticActionOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuadraticActionOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuadraticActionOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuadraticActionOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuadraticActionOut:EaseQuadraticActionOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuadraticActionOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuadraticActionOut)");
    return 0;
}

int lua_register_ax_base_EaseQuadraticActionOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuadraticActionOut");
    tolua_cclass(tolua_S,"EaseQuadraticActionOut","ax.EaseQuadraticActionOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuadraticActionOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuadraticActionOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuadraticActionOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuadraticActionOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuadraticActionOut";
    g_typeCast[typeName] = "ax.EaseQuadraticActionOut";
    return 1;
}

int lua_ax_base_EaseQuadraticActionInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuadraticActionInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuadraticActionInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuadraticActionInOut::create(arg0);
        object_to_luaval<ax::EaseQuadraticActionInOut>(tolua_S, "ax.EaseQuadraticActionInOut",(ax::EaseQuadraticActionInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuadraticActionInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuadraticActionInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuadraticActionInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuadraticActionInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuadraticActionInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuadraticActionInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuadraticActionInOut:EaseQuadraticActionInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuadraticActionInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuadraticActionInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuadraticActionInOut)");
    return 0;
}

int lua_register_ax_base_EaseQuadraticActionInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuadraticActionInOut");
    tolua_cclass(tolua_S,"EaseQuadraticActionInOut","ax.EaseQuadraticActionInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuadraticActionInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuadraticActionInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuadraticActionInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuadraticActionInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuadraticActionInOut";
    g_typeCast[typeName] = "ax.EaseQuadraticActionInOut";
    return 1;
}

int lua_ax_base_EaseQuarticActionIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuarticActionIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuarticActionIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuarticActionIn::create(arg0);
        object_to_luaval<ax::EaseQuarticActionIn>(tolua_S, "ax.EaseQuarticActionIn",(ax::EaseQuarticActionIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuarticActionIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuarticActionIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuarticActionIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuarticActionIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuarticActionIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuarticActionIn:EaseQuarticActionIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuarticActionIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuarticActionIn)");
    return 0;
}

int lua_register_ax_base_EaseQuarticActionIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuarticActionIn");
    tolua_cclass(tolua_S,"EaseQuarticActionIn","ax.EaseQuarticActionIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuarticActionIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuarticActionIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuarticActionIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuarticActionIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuarticActionIn";
    g_typeCast[typeName] = "ax.EaseQuarticActionIn";
    return 1;
}

int lua_ax_base_EaseQuarticActionOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuarticActionOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuarticActionOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuarticActionOut::create(arg0);
        object_to_luaval<ax::EaseQuarticActionOut>(tolua_S, "ax.EaseQuarticActionOut",(ax::EaseQuarticActionOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuarticActionOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuarticActionOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuarticActionOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuarticActionOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuarticActionOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuarticActionOut:EaseQuarticActionOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuarticActionOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuarticActionOut)");
    return 0;
}

int lua_register_ax_base_EaseQuarticActionOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuarticActionOut");
    tolua_cclass(tolua_S,"EaseQuarticActionOut","ax.EaseQuarticActionOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuarticActionOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuarticActionOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuarticActionOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuarticActionOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuarticActionOut";
    g_typeCast[typeName] = "ax.EaseQuarticActionOut";
    return 1;
}

int lua_ax_base_EaseQuarticActionInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuarticActionInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuarticActionInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuarticActionInOut::create(arg0);
        object_to_luaval<ax::EaseQuarticActionInOut>(tolua_S, "ax.EaseQuarticActionInOut",(ax::EaseQuarticActionInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuarticActionInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuarticActionInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuarticActionInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuarticActionInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuarticActionInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuarticActionInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuarticActionInOut:EaseQuarticActionInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuarticActionInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuarticActionInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuarticActionInOut)");
    return 0;
}

int lua_register_ax_base_EaseQuarticActionInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuarticActionInOut");
    tolua_cclass(tolua_S,"EaseQuarticActionInOut","ax.EaseQuarticActionInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuarticActionInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuarticActionInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuarticActionInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuarticActionInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuarticActionInOut";
    g_typeCast[typeName] = "ax.EaseQuarticActionInOut";
    return 1;
}

int lua_ax_base_EaseQuinticActionIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuinticActionIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuinticActionIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuinticActionIn::create(arg0);
        object_to_luaval<ax::EaseQuinticActionIn>(tolua_S, "ax.EaseQuinticActionIn",(ax::EaseQuinticActionIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuinticActionIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuinticActionIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuinticActionIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuinticActionIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuinticActionIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuinticActionIn:EaseQuinticActionIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuinticActionIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuinticActionIn)");
    return 0;
}

int lua_register_ax_base_EaseQuinticActionIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuinticActionIn");
    tolua_cclass(tolua_S,"EaseQuinticActionIn","ax.EaseQuinticActionIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuinticActionIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuinticActionIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuinticActionIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuinticActionIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuinticActionIn";
    g_typeCast[typeName] = "ax.EaseQuinticActionIn";
    return 1;
}

int lua_ax_base_EaseQuinticActionOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuinticActionOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuinticActionOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuinticActionOut::create(arg0);
        object_to_luaval<ax::EaseQuinticActionOut>(tolua_S, "ax.EaseQuinticActionOut",(ax::EaseQuinticActionOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuinticActionOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuinticActionOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuinticActionOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuinticActionOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuinticActionOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuinticActionOut:EaseQuinticActionOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuinticActionOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuinticActionOut)");
    return 0;
}

int lua_register_ax_base_EaseQuinticActionOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuinticActionOut");
    tolua_cclass(tolua_S,"EaseQuinticActionOut","ax.EaseQuinticActionOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuinticActionOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuinticActionOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuinticActionOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuinticActionOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuinticActionOut";
    g_typeCast[typeName] = "ax.EaseQuinticActionOut";
    return 1;
}

int lua_ax_base_EaseQuinticActionInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseQuinticActionInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseQuinticActionInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseQuinticActionInOut::create(arg0);
        object_to_luaval<ax::EaseQuinticActionInOut>(tolua_S, "ax.EaseQuinticActionInOut",(ax::EaseQuinticActionInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseQuinticActionInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseQuinticActionInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseQuinticActionInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseQuinticActionInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseQuinticActionInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseQuinticActionInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseQuinticActionInOut:EaseQuinticActionInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseQuinticActionInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseQuinticActionInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseQuinticActionInOut)");
    return 0;
}

int lua_register_ax_base_EaseQuinticActionInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseQuinticActionInOut");
    tolua_cclass(tolua_S,"EaseQuinticActionInOut","ax.EaseQuinticActionInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseQuinticActionInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseQuinticActionInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseQuinticActionInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseQuinticActionInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseQuinticActionInOut";
    g_typeCast[typeName] = "ax.EaseQuinticActionInOut";
    return 1;
}

int lua_ax_base_EaseCircleActionIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCircleActionIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCircleActionIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCircleActionIn::create(arg0);
        object_to_luaval<ax::EaseCircleActionIn>(tolua_S, "ax.EaseCircleActionIn",(ax::EaseCircleActionIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCircleActionIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCircleActionIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCircleActionIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCircleActionIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCircleActionIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCircleActionIn:EaseCircleActionIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCircleActionIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCircleActionIn)");
    return 0;
}

int lua_register_ax_base_EaseCircleActionIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCircleActionIn");
    tolua_cclass(tolua_S,"EaseCircleActionIn","ax.EaseCircleActionIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCircleActionIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCircleActionIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCircleActionIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCircleActionIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCircleActionIn";
    g_typeCast[typeName] = "ax.EaseCircleActionIn";
    return 1;
}

int lua_ax_base_EaseCircleActionOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCircleActionOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCircleActionOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCircleActionOut::create(arg0);
        object_to_luaval<ax::EaseCircleActionOut>(tolua_S, "ax.EaseCircleActionOut",(ax::EaseCircleActionOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCircleActionOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCircleActionOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCircleActionOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCircleActionOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCircleActionOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCircleActionOut:EaseCircleActionOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCircleActionOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCircleActionOut)");
    return 0;
}

int lua_register_ax_base_EaseCircleActionOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCircleActionOut");
    tolua_cclass(tolua_S,"EaseCircleActionOut","ax.EaseCircleActionOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCircleActionOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCircleActionOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCircleActionOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCircleActionOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCircleActionOut";
    g_typeCast[typeName] = "ax.EaseCircleActionOut";
    return 1;
}

int lua_ax_base_EaseCircleActionInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCircleActionInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCircleActionInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCircleActionInOut::create(arg0);
        object_to_luaval<ax::EaseCircleActionInOut>(tolua_S, "ax.EaseCircleActionInOut",(ax::EaseCircleActionInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCircleActionInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCircleActionInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCircleActionInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCircleActionInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCircleActionInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCircleActionInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCircleActionInOut:EaseCircleActionInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCircleActionInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCircleActionInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCircleActionInOut)");
    return 0;
}

int lua_register_ax_base_EaseCircleActionInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCircleActionInOut");
    tolua_cclass(tolua_S,"EaseCircleActionInOut","ax.EaseCircleActionInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCircleActionInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCircleActionInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCircleActionInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCircleActionInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCircleActionInOut";
    g_typeCast[typeName] = "ax.EaseCircleActionInOut";
    return 1;
}

int lua_ax_base_EaseCubicActionIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCubicActionIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCubicActionIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCubicActionIn::create(arg0);
        object_to_luaval<ax::EaseCubicActionIn>(tolua_S, "ax.EaseCubicActionIn",(ax::EaseCubicActionIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCubicActionIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCubicActionIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCubicActionIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCubicActionIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCubicActionIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCubicActionIn:EaseCubicActionIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCubicActionIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCubicActionIn)");
    return 0;
}

int lua_register_ax_base_EaseCubicActionIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCubicActionIn");
    tolua_cclass(tolua_S,"EaseCubicActionIn","ax.EaseCubicActionIn","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCubicActionIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCubicActionIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCubicActionIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCubicActionIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCubicActionIn";
    g_typeCast[typeName] = "ax.EaseCubicActionIn";
    return 1;
}

int lua_ax_base_EaseCubicActionOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCubicActionOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCubicActionOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCubicActionOut::create(arg0);
        object_to_luaval<ax::EaseCubicActionOut>(tolua_S, "ax.EaseCubicActionOut",(ax::EaseCubicActionOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCubicActionOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCubicActionOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCubicActionOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCubicActionOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCubicActionOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCubicActionOut:EaseCubicActionOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCubicActionOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCubicActionOut)");
    return 0;
}

int lua_register_ax_base_EaseCubicActionOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCubicActionOut");
    tolua_cclass(tolua_S,"EaseCubicActionOut","ax.EaseCubicActionOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCubicActionOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCubicActionOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCubicActionOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCubicActionOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCubicActionOut";
    g_typeCast[typeName] = "ax.EaseCubicActionOut";
    return 1;
}

int lua_ax_base_EaseCubicActionInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseCubicActionInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseCubicActionInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseCubicActionInOut::create(arg0);
        object_to_luaval<ax::EaseCubicActionInOut>(tolua_S, "ax.EaseCubicActionInOut",(ax::EaseCubicActionInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseCubicActionInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseCubicActionInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseCubicActionInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseCubicActionInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseCubicActionInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseCubicActionInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseCubicActionInOut:EaseCubicActionInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseCubicActionInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseCubicActionInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseCubicActionInOut)");
    return 0;
}

int lua_register_ax_base_EaseCubicActionInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseCubicActionInOut");
    tolua_cclass(tolua_S,"EaseCubicActionInOut","ax.EaseCubicActionInOut","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseCubicActionInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseCubicActionInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseCubicActionInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseCubicActionInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseCubicActionInOut";
    g_typeCast[typeName] = "ax.EaseCubicActionInOut";
    return 1;
}

int lua_ax_base_EaseIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseIn:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseIn::create(arg0, arg1);
        object_to_luaval<ax::EaseIn>(tolua_S, "ax.EaseIn",(ax::EaseIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseIn:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseIn:EaseIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseIn)");
    return 0;
}

int lua_register_ax_base_EaseIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseIn");
    tolua_cclass(tolua_S,"EaseIn","ax.EaseIn","ax.EaseRateAction",nullptr);

    tolua_beginmodule(tolua_S,"EaseIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseIn";
    g_typeCast[typeName] = "ax.EaseIn";
    return 1;
}

int lua_ax_base_EaseOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseOut:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseOut::create(arg0, arg1);
        object_to_luaval<ax::EaseOut>(tolua_S, "ax.EaseOut",(ax::EaseOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseOut:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseOut:EaseOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseOut)");
    return 0;
}

int lua_register_ax_base_EaseOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseOut");
    tolua_cclass(tolua_S,"EaseOut","ax.EaseOut","ax.EaseRateAction",nullptr);

    tolua_beginmodule(tolua_S,"EaseOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseOut";
    g_typeCast[typeName] = "ax.EaseOut";
    return 1;
}

int lua_ax_base_EaseInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseInOut:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseInOut::create(arg0, arg1);
        object_to_luaval<ax::EaseInOut>(tolua_S, "ax.EaseInOut",(ax::EaseInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseInOut:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseInOut:EaseInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseInOut)");
    return 0;
}

int lua_register_ax_base_EaseInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseInOut");
    tolua_cclass(tolua_S,"EaseInOut","ax.EaseInOut","ax.EaseRateAction",nullptr);

    tolua_beginmodule(tolua_S,"EaseInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseInOut";
    g_typeCast[typeName] = "ax.EaseInOut";
    return 1;
}

int lua_ax_base_EaseElastic_getPeriod(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElastic* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseElastic",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseElastic*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseElastic_getPeriod'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElastic_getPeriod'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPeriod();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElastic:getPeriod",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElastic_getPeriod'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseElastic_setPeriod(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElastic* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseElastic",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseElastic*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseElastic_setPeriod'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.EaseElastic:setPeriod");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElastic_setPeriod'", nullptr);
            return 0;
        }
        cobj->setPeriod(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElastic:setPeriod",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElastic_setPeriod'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseElastic_initWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElastic* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseElastic",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseElastic*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseElastic_initWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElastic:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElastic_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        ax::ActionInterval* arg0;
        double arg1;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElastic:initWithAction");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseElastic:initWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElastic_initWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithAction(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElastic:initWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElastic_initWithAction'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_EaseElastic_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseElastic)");
    return 0;
}

int lua_register_ax_base_EaseElastic(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseElastic");
    tolua_cclass(tolua_S,"EaseElastic","ax.EaseElastic","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseElastic");
        tolua_function(tolua_S,"getPeriod",lua_ax_base_EaseElastic_getPeriod);
        tolua_function(tolua_S,"setPeriod",lua_ax_base_EaseElastic_setPeriod);
        tolua_function(tolua_S,"initWithAction",lua_ax_base_EaseElastic_initWithAction);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseElastic).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseElastic";
    g_typeCast[typeName] = "ax.EaseElastic";
    return 1;
}

int lua_ax_base_EaseElasticIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseElasticIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticIn::create(arg0);
        object_to_luaval<ax::EaseElasticIn>(tolua_S, "ax.EaseElasticIn",(ax::EaseElasticIn*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticIn:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseElasticIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticIn::create(arg0, arg1);
        object_to_luaval<ax::EaseElasticIn>(tolua_S, "ax.EaseElasticIn",(ax::EaseElasticIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseElasticIn:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseElasticIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElasticIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseElasticIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseElasticIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElasticIn:EaseElasticIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseElasticIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseElasticIn)");
    return 0;
}

int lua_register_ax_base_EaseElasticIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseElasticIn");
    tolua_cclass(tolua_S,"EaseElasticIn","ax.EaseElasticIn","ax.EaseElastic",nullptr);

    tolua_beginmodule(tolua_S,"EaseElasticIn");
        tolua_function(tolua_S,"new",lua_ax_base_EaseElasticIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseElasticIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseElasticIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseElasticIn";
    g_typeCast[typeName] = "ax.EaseElasticIn";
    return 1;
}

int lua_ax_base_EaseElasticOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseElasticOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticOut::create(arg0);
        object_to_luaval<ax::EaseElasticOut>(tolua_S, "ax.EaseElasticOut",(ax::EaseElasticOut*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticOut:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseElasticOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticOut::create(arg0, arg1);
        object_to_luaval<ax::EaseElasticOut>(tolua_S, "ax.EaseElasticOut",(ax::EaseElasticOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseElasticOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseElasticOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElasticOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseElasticOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseElasticOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElasticOut:EaseElasticOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseElasticOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseElasticOut)");
    return 0;
}

int lua_register_ax_base_EaseElasticOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseElasticOut");
    tolua_cclass(tolua_S,"EaseElasticOut","ax.EaseElasticOut","ax.EaseElastic",nullptr);

    tolua_beginmodule(tolua_S,"EaseElasticOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseElasticOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseElasticOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseElasticOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseElasticOut";
    g_typeCast[typeName] = "ax.EaseElasticOut";
    return 1;
}

int lua_ax_base_EaseElasticInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseElasticInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticInOut::create(arg0);
        object_to_luaval<ax::EaseElasticInOut>(tolua_S, "ax.EaseElasticInOut",(ax::EaseElasticInOut*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::ActionInterval* arg0;
        double arg1;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseElasticInOut:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseElasticInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseElasticInOut::create(arg0, arg1);
        object_to_luaval<ax::EaseElasticInOut>(tolua_S, "ax.EaseElasticInOut",(ax::EaseElasticInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseElasticInOut:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseElasticInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseElasticInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseElasticInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseElasticInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseElasticInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseElasticInOut:EaseElasticInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseElasticInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseElasticInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseElasticInOut)");
    return 0;
}

int lua_register_ax_base_EaseElasticInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseElasticInOut");
    tolua_cclass(tolua_S,"EaseElasticInOut","ax.EaseElasticInOut","ax.EaseElastic",nullptr);

    tolua_beginmodule(tolua_S,"EaseElasticInOut");
        tolua_function(tolua_S,"new",lua_ax_base_EaseElasticInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_EaseElasticInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseElasticInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseElasticInOut";
    g_typeCast[typeName] = "ax.EaseElasticInOut";
    return 1;
}

int lua_ax_base_EaseBezierAction_setBezierParamer(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBezierAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.EaseBezierAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::EaseBezierAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_EaseBezierAction_setBezierParamer'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.EaseBezierAction:setBezierParamer");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.EaseBezierAction:setBezierParamer");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.EaseBezierAction:setBezierParamer");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.EaseBezierAction:setBezierParamer");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBezierAction_setBezierParamer'", nullptr);
            return 0;
        }
        cobj->setBezierParamer(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBezierAction:setBezierParamer",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBezierAction_setBezierParamer'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_EaseBezierAction_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.EaseBezierAction",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::ActionInterval* arg0;
        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.EaseBezierAction:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBezierAction_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::EaseBezierAction::create(arg0);
        object_to_luaval<ax::EaseBezierAction>(tolua_S, "ax.EaseBezierAction",(ax::EaseBezierAction*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.EaseBezierAction:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBezierAction_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_EaseBezierAction_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::EaseBezierAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_EaseBezierAction_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::EaseBezierAction();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.EaseBezierAction");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.EaseBezierAction:EaseBezierAction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_EaseBezierAction_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_EaseBezierAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (EaseBezierAction)");
    return 0;
}

int lua_register_ax_base_EaseBezierAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.EaseBezierAction");
    tolua_cclass(tolua_S,"EaseBezierAction","ax.EaseBezierAction","ax.ActionEase",nullptr);

    tolua_beginmodule(tolua_S,"EaseBezierAction");
        tolua_function(tolua_S,"new",lua_ax_base_EaseBezierAction_constructor);
        tolua_function(tolua_S,"setBezierParamer",lua_ax_base_EaseBezierAction_setBezierParamer);
        tolua_function(tolua_S,"create", lua_ax_base_EaseBezierAction_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::EaseBezierAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.EaseBezierAction";
    g_typeCast[typeName] = "ax.EaseBezierAction";
    return 1;
}

static int lua_ax_base_ActionInstant_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionInstant)");
    return 0;
}

int lua_register_ax_base_ActionInstant(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionInstant");
    tolua_cclass(tolua_S,"ActionInstant","ax.ActionInstant","ax.FiniteTimeAction",nullptr);

    tolua_beginmodule(tolua_S,"ActionInstant");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionInstant).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionInstant";
    g_typeCast[typeName] = "ax.ActionInstant";
    return 1;
}

int lua_ax_base_Show_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Show",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Show_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Show::create();
        object_to_luaval<ax::Show>(tolua_S, "ax.Show",(ax::Show*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Show:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Show_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Show_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Show* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Show_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Show();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Show");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Show:Show",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Show_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Show_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Show)");
    return 0;
}

int lua_register_ax_base_Show(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Show");
    tolua_cclass(tolua_S,"Show","ax.Show","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"Show");
        tolua_function(tolua_S,"new",lua_ax_base_Show_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_Show_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Show).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Show";
    g_typeCast[typeName] = "ax.Show";
    return 1;
}

int lua_ax_base_Hide_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Hide",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Hide_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Hide::create();
        object_to_luaval<ax::Hide>(tolua_S, "ax.Hide",(ax::Hide*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Hide:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Hide_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Hide_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Hide* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Hide_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Hide();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Hide");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Hide:Hide",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Hide_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Hide_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Hide)");
    return 0;
}

int lua_register_ax_base_Hide(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Hide");
    tolua_cclass(tolua_S,"Hide","ax.Hide","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"Hide");
        tolua_function(tolua_S,"new",lua_ax_base_Hide_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_Hide_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Hide).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Hide";
    g_typeCast[typeName] = "ax.Hide";
    return 1;
}

int lua_ax_base_ToggleVisibility_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ToggleVisibility",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ToggleVisibility_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ToggleVisibility::create();
        object_to_luaval<ax::ToggleVisibility>(tolua_S, "ax.ToggleVisibility",(ax::ToggleVisibility*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ToggleVisibility:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ToggleVisibility_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ToggleVisibility_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ToggleVisibility* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ToggleVisibility_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ToggleVisibility();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ToggleVisibility");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ToggleVisibility:ToggleVisibility",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ToggleVisibility_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ToggleVisibility_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ToggleVisibility)");
    return 0;
}

int lua_register_ax_base_ToggleVisibility(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ToggleVisibility");
    tolua_cclass(tolua_S,"ToggleVisibility","ax.ToggleVisibility","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"ToggleVisibility");
        tolua_function(tolua_S,"new",lua_ax_base_ToggleVisibility_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_ToggleVisibility_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ToggleVisibility).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ToggleVisibility";
    g_typeCast[typeName] = "ax.ToggleVisibility";
    return 1;
}

int lua_ax_base_RemoveSelf_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::RemoveSelf* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RemoveSelf",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RemoveSelf*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RemoveSelf_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.RemoveSelf:init");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RemoveSelf_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RemoveSelf:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RemoveSelf_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RemoveSelf_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.RemoveSelf",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RemoveSelf_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::RemoveSelf::create();
        object_to_luaval<ax::RemoveSelf>(tolua_S, "ax.RemoveSelf",(ax::RemoveSelf*)ret);
        return 1;
    }
    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.RemoveSelf:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RemoveSelf_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::RemoveSelf::create(arg0);
        object_to_luaval<ax::RemoveSelf>(tolua_S, "ax.RemoveSelf",(ax::RemoveSelf*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.RemoveSelf:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RemoveSelf_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_RemoveSelf_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RemoveSelf* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RemoveSelf_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::RemoveSelf();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.RemoveSelf");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RemoveSelf:RemoveSelf",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RemoveSelf_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_RemoveSelf_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RemoveSelf)");
    return 0;
}

int lua_register_ax_base_RemoveSelf(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RemoveSelf");
    tolua_cclass(tolua_S,"RemoveSelf","ax.RemoveSelf","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"RemoveSelf");
        tolua_function(tolua_S,"new",lua_ax_base_RemoveSelf_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_RemoveSelf_init);
        tolua_function(tolua_S,"create", lua_ax_base_RemoveSelf_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RemoveSelf).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RemoveSelf";
    g_typeCast[typeName] = "ax.RemoveSelf";
    return 1;
}

int lua_ax_base_FlipX_initWithFlipX(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipX* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FlipX",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FlipX*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FlipX_initWithFlipX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FlipX:initWithFlipX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX_initWithFlipX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFlipX(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipX:initWithFlipX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX_initWithFlipX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FlipX_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FlipX",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FlipX:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FlipX::create(arg0);
        object_to_luaval<ax::FlipX>(tolua_S, "ax.FlipX",(ax::FlipX*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FlipX:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FlipX_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipX* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FlipX();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FlipX");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipX:FlipX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FlipX_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FlipX)");
    return 0;
}

int lua_register_ax_base_FlipX(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FlipX");
    tolua_cclass(tolua_S,"FlipX","ax.FlipX","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"FlipX");
        tolua_function(tolua_S,"new",lua_ax_base_FlipX_constructor);
        tolua_function(tolua_S,"initWithFlipX",lua_ax_base_FlipX_initWithFlipX);
        tolua_function(tolua_S,"create", lua_ax_base_FlipX_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FlipX).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FlipX";
    g_typeCast[typeName] = "ax.FlipX";
    return 1;
}

int lua_ax_base_FlipY_initWithFlipY(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipY* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FlipY",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FlipY*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FlipY_initWithFlipY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FlipY:initWithFlipY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipY_initWithFlipY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFlipY(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipY:initWithFlipY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipY_initWithFlipY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FlipY_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FlipY",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FlipY:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipY_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FlipY::create(arg0);
        object_to_luaval<ax::FlipY>(tolua_S, "ax.FlipY",(ax::FlipY*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FlipY:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipY_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FlipY_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipY* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipY_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FlipY();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FlipY");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipY:FlipY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipY_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FlipY_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FlipY)");
    return 0;
}

int lua_register_ax_base_FlipY(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FlipY");
    tolua_cclass(tolua_S,"FlipY","ax.FlipY","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"FlipY");
        tolua_function(tolua_S,"new",lua_ax_base_FlipY_constructor);
        tolua_function(tolua_S,"initWithFlipY",lua_ax_base_FlipY_initWithFlipY);
        tolua_function(tolua_S,"create", lua_ax_base_FlipY_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FlipY).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FlipY";
    g_typeCast[typeName] = "ax.FlipY";
    return 1;
}

int lua_ax_base_Place_initWithPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Place* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Place",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Place*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Place_initWithPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Place:initWithPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Place_initWithPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithPosition(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Place:initWithPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Place_initWithPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Place_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Place",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Vec2 arg0;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Place:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Place_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Place::create(arg0);
        object_to_luaval<ax::Place>(tolua_S, "ax.Place",(ax::Place*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Place:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Place_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Place_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Place* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Place_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Place();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Place");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Place:Place",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Place_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Place_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Place)");
    return 0;
}

int lua_register_ax_base_Place(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Place");
    tolua_cclass(tolua_S,"Place","ax.Place","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"Place");
        tolua_function(tolua_S,"new",lua_ax_base_Place_constructor);
        tolua_function(tolua_S,"initWithPosition",lua_ax_base_Place_initWithPosition);
        tolua_function(tolua_S,"create", lua_ax_base_Place_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Place).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Place";
    g_typeCast[typeName] = "ax.Place";
    return 1;
}

int lua_ax_base_CallFunc_execute(lua_State* tolua_S)
{
    int argc = 0;
    ax::CallFunc* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CallFunc",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CallFunc*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CallFunc_execute'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CallFunc_execute'", nullptr);
            return 0;
        }
        cobj->execute();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CallFunc:execute",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CallFunc_execute'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CallFunc_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CallFunc* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CallFunc_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CallFunc();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CallFunc");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CallFunc:CallFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CallFunc_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CallFunc_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CallFunc)");
    return 0;
}

int lua_register_ax_base_CallFunc(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CallFunc");
    tolua_cclass(tolua_S,"CallFunc","ax.CallFunc","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"CallFunc");
        tolua_function(tolua_S,"new",lua_ax_base_CallFunc_constructor);
        tolua_function(tolua_S,"execute",lua_ax_base_CallFunc_execute);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CallFunc).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CallFunc";
    g_typeCast[typeName] = "ax.CallFunc";
    return 1;
}

int lua_ax_base_GridAction_getGrid(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridAction_getGrid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridAction_getGrid'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGrid();
        object_to_luaval<ax::GridBase>(tolua_S, "ax.GridBase",(ax::GridBase*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridAction:getGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridAction_getGrid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridAction_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridAction_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::Vec2 arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.GridAction:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.GridAction:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridAction_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridAction:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridAction_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_GridAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (GridAction)");
    return 0;
}

int lua_register_ax_base_GridAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.GridAction");
    tolua_cclass(tolua_S,"GridAction","ax.GridAction","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"GridAction");
        tolua_function(tolua_S,"getGrid",lua_ax_base_GridAction_getGrid);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_GridAction_initWithDuration);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::GridAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.GridAction";
    g_typeCast[typeName] = "ax.GridAction";
    return 1;
}

int lua_ax_base_Grid3DAction_getGridRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Grid3DAction* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Grid3DAction",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Grid3DAction*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Grid3DAction_getGridRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Grid3DAction_getGridRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGridRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Grid3DAction:getGridRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Grid3DAction_getGridRect'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_Grid3DAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Grid3DAction)");
    return 0;
}

int lua_register_ax_base_Grid3DAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Grid3DAction");
    tolua_cclass(tolua_S,"Grid3DAction","ax.Grid3DAction","ax.GridAction",nullptr);

    tolua_beginmodule(tolua_S,"Grid3DAction");
        tolua_function(tolua_S,"getGridRect",lua_ax_base_Grid3DAction_getGridRect);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Grid3DAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Grid3DAction";
    g_typeCast[typeName] = "ax.Grid3DAction";
    return 1;
}

static int lua_ax_base_TiledGrid3DAction_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TiledGrid3DAction)");
    return 0;
}

int lua_register_ax_base_TiledGrid3DAction(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TiledGrid3DAction");
    tolua_cclass(tolua_S,"TiledGrid3DAction","ax.TiledGrid3DAction","ax.GridAction",nullptr);

    tolua_beginmodule(tolua_S,"TiledGrid3DAction");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TiledGrid3DAction).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TiledGrid3DAction";
    g_typeCast[typeName] = "ax.TiledGrid3DAction";
    return 1;
}

int lua_ax_base_StopGrid_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.StopGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_StopGrid_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::StopGrid::create();
        object_to_luaval<ax::StopGrid>(tolua_S, "ax.StopGrid",(ax::StopGrid*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.StopGrid:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_StopGrid_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_StopGrid_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::StopGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_StopGrid_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::StopGrid();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.StopGrid");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.StopGrid:StopGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_StopGrid_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_StopGrid_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (StopGrid)");
    return 0;
}

int lua_register_ax_base_StopGrid(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.StopGrid");
    tolua_cclass(tolua_S,"StopGrid","ax.StopGrid","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"StopGrid");
        tolua_function(tolua_S,"new",lua_ax_base_StopGrid_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_StopGrid_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::StopGrid).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.StopGrid";
    g_typeCast[typeName] = "ax.StopGrid";
    return 1;
}

int lua_ax_base_ReuseGrid_initWithTimes(lua_State* tolua_S)
{
    int argc = 0;
    ax::ReuseGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ReuseGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ReuseGrid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ReuseGrid_initWithTimes'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ReuseGrid:initWithTimes");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ReuseGrid_initWithTimes'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTimes(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ReuseGrid:initWithTimes",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ReuseGrid_initWithTimes'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ReuseGrid_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ReuseGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ReuseGrid:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ReuseGrid_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ReuseGrid::create(arg0);
        object_to_luaval<ax::ReuseGrid>(tolua_S, "ax.ReuseGrid",(ax::ReuseGrid*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ReuseGrid:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ReuseGrid_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ReuseGrid_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ReuseGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ReuseGrid_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ReuseGrid();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ReuseGrid");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ReuseGrid:ReuseGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ReuseGrid_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ReuseGrid_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ReuseGrid)");
    return 0;
}

int lua_register_ax_base_ReuseGrid(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ReuseGrid");
    tolua_cclass(tolua_S,"ReuseGrid","ax.ReuseGrid","ax.ActionInstant",nullptr);

    tolua_beginmodule(tolua_S,"ReuseGrid");
        tolua_function(tolua_S,"new",lua_ax_base_ReuseGrid_constructor);
        tolua_function(tolua_S,"initWithTimes",lua_ax_base_ReuseGrid_initWithTimes);
        tolua_function(tolua_S,"create", lua_ax_base_ReuseGrid_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ReuseGrid).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ReuseGrid";
    g_typeCast[typeName] = "ax.ReuseGrid";
    return 1;
}

int lua_ax_base_Waves3D_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves3D_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves3D_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves3D_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves3D:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves3D_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves3D_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves3D_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves3D_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves3D:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Waves3D:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Waves3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Waves3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Waves3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Waves3D:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Waves3D:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Waves3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Waves3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Waves3D>(tolua_S, "ax.Waves3D",(ax::Waves3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Waves3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Waves3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Waves3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Waves3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves3D:Waves3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Waves3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Waves3D)");
    return 0;
}

int lua_register_ax_base_Waves3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Waves3D");
    tolua_cclass(tolua_S,"Waves3D","ax.Waves3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Waves3D");
        tolua_function(tolua_S,"new",lua_ax_base_Waves3D_constructor);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_Waves3D_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_Waves3D_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_Waves3D_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_Waves3D_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Waves3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Waves3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Waves3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Waves3D";
    g_typeCast[typeName] = "ax.Waves3D";
    return 1;
}

int lua_ax_base_FlipX3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipX3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FlipX3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FlipX3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FlipX3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FlipX3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipX3D:initWithDuration",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FlipX3D_initWithSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipX3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FlipX3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FlipX3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FlipX3D_initWithSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Vec2 arg0;
        double arg1;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FlipX3D:initWithSize");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.FlipX3D:initWithSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX3D_initWithSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSize(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipX3D:initWithSize",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX3D_initWithSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FlipX3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FlipX3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FlipX3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FlipX3D::create(arg0);
        object_to_luaval<ax::FlipX3D>(tolua_S, "ax.FlipX3D",(ax::FlipX3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FlipX3D:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FlipX3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipX3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipX3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FlipX3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FlipX3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipX3D:FlipX3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipX3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FlipX3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FlipX3D)");
    return 0;
}

int lua_register_ax_base_FlipX3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FlipX3D");
    tolua_cclass(tolua_S,"FlipX3D","ax.FlipX3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"FlipX3D");
        tolua_function(tolua_S,"new",lua_ax_base_FlipX3D_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_FlipX3D_initWithDuration);
        tolua_function(tolua_S,"initWithSize",lua_ax_base_FlipX3D_initWithSize);
        tolua_function(tolua_S,"create", lua_ax_base_FlipX3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FlipX3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FlipX3D";
    g_typeCast[typeName] = "ax.FlipX3D";
    return 1;
}

int lua_ax_base_FlipY3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FlipY3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FlipY3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipY3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FlipY3D::create(arg0);
        object_to_luaval<ax::FlipY3D>(tolua_S, "ax.FlipY3D",(ax::FlipY3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FlipY3D:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipY3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FlipY3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FlipY3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FlipY3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FlipY3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FlipY3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FlipY3D:FlipY3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FlipY3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FlipY3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FlipY3D)");
    return 0;
}

int lua_register_ax_base_FlipY3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FlipY3D");
    tolua_cclass(tolua_S,"FlipY3D","ax.FlipY3D","ax.FlipX3D",nullptr);

    tolua_beginmodule(tolua_S,"FlipY3D");
        tolua_function(tolua_S,"new",lua_ax_base_FlipY3D_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_FlipY3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FlipY3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FlipY3D";
    g_typeCast[typeName] = "ax.FlipY3D";
    return 1;
}

int lua_ax_base_Lens3D_getLensEffect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_getLensEffect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_getLensEffect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLensEffect();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:getLensEffect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_getLensEffect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_setLensEffect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_setLensEffect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Lens3D:setLensEffect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_setLensEffect'", nullptr);
            return 0;
        }
        cobj->setLensEffect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:setLensEffect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_setLensEffect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_setConcave(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_setConcave'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Lens3D:setConcave");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_setConcave'", nullptr);
            return 0;
        }
        cobj->setConcave(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:setConcave",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_setConcave'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_getPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_getPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_getPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:getPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_getPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_setPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_setPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Lens3D:setPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_setPosition'", nullptr);
            return 0;
        }
        cobj->setPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:setPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_setPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Lens3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Lens3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Lens3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Lens3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Lens3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Lens3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Lens3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Lens3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Lens3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Lens3D:create");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Lens3D:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Lens3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Lens3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Lens3D>(tolua_S, "ax.Lens3D",(ax::Lens3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Lens3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Lens3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Lens3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Lens3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Lens3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Lens3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Lens3D:Lens3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Lens3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Lens3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Lens3D)");
    return 0;
}

int lua_register_ax_base_Lens3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Lens3D");
    tolua_cclass(tolua_S,"Lens3D","ax.Lens3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Lens3D");
        tolua_function(tolua_S,"new",lua_ax_base_Lens3D_constructor);
        tolua_function(tolua_S,"getLensEffect",lua_ax_base_Lens3D_getLensEffect);
        tolua_function(tolua_S,"setLensEffect",lua_ax_base_Lens3D_setLensEffect);
        tolua_function(tolua_S,"setConcave",lua_ax_base_Lens3D_setConcave);
        tolua_function(tolua_S,"getPosition",lua_ax_base_Lens3D_getPosition);
        tolua_function(tolua_S,"setPosition",lua_ax_base_Lens3D_setPosition);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Lens3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Lens3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Lens3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Lens3D";
    g_typeCast[typeName] = "ax.Lens3D";
    return 1;
}

int lua_ax_base_Ripple3D_getPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_getPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_getPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:getPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_getPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_setPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_setPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Ripple3D:setPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_setPosition'", nullptr);
            return 0;
        }
        cobj->setPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:setPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_setPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Ripple3D:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Ripple3D:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Ripple3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Ripple3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 6) 
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        double arg3;
        unsigned int arg4;
        double arg5;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Ripple3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Ripple3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Ripple3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Ripple3D:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 6,&arg4, "ax.Ripple3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.Ripple3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:initWithDuration",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Ripple3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Ripple3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 6)
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        double arg3;
        unsigned int arg4;
        double arg5;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Ripple3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Ripple3D:create");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Ripple3D:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Ripple3D:create");
        ok &= luaval_to_uint32(tolua_S, 6,&arg4, "ax.Ripple3D:create");
        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.Ripple3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Ripple3D::create(arg0, arg1, arg2, arg3, arg4, arg5);
        object_to_luaval<ax::Ripple3D>(tolua_S, "ax.Ripple3D",(ax::Ripple3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Ripple3D:create",argc, 6);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Ripple3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Ripple3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Ripple3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Ripple3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Ripple3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Ripple3D:Ripple3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Ripple3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Ripple3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Ripple3D)");
    return 0;
}

int lua_register_ax_base_Ripple3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Ripple3D");
    tolua_cclass(tolua_S,"Ripple3D","ax.Ripple3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Ripple3D");
        tolua_function(tolua_S,"new",lua_ax_base_Ripple3D_constructor);
        tolua_function(tolua_S,"getPosition",lua_ax_base_Ripple3D_getPosition);
        tolua_function(tolua_S,"setPosition",lua_ax_base_Ripple3D_setPosition);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_Ripple3D_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_Ripple3D_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_Ripple3D_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_Ripple3D_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Ripple3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Ripple3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Ripple3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Ripple3D";
    g_typeCast[typeName] = "ax.Ripple3D";
    return 1;
}

int lua_ax_base_Shaky3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Shaky3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Shaky3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Shaky3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Shaky3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Shaky3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Shaky3D:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Shaky3D:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.Shaky3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Shaky3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Shaky3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Shaky3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Shaky3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Shaky3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Shaky3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Shaky3D:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Shaky3D:create");
        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.Shaky3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Shaky3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Shaky3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Shaky3D>(tolua_S, "ax.Shaky3D",(ax::Shaky3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Shaky3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Shaky3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Shaky3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Shaky3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Shaky3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Shaky3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Shaky3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Shaky3D:Shaky3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Shaky3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Shaky3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Shaky3D)");
    return 0;
}

int lua_register_ax_base_Shaky3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Shaky3D");
    tolua_cclass(tolua_S,"Shaky3D","ax.Shaky3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Shaky3D");
        tolua_function(tolua_S,"new",lua_ax_base_Shaky3D_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Shaky3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Shaky3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Shaky3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Shaky3D";
    g_typeCast[typeName] = "ax.Shaky3D";
    return 1;
}

int lua_ax_base_Liquid_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Liquid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Liquid_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Liquid_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Liquid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Liquid_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Liquid:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Liquid_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Liquid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Liquid_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Liquid_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Liquid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Liquid_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Liquid:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Liquid_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Liquid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Liquid_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Liquid:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Liquid:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Liquid:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Liquid:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Liquid_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Liquid",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Liquid:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Liquid:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Liquid:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Liquid:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Liquid::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Liquid>(tolua_S, "ax.Liquid",(ax::Liquid*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Liquid:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Liquid_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Liquid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Liquid_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Liquid();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Liquid");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Liquid:Liquid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Liquid_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Liquid_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Liquid)");
    return 0;
}

int lua_register_ax_base_Liquid(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Liquid");
    tolua_cclass(tolua_S,"Liquid","ax.Liquid","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Liquid");
        tolua_function(tolua_S,"new",lua_ax_base_Liquid_constructor);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_Liquid_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_Liquid_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_Liquid_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_Liquid_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Liquid_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Liquid_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Liquid).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Liquid";
    g_typeCast[typeName] = "ax.Liquid";
    return 1;
}

int lua_ax_base_Waves_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Waves*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Waves_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 6) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        bool arg4;
        bool arg5;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Waves:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Waves:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Waves:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.Waves:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 7,&arg5, "ax.Waves:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:initWithDuration",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Waves_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Waves",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 6)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        bool arg4;
        bool arg5;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Waves:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Waves:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Waves:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Waves:create");
        ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.Waves:create");
        ok &= luaval_to_boolean(tolua_S, 7,&arg5, "ax.Waves:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Waves::create(arg0, arg1, arg2, arg3, arg4, arg5);
        object_to_luaval<ax::Waves>(tolua_S, "ax.Waves",(ax::Waves*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Waves:create",argc, 6);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Waves_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Waves* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Waves_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Waves();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Waves");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Waves:Waves",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Waves_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Waves_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Waves)");
    return 0;
}

int lua_register_ax_base_Waves(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Waves");
    tolua_cclass(tolua_S,"Waves","ax.Waves","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Waves");
        tolua_function(tolua_S,"new",lua_ax_base_Waves_constructor);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_Waves_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_Waves_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_Waves_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_Waves_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Waves_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Waves_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Waves).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Waves";
    g_typeCast[typeName] = "ax.Waves";
    return 1;
}

int lua_ax_base_Twirl_getPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_getPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_getPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:getPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_getPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_setPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_setPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Twirl:setPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_setPosition'", nullptr);
            return 0;
        }
        cobj->setPosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:setPosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_setPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Twirl:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Twirl:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Twirl*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Twirl_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        unsigned int arg3;
        double arg4;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Twirl:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Twirl:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Twirl:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.Twirl:initWithDuration");

        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.Twirl:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:initWithDuration",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Twirl_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Twirl",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        double arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        unsigned int arg3;
        double arg4;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Twirl:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Twirl:create");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Twirl:create");
        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.Twirl:create");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.Twirl:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Twirl::create(arg0, arg1, arg2, arg3, arg4);
        object_to_luaval<ax::Twirl>(tolua_S, "ax.Twirl",(ax::Twirl*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Twirl:create",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Twirl_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Twirl* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Twirl_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Twirl();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Twirl");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Twirl:Twirl",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Twirl_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Twirl_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Twirl)");
    return 0;
}

int lua_register_ax_base_Twirl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Twirl");
    tolua_cclass(tolua_S,"Twirl","ax.Twirl","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"Twirl");
        tolua_function(tolua_S,"new",lua_ax_base_Twirl_constructor);
        tolua_function(tolua_S,"getPosition",lua_ax_base_Twirl_getPosition);
        tolua_function(tolua_S,"setPosition",lua_ax_base_Twirl_setPosition);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_Twirl_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_Twirl_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_Twirl_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_Twirl_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_Twirl_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_Twirl_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Twirl).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Twirl";
    g_typeCast[typeName] = "ax.Twirl";
    return 1;
}

int lua_ax_base_ActionManager_addAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_addAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Action* arg0;
        ax::Node* arg1;
        bool arg2;

        ok &= luaval_to_object<ax::Action>(tolua_S, 2, "ax.Action",&arg0, "ax.ActionManager:addAction");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.ActionManager:addAction");

        ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.ActionManager:addAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_addAction'", nullptr);
            return 0;
        }
        cobj->addAction(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:addAction",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_addAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeAllActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeAllActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeAllActions'", nullptr);
            return 0;
        }
        cobj->removeAllActions();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeAllActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeAllActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeAllActionsFromTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeAllActionsFromTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ActionManager:removeAllActionsFromTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeAllActionsFromTarget'", nullptr);
            return 0;
        }
        cobj->removeAllActionsFromTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeAllActionsFromTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeAllActionsFromTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Action* arg0;

        ok &= luaval_to_object<ax::Action>(tolua_S, 2, "ax.Action",&arg0, "ax.ActionManager:removeAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeAction'", nullptr);
            return 0;
        }
        cobj->removeAction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeActionByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeActionByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        ax::Node* arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ActionManager:removeActionByTag");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.ActionManager:removeActionByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeActionByTag'", nullptr);
            return 0;
        }
        cobj->removeActionByTag(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeActionByTag",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeActionByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeAllActionsByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeAllActionsByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        ax::Node* arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ActionManager:removeAllActionsByTag");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.ActionManager:removeAllActionsByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeAllActionsByTag'", nullptr);
            return 0;
        }
        cobj->removeAllActionsByTag(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeAllActionsByTag",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeAllActionsByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_removeActionsByFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_removeActionsByFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        ax::Node* arg1;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.ActionManager:removeActionsByFlags");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.ActionManager:removeActionsByFlags");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_removeActionsByFlags'", nullptr);
            return 0;
        }
        cobj->removeActionsByFlags(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:removeActionsByFlags",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_removeActionsByFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_getActionByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_getActionByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        const ax::Node* arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ActionManager:getActionByTag");

        ok &= luaval_to_object<const ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.ActionManager:getActionByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_getActionByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getActionByTag(arg0, arg1);
        object_to_luaval<ax::Action>(tolua_S, "ax.Action",(ax::Action*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:getActionByTag",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_getActionByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_getNumberOfRunningActionsInTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const ax::Node* arg0;

        ok &= luaval_to_object<const ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ActionManager:getNumberOfRunningActionsInTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfRunningActionsInTarget(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:getNumberOfRunningActionsInTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_getNumberOfRunningActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_getNumberOfRunningActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_getNumberOfRunningActions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfRunningActions();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:getNumberOfRunningActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_getNumberOfRunningActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_getNumberOfRunningActionsInTargetByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTargetByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const ax::Node* arg0;
        int arg1;

        ok &= luaval_to_object<const ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ActionManager:getNumberOfRunningActionsInTargetByTag");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ActionManager:getNumberOfRunningActionsInTargetByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTargetByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNumberOfRunningActionsInTargetByTag(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:getNumberOfRunningActionsInTargetByTag",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_getNumberOfRunningActionsInTargetByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_pauseTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_pauseTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ActionManager:pauseTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_pauseTarget'", nullptr);
            return 0;
        }
        cobj->pauseTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:pauseTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_pauseTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_resumeTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_resumeTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ActionManager:resumeTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_resumeTarget'", nullptr);
            return 0;
        }
        cobj->resumeTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:resumeTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_resumeTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_pauseAllRunningActions(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_pauseAllRunningActions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_pauseAllRunningActions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->pauseAllRunningActions();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:pauseAllRunningActions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_pauseAllRunningActions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_resumeTargets(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_resumeTargets'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::Node *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.ActionManager:resumeTargets");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_resumeTargets'", nullptr);
            return 0;
        }
        cobj->resumeTargets(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:resumeTargets",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_resumeTargets'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionManager_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionManager:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_update'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionManager_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ActionManager();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ActionManager");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionManager:ActionManager",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionManager_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ActionManager_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionManager)");
    return 0;
}

int lua_register_ax_base_ActionManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionManager");
    tolua_cclass(tolua_S,"ActionManager","ax.ActionManager","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"ActionManager");
        tolua_function(tolua_S,"new",lua_ax_base_ActionManager_constructor);
        tolua_function(tolua_S,"addAction",lua_ax_base_ActionManager_addAction);
        tolua_function(tolua_S,"removeAllActions",lua_ax_base_ActionManager_removeAllActions);
        tolua_function(tolua_S,"removeAllActionsFromTarget",lua_ax_base_ActionManager_removeAllActionsFromTarget);
        tolua_function(tolua_S,"removeAction",lua_ax_base_ActionManager_removeAction);
        tolua_function(tolua_S,"removeActionByTag",lua_ax_base_ActionManager_removeActionByTag);
        tolua_function(tolua_S,"removeAllActionsByTag",lua_ax_base_ActionManager_removeAllActionsByTag);
        tolua_function(tolua_S,"removeActionsByFlags",lua_ax_base_ActionManager_removeActionsByFlags);
        tolua_function(tolua_S,"getActionByTag",lua_ax_base_ActionManager_getActionByTag);
        tolua_function(tolua_S,"getNumberOfRunningActionsInTarget",lua_ax_base_ActionManager_getNumberOfRunningActionsInTarget);
        tolua_function(tolua_S,"getNumberOfRunningActions",lua_ax_base_ActionManager_getNumberOfRunningActions);
        tolua_function(tolua_S,"getNumberOfRunningActionsInTargetByTag",lua_ax_base_ActionManager_getNumberOfRunningActionsInTargetByTag);
        tolua_function(tolua_S,"pauseTarget",lua_ax_base_ActionManager_pauseTarget);
        tolua_function(tolua_S,"resumeTarget",lua_ax_base_ActionManager_resumeTarget);
        tolua_function(tolua_S,"pauseAllRunningActions",lua_ax_base_ActionManager_pauseAllRunningActions);
        tolua_function(tolua_S,"resumeTargets",lua_ax_base_ActionManager_resumeTargets);
        tolua_function(tolua_S,"update",lua_ax_base_ActionManager_update);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionManager).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionManager";
    g_typeCast[typeName] = "ax.ActionManager";
    return 1;
}

int lua_ax_base_PageTurn3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.PageTurn3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.PageTurn3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.PageTurn3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PageTurn3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::PageTurn3D::create(arg0, arg1);
        object_to_luaval<ax::PageTurn3D>(tolua_S, "ax.PageTurn3D",(ax::PageTurn3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.PageTurn3D:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PageTurn3D_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_PageTurn3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (PageTurn3D)");
    return 0;
}

int lua_register_ax_base_PageTurn3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.PageTurn3D");
    tolua_cclass(tolua_S,"PageTurn3D","ax.PageTurn3D","ax.Grid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"PageTurn3D");
        tolua_function(tolua_S,"create", lua_ax_base_PageTurn3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::PageTurn3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.PageTurn3D";
    g_typeCast[typeName] = "ax.PageTurn3D";
    return 1;
}

int lua_ax_base_ProgressTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ProgressTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ProgressTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTo:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ProgressTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        double arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ProgressTo:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ProgressTo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ProgressTo::create(arg0, arg1);
        object_to_luaval<ax::ProgressTo>(tolua_S, "ax.ProgressTo",(ax::ProgressTo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ProgressTo:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ProgressTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ProgressTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ProgressTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTo:ProgressTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ProgressTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ProgressTo)");
    return 0;
}

int lua_register_ax_base_ProgressTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ProgressTo");
    tolua_cclass(tolua_S,"ProgressTo","ax.ProgressTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ProgressTo");
        tolua_function(tolua_S,"new",lua_ax_base_ProgressTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ProgressTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ProgressTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ProgressTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ProgressTo";
    g_typeCast[typeName] = "ax.ProgressTo";
    return 1;
}

int lua_ax_base_ProgressFromTo_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressFromTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressFromTo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressFromTo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressFromTo_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        double arg1;
        double arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ProgressFromTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ProgressFromTo:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ProgressFromTo:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressFromTo_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressFromTo:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressFromTo_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressFromTo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ProgressFromTo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ProgressFromTo:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ProgressFromTo:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ProgressFromTo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressFromTo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ProgressFromTo::create(arg0, arg1, arg2);
        object_to_luaval<ax::ProgressFromTo>(tolua_S, "ax.ProgressFromTo",(ax::ProgressFromTo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ProgressFromTo:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressFromTo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ProgressFromTo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressFromTo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressFromTo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ProgressFromTo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ProgressFromTo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressFromTo:ProgressFromTo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressFromTo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ProgressFromTo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ProgressFromTo)");
    return 0;
}

int lua_register_ax_base_ProgressFromTo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ProgressFromTo");
    tolua_cclass(tolua_S,"ProgressFromTo","ax.ProgressFromTo","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ProgressFromTo");
        tolua_function(tolua_S,"new",lua_ax_base_ProgressFromTo_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ProgressFromTo_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ProgressFromTo_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ProgressFromTo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ProgressFromTo";
    g_typeCast[typeName] = "ax.ProgressFromTo";
    return 1;
}

int lua_ax_base_ShakyTiles3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShakyTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ShakyTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ShakyTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShakyTiles3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShakyTiles3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShakyTiles3D:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ShakyTiles3D:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ShakyTiles3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShakyTiles3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShakyTiles3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShakyTiles3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShakyTiles3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ShakyTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShakyTiles3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShakyTiles3D:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ShakyTiles3D:create");
        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ShakyTiles3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShakyTiles3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ShakyTiles3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::ShakyTiles3D>(tolua_S, "ax.ShakyTiles3D",(ax::ShakyTiles3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ShakyTiles3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShakyTiles3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ShakyTiles3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShakyTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShakyTiles3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ShakyTiles3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ShakyTiles3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShakyTiles3D:ShakyTiles3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShakyTiles3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ShakyTiles3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ShakyTiles3D)");
    return 0;
}

int lua_register_ax_base_ShakyTiles3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ShakyTiles3D");
    tolua_cclass(tolua_S,"ShakyTiles3D","ax.ShakyTiles3D","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"ShakyTiles3D");
        tolua_function(tolua_S,"new",lua_ax_base_ShakyTiles3D_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ShakyTiles3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ShakyTiles3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ShakyTiles3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ShakyTiles3D";
    g_typeCast[typeName] = "ax.ShakyTiles3D";
    return 1;
}

int lua_ax_base_ShatteredTiles3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShatteredTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ShatteredTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ShatteredTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShatteredTiles3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShatteredTiles3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShatteredTiles3D:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ShatteredTiles3D:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ShatteredTiles3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShatteredTiles3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShatteredTiles3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShatteredTiles3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShatteredTiles3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ShatteredTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        int arg2;
        bool arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShatteredTiles3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShatteredTiles3D:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ShatteredTiles3D:create");
        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ShatteredTiles3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShatteredTiles3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ShatteredTiles3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::ShatteredTiles3D>(tolua_S, "ax.ShatteredTiles3D",(ax::ShatteredTiles3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ShatteredTiles3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShatteredTiles3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ShatteredTiles3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShatteredTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShatteredTiles3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ShatteredTiles3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ShatteredTiles3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShatteredTiles3D:ShatteredTiles3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShatteredTiles3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ShatteredTiles3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ShatteredTiles3D)");
    return 0;
}

int lua_register_ax_base_ShatteredTiles3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ShatteredTiles3D");
    tolua_cclass(tolua_S,"ShatteredTiles3D","ax.ShatteredTiles3D","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"ShatteredTiles3D");
        tolua_function(tolua_S,"new",lua_ax_base_ShatteredTiles3D_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ShatteredTiles3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ShatteredTiles3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ShatteredTiles3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ShatteredTiles3D";
    g_typeCast[typeName] = "ax.ShatteredTiles3D";
    return 1;
}

int lua_ax_base_ShuffleTiles_getDelta(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShuffleTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ShuffleTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ShuffleTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShuffleTiles_getDelta'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ShuffleTiles:getDelta");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShuffleTiles_getDelta'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDelta(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShuffleTiles:getDelta",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShuffleTiles_getDelta'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShuffleTiles_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShuffleTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ShuffleTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ShuffleTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ShuffleTiles_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShuffleTiles:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShuffleTiles:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.ShuffleTiles:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShuffleTiles_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShuffleTiles:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShuffleTiles_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ShuffleTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ShuffleTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ShuffleTiles:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ShuffleTiles:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.ShuffleTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShuffleTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ShuffleTiles::create(arg0, arg1, arg2);
        object_to_luaval<ax::ShuffleTiles>(tolua_S, "ax.ShuffleTiles",(ax::ShuffleTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ShuffleTiles:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShuffleTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ShuffleTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ShuffleTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ShuffleTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ShuffleTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ShuffleTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ShuffleTiles:ShuffleTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ShuffleTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ShuffleTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ShuffleTiles)");
    return 0;
}

int lua_register_ax_base_ShuffleTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ShuffleTiles");
    tolua_cclass(tolua_S,"ShuffleTiles","ax.ShuffleTiles","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"ShuffleTiles");
        tolua_function(tolua_S,"new",lua_ax_base_ShuffleTiles_constructor);
        tolua_function(tolua_S,"getDelta",lua_ax_base_ShuffleTiles_getDelta);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ShuffleTiles_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ShuffleTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ShuffleTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ShuffleTiles";
    g_typeCast[typeName] = "ax.ShuffleTiles";
    return 1;
}

int lua_ax_base_FadeOutTRTiles_testFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutTRTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeOutTRTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeOutTRTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeOutTRTiles_testFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Vec2 arg0;
        double arg1;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FadeOutTRTiles:testFunc");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.FadeOutTRTiles:testFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_testFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->testFunc(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutTRTiles:testFunc",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_testFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeOutTRTiles_turnOnTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutTRTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeOutTRTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeOutTRTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeOutTRTiles_turnOnTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FadeOutTRTiles:turnOnTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_turnOnTile'", nullptr);
            return 0;
        }
        cobj->turnOnTile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutTRTiles:turnOnTile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_turnOnTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeOutTRTiles_turnOffTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutTRTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeOutTRTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeOutTRTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeOutTRTiles_turnOffTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FadeOutTRTiles:turnOffTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_turnOffTile'", nullptr);
            return 0;
        }
        cobj->turnOffTile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutTRTiles:turnOffTile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_turnOffTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeOutTRTiles_transformTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutTRTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FadeOutTRTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FadeOutTRTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FadeOutTRTiles_transformTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Vec2 arg0;
        double arg1;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FadeOutTRTiles:transformTile");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.FadeOutTRTiles:transformTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_transformTile'", nullptr);
            return 0;
        }
        cobj->transformTile(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutTRTiles:transformTile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_transformTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FadeOutTRTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeOutTRTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeOutTRTiles:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FadeOutTRTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeOutTRTiles::create(arg0, arg1);
        object_to_luaval<ax::FadeOutTRTiles>(tolua_S, "ax.FadeOutTRTiles",(ax::FadeOutTRTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeOutTRTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeOutTRTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutTRTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutTRTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeOutTRTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeOutTRTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutTRTiles:FadeOutTRTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutTRTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeOutTRTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeOutTRTiles)");
    return 0;
}

int lua_register_ax_base_FadeOutTRTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeOutTRTiles");
    tolua_cclass(tolua_S,"FadeOutTRTiles","ax.FadeOutTRTiles","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"FadeOutTRTiles");
        tolua_function(tolua_S,"new",lua_ax_base_FadeOutTRTiles_constructor);
        tolua_function(tolua_S,"testFunc",lua_ax_base_FadeOutTRTiles_testFunc);
        tolua_function(tolua_S,"turnOnTile",lua_ax_base_FadeOutTRTiles_turnOnTile);
        tolua_function(tolua_S,"turnOffTile",lua_ax_base_FadeOutTRTiles_turnOffTile);
        tolua_function(tolua_S,"transformTile",lua_ax_base_FadeOutTRTiles_transformTile);
        tolua_function(tolua_S,"create", lua_ax_base_FadeOutTRTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeOutTRTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeOutTRTiles";
    g_typeCast[typeName] = "ax.FadeOutTRTiles";
    return 1;
}

int lua_ax_base_FadeOutBLTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeOutBLTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeOutBLTiles:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FadeOutBLTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutBLTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeOutBLTiles::create(arg0, arg1);
        object_to_luaval<ax::FadeOutBLTiles>(tolua_S, "ax.FadeOutBLTiles",(ax::FadeOutBLTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeOutBLTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutBLTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeOutBLTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutBLTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutBLTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeOutBLTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeOutBLTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutBLTiles:FadeOutBLTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutBLTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeOutBLTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeOutBLTiles)");
    return 0;
}

int lua_register_ax_base_FadeOutBLTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeOutBLTiles");
    tolua_cclass(tolua_S,"FadeOutBLTiles","ax.FadeOutBLTiles","ax.FadeOutTRTiles",nullptr);

    tolua_beginmodule(tolua_S,"FadeOutBLTiles");
        tolua_function(tolua_S,"new",lua_ax_base_FadeOutBLTiles_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_FadeOutBLTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeOutBLTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeOutBLTiles";
    g_typeCast[typeName] = "ax.FadeOutBLTiles";
    return 1;
}

int lua_ax_base_FadeOutUpTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeOutUpTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeOutUpTiles:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FadeOutUpTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutUpTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeOutUpTiles::create(arg0, arg1);
        object_to_luaval<ax::FadeOutUpTiles>(tolua_S, "ax.FadeOutUpTiles",(ax::FadeOutUpTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeOutUpTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutUpTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeOutUpTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutUpTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutUpTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeOutUpTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeOutUpTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutUpTiles:FadeOutUpTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutUpTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeOutUpTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeOutUpTiles)");
    return 0;
}

int lua_register_ax_base_FadeOutUpTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeOutUpTiles");
    tolua_cclass(tolua_S,"FadeOutUpTiles","ax.FadeOutUpTiles","ax.FadeOutTRTiles",nullptr);

    tolua_beginmodule(tolua_S,"FadeOutUpTiles");
        tolua_function(tolua_S,"new",lua_ax_base_FadeOutUpTiles_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_FadeOutUpTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeOutUpTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeOutUpTiles";
    g_typeCast[typeName] = "ax.FadeOutUpTiles";
    return 1;
}

int lua_ax_base_FadeOutDownTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FadeOutDownTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.FadeOutDownTiles:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FadeOutDownTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutDownTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FadeOutDownTiles::create(arg0, arg1);
        object_to_luaval<ax::FadeOutDownTiles>(tolua_S, "ax.FadeOutDownTiles",(ax::FadeOutDownTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FadeOutDownTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutDownTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FadeOutDownTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FadeOutDownTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FadeOutDownTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FadeOutDownTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FadeOutDownTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FadeOutDownTiles:FadeOutDownTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FadeOutDownTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FadeOutDownTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FadeOutDownTiles)");
    return 0;
}

int lua_register_ax_base_FadeOutDownTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FadeOutDownTiles");
    tolua_cclass(tolua_S,"FadeOutDownTiles","ax.FadeOutDownTiles","ax.FadeOutUpTiles",nullptr);

    tolua_beginmodule(tolua_S,"FadeOutDownTiles");
        tolua_function(tolua_S,"new",lua_ax_base_FadeOutDownTiles_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_FadeOutDownTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FadeOutDownTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FadeOutDownTiles";
    g_typeCast[typeName] = "ax.FadeOutDownTiles";
    return 1;
}

int lua_ax_base_TurnOffTiles_turnOnTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TurnOffTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TurnOffTiles_turnOnTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TurnOffTiles:turnOnTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TurnOffTiles_turnOnTile'", nullptr);
            return 0;
        }
        cobj->turnOnTile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TurnOffTiles:turnOnTile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TurnOffTiles_turnOnTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TurnOffTiles_turnOffTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TurnOffTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TurnOffTiles_turnOffTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TurnOffTiles:turnOffTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TurnOffTiles_turnOffTile'", nullptr);
            return 0;
        }
        cobj->turnOffTile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TurnOffTiles:turnOffTile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TurnOffTiles_turnOffTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TurnOffTiles_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TurnOffTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TurnOffTiles_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TurnOffTiles:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.TurnOffTiles:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.TurnOffTiles:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TurnOffTiles_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TurnOffTiles:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TurnOffTiles_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TurnOffTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TurnOffTiles:create");
            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.TurnOffTiles:create");
            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.TurnOffTiles:create");
            if (!ok) { break; }
            ax::TurnOffTiles* ret = ax::TurnOffTiles::create(arg0, arg1, arg2);
            object_to_luaval<ax::TurnOffTiles>(tolua_S, "ax.TurnOffTiles",(ax::TurnOffTiles*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TurnOffTiles:create");
            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.TurnOffTiles:create");
            if (!ok) { break; }
            ax::TurnOffTiles* ret = ax::TurnOffTiles::create(arg0, arg1);
            object_to_luaval<ax::TurnOffTiles>(tolua_S, "ax.TurnOffTiles",(ax::TurnOffTiles*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TurnOffTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TurnOffTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TurnOffTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TurnOffTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TurnOffTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TurnOffTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TurnOffTiles:TurnOffTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TurnOffTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TurnOffTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TurnOffTiles)");
    return 0;
}

int lua_register_ax_base_TurnOffTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TurnOffTiles");
    tolua_cclass(tolua_S,"TurnOffTiles","ax.TurnOffTiles","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"TurnOffTiles");
        tolua_function(tolua_S,"new",lua_ax_base_TurnOffTiles_constructor);
        tolua_function(tolua_S,"turnOnTile",lua_ax_base_TurnOffTiles_turnOnTile);
        tolua_function(tolua_S,"turnOffTile",lua_ax_base_TurnOffTiles_turnOffTile);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TurnOffTiles_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TurnOffTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TurnOffTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TurnOffTiles";
    g_typeCast[typeName] = "ax.TurnOffTiles";
    return 1;
}

int lua_ax_base_WavesTiles3D_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::WavesTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_WavesTiles3D_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_WavesTiles3D_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::WavesTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_WavesTiles3D_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.WavesTiles3D:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_WavesTiles3D_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::WavesTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_WavesTiles3D_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_WavesTiles3D_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::WavesTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_WavesTiles3D_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.WavesTiles3D:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_WavesTiles3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::WavesTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_WavesTiles3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.WavesTiles3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.WavesTiles3D:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.WavesTiles3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.WavesTiles3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_WavesTiles3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.WavesTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.WavesTiles3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.WavesTiles3D:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.WavesTiles3D:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.WavesTiles3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::WavesTiles3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::WavesTiles3D>(tolua_S, "ax.WavesTiles3D",(ax::WavesTiles3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.WavesTiles3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_WavesTiles3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::WavesTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_WavesTiles3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::WavesTiles3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.WavesTiles3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.WavesTiles3D:WavesTiles3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_WavesTiles3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_WavesTiles3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (WavesTiles3D)");
    return 0;
}

int lua_register_ax_base_WavesTiles3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.WavesTiles3D");
    tolua_cclass(tolua_S,"WavesTiles3D","ax.WavesTiles3D","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"WavesTiles3D");
        tolua_function(tolua_S,"new",lua_ax_base_WavesTiles3D_constructor);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_WavesTiles3D_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_WavesTiles3D_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_WavesTiles3D_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_WavesTiles3D_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_WavesTiles3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_WavesTiles3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::WavesTiles3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.WavesTiles3D";
    g_typeCast[typeName] = "ax.WavesTiles3D";
    return 1;
}

int lua_ax_base_JumpTiles3D_getAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTiles3D_getAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_getAmplitude'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitude();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:getAmplitude",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_getAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTiles3D_setAmplitude(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTiles3D_setAmplitude'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTiles3D:setAmplitude");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_setAmplitude'", nullptr);
            return 0;
        }
        cobj->setAmplitude(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:setAmplitude",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_setAmplitude'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTiles3D_getAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTiles3D_getAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_getAmplitudeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAmplitudeRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:getAmplitudeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_getAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTiles3D_setAmplitudeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTiles3D_setAmplitudeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTiles3D:setAmplitudeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_setAmplitudeRate'", nullptr);
            return 0;
        }
        cobj->setAmplitudeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:setAmplitudeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_setAmplitudeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTiles3D_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::JumpTiles3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_JumpTiles3D_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTiles3D:initWithDuration");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpTiles3D:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.JumpTiles3D:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.JumpTiles3D:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_JumpTiles3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.JumpTiles3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        ax::Vec2 arg1;
        unsigned int arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.JumpTiles3D:create");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.JumpTiles3D:create");
        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.JumpTiles3D:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.JumpTiles3D:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::JumpTiles3D::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::JumpTiles3D>(tolua_S, "ax.JumpTiles3D",(ax::JumpTiles3D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.JumpTiles3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_JumpTiles3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::JumpTiles3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_JumpTiles3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::JumpTiles3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.JumpTiles3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.JumpTiles3D:JumpTiles3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_JumpTiles3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_JumpTiles3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (JumpTiles3D)");
    return 0;
}

int lua_register_ax_base_JumpTiles3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.JumpTiles3D");
    tolua_cclass(tolua_S,"JumpTiles3D","ax.JumpTiles3D","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"JumpTiles3D");
        tolua_function(tolua_S,"new",lua_ax_base_JumpTiles3D_constructor);
        tolua_function(tolua_S,"getAmplitude",lua_ax_base_JumpTiles3D_getAmplitude);
        tolua_function(tolua_S,"setAmplitude",lua_ax_base_JumpTiles3D_setAmplitude);
        tolua_function(tolua_S,"getAmplitudeRate",lua_ax_base_JumpTiles3D_getAmplitudeRate);
        tolua_function(tolua_S,"setAmplitudeRate",lua_ax_base_JumpTiles3D_setAmplitudeRate);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_JumpTiles3D_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_JumpTiles3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::JumpTiles3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.JumpTiles3D";
    g_typeCast[typeName] = "ax.JumpTiles3D";
    return 1;
}

int lua_ax_base_SplitRows_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::SplitRows* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SplitRows",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SplitRows*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SplitRows_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        unsigned int arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SplitRows:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.SplitRows:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitRows_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SplitRows:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitRows_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SplitRows_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SplitRows",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        unsigned int arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SplitRows:create");
        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.SplitRows:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitRows_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SplitRows::create(arg0, arg1);
        object_to_luaval<ax::SplitRows>(tolua_S, "ax.SplitRows",(ax::SplitRows*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SplitRows:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitRows_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SplitRows_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SplitRows* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitRows_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SplitRows();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SplitRows");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SplitRows:SplitRows",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitRows_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SplitRows_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SplitRows)");
    return 0;
}

int lua_register_ax_base_SplitRows(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SplitRows");
    tolua_cclass(tolua_S,"SplitRows","ax.SplitRows","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"SplitRows");
        tolua_function(tolua_S,"new",lua_ax_base_SplitRows_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_SplitRows_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_SplitRows_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SplitRows).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SplitRows";
    g_typeCast[typeName] = "ax.SplitRows";
    return 1;
}

int lua_ax_base_SplitCols_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::SplitCols* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SplitCols",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SplitCols*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SplitCols_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        unsigned int arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SplitCols:initWithDuration");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.SplitCols:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitCols_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SplitCols:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitCols_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SplitCols_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SplitCols",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        unsigned int arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SplitCols:create");
        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.SplitCols:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitCols_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SplitCols::create(arg0, arg1);
        object_to_luaval<ax::SplitCols>(tolua_S, "ax.SplitCols",(ax::SplitCols*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SplitCols:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitCols_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SplitCols_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SplitCols* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SplitCols_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SplitCols();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SplitCols");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SplitCols:SplitCols",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SplitCols_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SplitCols_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SplitCols)");
    return 0;
}

int lua_register_ax_base_SplitCols(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SplitCols");
    tolua_cclass(tolua_S,"SplitCols","ax.SplitCols","ax.TiledGrid3DAction",nullptr);

    tolua_beginmodule(tolua_S,"SplitCols");
        tolua_function(tolua_S,"new",lua_ax_base_SplitCols_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_SplitCols_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_SplitCols_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SplitCols).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SplitCols";
    g_typeCast[typeName] = "ax.SplitCols";
    return 1;
}

int lua_ax_base_ActionTween_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionTween* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionTween",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionTween*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionTween_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        std::string_view arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionTween:initWithDuration");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ActionTween:initWithDuration");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ActionTween:initWithDuration");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ActionTween:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionTween_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionTween:initWithDuration",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionTween_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionTween_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ActionTween",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        std::string_view arg1;
        double arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ActionTween:create");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ActionTween:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ActionTween:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ActionTween:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionTween_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ActionTween::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::ActionTween>(tolua_S, "ax.ActionTween",(ax::ActionTween*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ActionTween:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionTween_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_ActionTween_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionTween)");
    return 0;
}

int lua_register_ax_base_ActionTween(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionTween");
    tolua_cclass(tolua_S,"ActionTween","ax.ActionTween","ax.ActionInterval",nullptr);

    tolua_beginmodule(tolua_S,"ActionTween");
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_ActionTween_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_ActionTween_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionTween).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionTween";
    g_typeCast[typeName] = "ax.ActionTween";
    return 1;
}

int lua_ax_base_ActionCoroutine_initWithCoroutine(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCoroutine* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ActionCoroutine",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ActionCoroutine*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ActionCoroutine_initWithCoroutine'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<ax::Coroutine ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCoroutine_initWithCoroutine'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithCoroutine(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCoroutine:initWithCoroutine",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCoroutine_initWithCoroutine'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ActionCoroutine_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ActionCoroutine",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::function<ax::Coroutine ()> arg0;
        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCoroutine_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ActionCoroutine::create(arg0);
        object_to_luaval<ax::ActionCoroutine>(tolua_S, "ax.ActionCoroutine",(ax::ActionCoroutine*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ActionCoroutine:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCoroutine_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ActionCoroutine_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ActionCoroutine* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ActionCoroutine_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ActionCoroutine();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ActionCoroutine");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ActionCoroutine:ActionCoroutine",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ActionCoroutine_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ActionCoroutine_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ActionCoroutine)");
    return 0;
}

int lua_register_ax_base_ActionCoroutine(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ActionCoroutine");
    tolua_cclass(tolua_S,"ActionCoroutine","ax.ActionCoroutine","ax.Action",nullptr);

    tolua_beginmodule(tolua_S,"ActionCoroutine");
        tolua_function(tolua_S,"new",lua_ax_base_ActionCoroutine_constructor);
        tolua_function(tolua_S,"initWithCoroutine",lua_ax_base_ActionCoroutine_initWithCoroutine);
        tolua_function(tolua_S,"create", lua_ax_base_ActionCoroutine_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ActionCoroutine).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ActionCoroutine";
    g_typeCast[typeName] = "ax.ActionCoroutine";
    return 1;
}

int lua_ax_base_AtlasNode_updateAtlasValues(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_updateAtlasValues'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_updateAtlasValues'", nullptr);
            return 0;
        }
        cobj->updateAtlasValues();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:updateAtlasValues",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_updateAtlasValues'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.AtlasNode:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.AtlasNode:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_setTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_setTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextureAtlas* arg0;

        ok &= luaval_to_object<ax::TextureAtlas>(tolua_S, 2, "ax.TextureAtlas",&arg0, "ax.AtlasNode:setTextureAtlas");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_setTextureAtlas'", nullptr);
            return 0;
        }
        cobj->setTextureAtlas(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:setTextureAtlas",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_setTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_getTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_getTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_getTextureAtlas'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureAtlas();
        object_to_luaval<ax::TextureAtlas>(tolua_S, "ax.TextureAtlas",(ax::TextureAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:getTextureAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_getTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_setQuadsToDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_setQuadsToDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.AtlasNode:setQuadsToDraw");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_setQuadsToDraw'", nullptr);
            return 0;
        }
        cobj->setQuadsToDraw(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:setQuadsToDraw",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_setQuadsToDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_getQuadsToDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_getQuadsToDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_getQuadsToDraw'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getQuadsToDraw();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:getQuadsToDraw",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_getQuadsToDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_initWithTileFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_initWithTileFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string_view arg0;
        int arg1;
        int arg2;
        int arg3;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AtlasNode:initWithTileFile");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.AtlasNode:initWithTileFile");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.AtlasNode:initWithTileFile");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.AtlasNode:initWithTileFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_initWithTileFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:initWithTileFile",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_initWithTileFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_initWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AtlasNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AtlasNode_initWithTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ax::Texture2D* arg0;
        int arg1;
        int arg2;
        int arg3;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.AtlasNode:initWithTexture");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.AtlasNode:initWithTexture");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.AtlasNode:initWithTexture");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.AtlasNode:initWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_initWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTexture(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:initWithTexture",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_initWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AtlasNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AtlasNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        std::string_view arg0;
        int arg1;
        int arg2;
        int arg3;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AtlasNode:create");
        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.AtlasNode:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.AtlasNode:create");
        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.AtlasNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::AtlasNode::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::AtlasNode>(tolua_S, "ax.AtlasNode",(ax::AtlasNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AtlasNode:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AtlasNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AtlasNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AtlasNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AtlasNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.AtlasNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AtlasNode:AtlasNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AtlasNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AtlasNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AtlasNode)");
    return 0;
}

int lua_register_ax_base_AtlasNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AtlasNode");
    tolua_cclass(tolua_S,"AtlasNode","ax.AtlasNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"AtlasNode");
        tolua_function(tolua_S,"new",lua_ax_base_AtlasNode_constructor);
        tolua_function(tolua_S,"updateAtlasValues",lua_ax_base_AtlasNode_updateAtlasValues);
        tolua_function(tolua_S,"getTexture",lua_ax_base_AtlasNode_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_AtlasNode_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_AtlasNode_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_AtlasNode_getBlendFunc);
        tolua_function(tolua_S,"setTextureAtlas",lua_ax_base_AtlasNode_setTextureAtlas);
        tolua_function(tolua_S,"getTextureAtlas",lua_ax_base_AtlasNode_getTextureAtlas);
        tolua_function(tolua_S,"setQuadsToDraw",lua_ax_base_AtlasNode_setQuadsToDraw);
        tolua_function(tolua_S,"getQuadsToDraw",lua_ax_base_AtlasNode_getQuadsToDraw);
        tolua_function(tolua_S,"initWithTileFile",lua_ax_base_AtlasNode_initWithTileFile);
        tolua_function(tolua_S,"initWithTexture",lua_ax_base_AtlasNode_initWithTexture);
        tolua_function(tolua_S,"create", lua_ax_base_AtlasNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AtlasNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AtlasNode";
    g_typeCast[typeName] = "ax.AtlasNode";
    return 1;
}

int lua_ax_base_ClippingNode_getStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_getStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_getStencil'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStencil();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:getStencil",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_getStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_setStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_setStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ClippingNode:setStencil");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_setStencil'", nullptr);
            return 0;
        }
        cobj->setStencil(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:setStencil",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_setStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_hasContent(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_hasContent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_hasContent'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasContent();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:hasContent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_hasContent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_getAlphaThreshold(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_getAlphaThreshold'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_getAlphaThreshold'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAlphaThreshold();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:getAlphaThreshold",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_getAlphaThreshold'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_setAlphaThreshold(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_setAlphaThreshold'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ClippingNode:setAlphaThreshold");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_setAlphaThreshold'", nullptr);
            return 0;
        }
        cobj->setAlphaThreshold(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:setAlphaThreshold",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_setAlphaThreshold'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_isInverted(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_isInverted'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_isInverted'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isInverted();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:isInverted",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_isInverted'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_setInverted(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_setInverted'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ClippingNode:setInverted");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_setInverted'", nullptr);
            return 0;
        }
        cobj->setInverted(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:setInverted",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_setInverted'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingNode_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ClippingNode:init");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingNode_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingNode:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ClippingNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 1)
        {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ClippingNode:create");
            if (!ok) { break; }
            ax::ClippingNode* ret = ax::ClippingNode::create(arg0);
            object_to_luaval<ax::ClippingNode>(tolua_S, "ax.ClippingNode",(ax::ClippingNode*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::ClippingNode* ret = ax::ClippingNode::create();
            object_to_luaval<ax::ClippingNode>(tolua_S, "ax.ClippingNode",(ax::ClippingNode*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.ClippingNode:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingNode_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_ClippingNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ClippingNode)");
    return 0;
}

int lua_register_ax_base_ClippingNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ClippingNode");
    tolua_cclass(tolua_S,"ClippingNode","ax.ClippingNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ClippingNode");
        tolua_function(tolua_S,"getStencil",lua_ax_base_ClippingNode_getStencil);
        tolua_function(tolua_S,"setStencil",lua_ax_base_ClippingNode_setStencil);
        tolua_function(tolua_S,"hasContent",lua_ax_base_ClippingNode_hasContent);
        tolua_function(tolua_S,"getAlphaThreshold",lua_ax_base_ClippingNode_getAlphaThreshold);
        tolua_function(tolua_S,"setAlphaThreshold",lua_ax_base_ClippingNode_setAlphaThreshold);
        tolua_function(tolua_S,"isInverted",lua_ax_base_ClippingNode_isInverted);
        tolua_function(tolua_S,"setInverted",lua_ax_base_ClippingNode_setInverted);
        tolua_function(tolua_S,"init",lua_ax_base_ClippingNode_init);
        tolua_function(tolua_S,"create", lua_ax_base_ClippingNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ClippingNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ClippingNode";
    g_typeCast[typeName] = "ax.ClippingNode";
    return 1;
}

int lua_ax_base_ClippingRectangleNode_getClippingRegion(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingRectangleNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingRectangleNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingRectangleNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingRectangleNode_getClippingRegion'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingRectangleNode_getClippingRegion'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClippingRegion();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingRectangleNode:getClippingRegion",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingRectangleNode_getClippingRegion'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingRectangleNode_setClippingRegion(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingRectangleNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingRectangleNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingRectangleNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingRectangleNode_setClippingRegion'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.ClippingRectangleNode:setClippingRegion");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingRectangleNode_setClippingRegion'", nullptr);
            return 0;
        }
        cobj->setClippingRegion(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingRectangleNode:setClippingRegion",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingRectangleNode_setClippingRegion'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingRectangleNode_isClippingEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingRectangleNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingRectangleNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingRectangleNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingRectangleNode_isClippingEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingRectangleNode_isClippingEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isClippingEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingRectangleNode:isClippingEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingRectangleNode_isClippingEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingRectangleNode_setClippingEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::ClippingRectangleNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ClippingRectangleNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ClippingRectangleNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ClippingRectangleNode_setClippingEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ClippingRectangleNode:setClippingEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ClippingRectangleNode_setClippingEnabled'", nullptr);
            return 0;
        }
        cobj->setClippingEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ClippingRectangleNode:setClippingEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingRectangleNode_setClippingEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ClippingRectangleNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ClippingRectangleNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 0)
        {
            ax::ClippingRectangleNode* ret = ax::ClippingRectangleNode::create();
            object_to_luaval<ax::ClippingRectangleNode>(tolua_S, "ax.ClippingRectangleNode",(ax::ClippingRectangleNode*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::Rect arg0;
            ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.ClippingRectangleNode:create");
            if (!ok) { break; }
            ax::ClippingRectangleNode* ret = ax::ClippingRectangleNode::create(arg0);
            object_to_luaval<ax::ClippingRectangleNode>(tolua_S, "ax.ClippingRectangleNode",(ax::ClippingRectangleNode*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.ClippingRectangleNode:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ClippingRectangleNode_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_ClippingRectangleNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ClippingRectangleNode)");
    return 0;
}

int lua_register_ax_base_ClippingRectangleNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ClippingRectangleNode");
    tolua_cclass(tolua_S,"ClippingRectangleNode","ax.ClippingRectangleNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ClippingRectangleNode");
        tolua_function(tolua_S,"getClippingRegion",lua_ax_base_ClippingRectangleNode_getClippingRegion);
        tolua_function(tolua_S,"setClippingRegion",lua_ax_base_ClippingRectangleNode_setClippingRegion);
        tolua_function(tolua_S,"isClippingEnabled",lua_ax_base_ClippingRectangleNode_isClippingEnabled);
        tolua_function(tolua_S,"setClippingEnabled",lua_ax_base_ClippingRectangleNode_setClippingEnabled);
        tolua_function(tolua_S,"create", lua_ax_base_ClippingRectangleNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ClippingRectangleNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ClippingRectangleNode";
    g_typeCast[typeName] = "ax.ClippingRectangleNode";
    return 1;
}

int lua_ax_base_DrawNode_drawPoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawPoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vec2 arg0;
        double arg1;
        ax::Color4B arg2;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawPoint");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawPoint");

        ok &=luaval_to_color4b(tolua_S, 4, &arg2, "ax.DrawNode:drawPoint");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawPoint'", nullptr);
            return 0;
        }
        cobj->drawPoint(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawPoint",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawPoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawLine(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawLine'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        ax::Color4B arg2;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawLine");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawLine");

        ok &=luaval_to_color4b(tolua_S, 4, &arg2, "ax.DrawNode:drawLine");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawLine'", nullptr);
            return 0;
        }
        cobj->drawLine(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawLine",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawLine'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawRect'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Vec2 arg2;
            ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Color4B arg4;
            ok &=luaval_to_color4b(tolua_S, 6, &arg4, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            cobj->drawRect(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            ax::Color4B arg2;
            ok &=luaval_to_color4b(tolua_S, 4, &arg2, "ax.DrawNode:drawRect");

            if (!ok) { break; }
            cobj->drawRect(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.DrawNode:drawRect",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawCircle(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawCircle'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 6) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            ax::Color4B arg5;
            ok &=luaval_to_color4b(tolua_S, 7, &arg5, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 7) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            ax::Color4B arg5;
            ok &=luaval_to_color4b(tolua_S, 7, &arg5, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg6;
            ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 8) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg5;
            ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg6;
            ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            ax::Color4B arg7;
            ok &=luaval_to_color4b(tolua_S, 9, &arg7, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 9) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg5;
            ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg6;
            ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            ax::Color4B arg7;
            ok &=luaval_to_color4b(tolua_S, 9, &arg7, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            double arg8;
            ok &= luaval_to_number(tolua_S, 10,&arg8, "ax.DrawNode:drawCircle");

            if (!ok) { break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.DrawNode:drawCircle",argc, 8);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawCircle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawQuadBezier(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawQuadBezier'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        unsigned int arg3;
        ax::Color4B arg4;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawQuadBezier");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawQuadBezier");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.DrawNode:drawQuadBezier");

        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawQuadBezier");

        ok &=luaval_to_color4b(tolua_S, 6, &arg4, "ax.DrawNode:drawQuadBezier");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawQuadBezier'", nullptr);
            return 0;
        }
        cobj->drawQuadBezier(arg0, arg1, arg2, arg3, arg4);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawQuadBezier",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawQuadBezier'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawCubicBezier(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawCubicBezier'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 6) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        ax::Vec2 arg3;
        unsigned int arg4;
        ax::Color4B arg5;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawCubicBezier");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawCubicBezier");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.DrawNode:drawCubicBezier");

        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.DrawNode:drawCubicBezier");

        ok &= luaval_to_uint32(tolua_S, 6,&arg4, "ax.DrawNode:drawCubicBezier");

        ok &=luaval_to_color4b(tolua_S, 7, &arg5, "ax.DrawNode:drawCubicBezier");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawCubicBezier'", nullptr);
            return 0;
        }
        cobj->drawCubicBezier(arg0, arg1, arg2, arg3, arg4, arg5);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawCubicBezier",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawCubicBezier'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawDot(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawDot'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vec2 arg0;
        double arg1;
        ax::Color4B arg2;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawDot");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawDot");

        ok &=luaval_to_color4b(tolua_S, 4, &arg2, "ax.DrawNode:drawDot");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawDot'", nullptr);
            return 0;
        }
        cobj->drawDot(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawDot",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawDot'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawSolidRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawSolidRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        ax::Color4B arg2;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawSolidRect");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawSolidRect");

        ok &=luaval_to_color4b(tolua_S, 4, &arg2, "ax.DrawNode:drawSolidRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawSolidRect'", nullptr);
            return 0;
        }
        cobj->drawSolidRect(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawSolidRect",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawSolidRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawSolidCircle(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawSolidCircle'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 7) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg5;
            ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            ax::Color4B arg6;
            ok &=luaval_to_color4b(tolua_S, 8, &arg6, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 9) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg5;
            ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            ax::Color4B arg6;
            ok &=luaval_to_color4b(tolua_S, 8, &arg6, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg7;
            ok &= luaval_to_number(tolua_S, 9,&arg7, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            ax::Color4B arg8;
            ok &=luaval_to_color4b(tolua_S, 10, &arg8, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            unsigned int arg3;
            ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            ax::Color4B arg4;
            ok &=luaval_to_color4b(tolua_S, 6, &arg4, "ax.DrawNode:drawSolidCircle");

            if (!ok) { break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.DrawNode:drawSolidCircle",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawSolidCircle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawPie(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawPie'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 9) 
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        int arg3;
        int arg4;
        double arg5;
        double arg6;
        ax::Color4B arg7;
        ax::DrawNode::DrawMode arg8;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawPie");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.DrawNode:drawPie");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawPie");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.DrawNode:drawPie");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.DrawNode:drawPie");

        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.DrawNode:drawPie");

        ok &= luaval_to_number(tolua_S, 8,&arg6, "ax.DrawNode:drawPie");

        ok &=luaval_to_color4b(tolua_S, 9, &arg7, "ax.DrawNode:drawPie");

        ok &= luaval_to_int32(tolua_S, 10,(int *)&arg8, "ax.DrawNode:drawPie");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawPie'", nullptr);
            return 0;
        }
        cobj->drawPie(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawPie",argc, 9);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawPie'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawSegment(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawSegment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        double arg2;
        ax::Color4B arg3;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawSegment");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawSegment");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.DrawNode:drawSegment");

        ok &=luaval_to_color4b(tolua_S, 5, &arg3, "ax.DrawNode:drawSegment");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawSegment'", nullptr);
            return 0;
        }
        cobj->drawSegment(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawSegment",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawSegment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_drawTriangle(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_drawTriangle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ax::Vec2 arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        ax::Color4B arg3;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.DrawNode:drawTriangle");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.DrawNode:drawTriangle");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.DrawNode:drawTriangle");

        ok &=luaval_to_color4b(tolua_S, 5, &arg3, "ax.DrawNode:drawTriangle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_drawTriangle'", nullptr);
            return 0;
        }
        cobj->drawTriangle(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:drawTriangle",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_drawTriangle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_clear(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_clear'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_clear'", nullptr);
            return 0;
        }
        cobj->clear();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:clear",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_clear'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.DrawNode:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_setLineWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_setLineWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.DrawNode:setLineWidth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_setLineWidth'", nullptr);
            return 0;
        }
        cobj->setLineWidth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:setLineWidth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_setLineWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_getLineWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_getLineWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_getLineWidth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLineWidth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:getLineWidth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_getLineWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_setIsConvex(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_setIsConvex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.DrawNode:setIsConvex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_setIsConvex'", nullptr);
            return 0;
        }
        cobj->setIsConvex(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:setIsConvex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_setIsConvex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_setIsolated(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_setIsolated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.DrawNode:setIsolated");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_setIsolated'", nullptr);
            return 0;
        }
        cobj->setIsolated(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:setIsolated",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_setIsolated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_isIsolated(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DrawNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DrawNode_isIsolated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_isIsolated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isIsolated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:isIsolated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_isIsolated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DrawNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.DrawNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::DrawNode::create();
        object_to_luaval<ax::DrawNode>(tolua_S, "ax.DrawNode",(ax::DrawNode*)ret);
        return 1;
    }
    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.DrawNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::DrawNode::create(arg0);
        object_to_luaval<ax::DrawNode>(tolua_S, "ax.DrawNode",(ax::DrawNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.DrawNode:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_DrawNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::DrawNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::DrawNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.DrawNode");
        return 1;
    }
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.DrawNode:DrawNode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DrawNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::DrawNode(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.DrawNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DrawNode:DrawNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DrawNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_DrawNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (DrawNode)");
    return 0;
}

int lua_register_ax_base_DrawNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.DrawNode");
    tolua_cclass(tolua_S,"DrawNode","ax.DrawNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"DrawNode");
        tolua_function(tolua_S,"new",lua_ax_base_DrawNode_constructor);
        tolua_function(tolua_S,"drawPoint",lua_ax_base_DrawNode_drawPoint);
        tolua_function(tolua_S,"drawLine",lua_ax_base_DrawNode_drawLine);
        tolua_function(tolua_S,"drawRect",lua_ax_base_DrawNode_drawRect);
        tolua_function(tolua_S,"drawCircle",lua_ax_base_DrawNode_drawCircle);
        tolua_function(tolua_S,"drawQuadBezier",lua_ax_base_DrawNode_drawQuadBezier);
        tolua_function(tolua_S,"drawCubicBezier",lua_ax_base_DrawNode_drawCubicBezier);
        tolua_function(tolua_S,"drawDot",lua_ax_base_DrawNode_drawDot);
        tolua_function(tolua_S,"drawSolidRect",lua_ax_base_DrawNode_drawSolidRect);
        tolua_function(tolua_S,"drawSolidCircle",lua_ax_base_DrawNode_drawSolidCircle);
        tolua_function(tolua_S,"drawPie",lua_ax_base_DrawNode_drawPie);
        tolua_function(tolua_S,"drawSegment",lua_ax_base_DrawNode_drawSegment);
        tolua_function(tolua_S,"drawTriangle",lua_ax_base_DrawNode_drawTriangle);
        tolua_function(tolua_S,"clear",lua_ax_base_DrawNode_clear);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_DrawNode_getBlendFunc);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_DrawNode_setBlendFunc);
        tolua_function(tolua_S,"setLineWidth",lua_ax_base_DrawNode_setLineWidth);
        tolua_function(tolua_S,"getLineWidth",lua_ax_base_DrawNode_getLineWidth);
        tolua_function(tolua_S,"setIsConvex",lua_ax_base_DrawNode_setIsConvex);
        tolua_function(tolua_S,"setIsolated",lua_ax_base_DrawNode_setIsolated);
        tolua_function(tolua_S,"isIsolated",lua_ax_base_DrawNode_isIsolated);
        tolua_function(tolua_S,"create", lua_ax_base_DrawNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::DrawNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.DrawNode";
    g_typeCast[typeName] = "ax.DrawNode";
    return 1;
}

int lua_ax_base_Label_setTTFConfig(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setTTFConfig'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::_ttfConfig arg0;

        ok &= luaval_to_ttfconfig(tolua_S, 2, &arg0, "ax.Label:setTTFConfig");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setTTFConfig'", nullptr);
            return 0;
        }
        auto&& ret = cobj->setTTFConfig(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setTTFConfig",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setTTFConfig'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getTTFConfig(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getTTFConfig'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getTTFConfig'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTTFConfig();
        ttfconfig_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getTTFConfig",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getTTFConfig'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setBMFontFilePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setBMFontFilePath'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:setBMFontFilePath");

            if (!ok) { break; }
            bool ret = cobj->setBMFontFilePath(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Label:setBMFontFilePath",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setBMFontFilePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getBMFontFilePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getBMFontFilePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getBMFontFilePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBMFontFilePath();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getBMFontFilePath",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getBMFontFilePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setCharMap(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setCharMap'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:setCharMap");

            if (!ok) { break; }
            bool ret = cobj->setCharMap(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:setCharMap");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:setCharMap");

            if (!ok) { break; }
            bool ret = cobj->setCharMap(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setCharMap");

            if (!ok) { break; }
            bool ret = cobj->setCharMap(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Label:setCharMap",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setCharMap'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setSystemFontName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setSystemFontName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setSystemFontName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setSystemFontName'", nullptr);
            return 0;
        }
        cobj->setSystemFontName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setSystemFontName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setSystemFontName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getSystemFontName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getSystemFontName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getSystemFontName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSystemFontName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getSystemFontName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getSystemFontName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setSystemFontSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setSystemFontSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setSystemFontSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setSystemFontSize'", nullptr);
            return 0;
        }
        cobj->setSystemFontSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setSystemFontSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setSystemFontSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getSystemFontSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getSystemFontSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getSystemFontSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSystemFontSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getSystemFontSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getSystemFontSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_requestSystemFontRefresh(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_requestSystemFontRefresh'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_requestSystemFontRefresh'", nullptr);
            return 0;
        }
        cobj->requestSystemFontRefresh();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:requestSystemFontRefresh",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_requestSystemFontRefresh'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setString(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:setString");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setString'", nullptr);
            return 0;
        }
        cobj->setString(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setString",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getString(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getString",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getStringNumLines(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getStringNumLines'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getStringNumLines'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStringNumLines();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getStringNumLines",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getStringNumLines'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getStringLength(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getStringLength'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getStringLength'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStringLength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getStringLength",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getStringLength'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setTextColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setTextColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4B arg0;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:setTextColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setTextColor'", nullptr);
            return 0;
        }
        cobj->setTextColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setTextColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setTextColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getTextColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getTextColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getTextColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextColor();
        color4b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getTextColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getTextColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableShadow(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableShadow'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableShadow'", nullptr);
            return 0;
        }
        cobj->enableShadow();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        ax::Color4B arg0;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableShadow");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableShadow'", nullptr);
            return 0;
        }
        cobj->enableShadow(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Color4B arg0;
        ax::Vec2 arg1;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableShadow");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Label:enableShadow");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableShadow'", nullptr);
            return 0;
        }
        cobj->enableShadow(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 3) 
    {
        ax::Color4B arg0;
        ax::Vec2 arg1;
        int arg2;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableShadow");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Label:enableShadow");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:enableShadow");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableShadow'", nullptr);
            return 0;
        }
        cobj->enableShadow(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableShadow",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableShadow'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableOutline(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableOutline'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4B arg0;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableOutline");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableOutline'", nullptr);
            return 0;
        }
        cobj->enableOutline(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Color4B arg0;
        int arg1;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableOutline");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:enableOutline");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableOutline'", nullptr);
            return 0;
        }
        cobj->enableOutline(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableOutline",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableOutline'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableGlow(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableGlow'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4B arg0;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.Label:enableGlow");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableGlow'", nullptr);
            return 0;
        }
        cobj->enableGlow(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableGlow",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableGlow'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableItalics(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableItalics'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableItalics'", nullptr);
            return 0;
        }
        cobj->enableItalics();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableItalics",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableItalics'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableBold(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableBold'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableBold'", nullptr);
            return 0;
        }
        cobj->enableBold();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableBold",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableBold'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableUnderline(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableUnderline'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableUnderline'", nullptr);
            return 0;
        }
        cobj->enableUnderline();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableUnderline",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableUnderline'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableStrikethrough(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableStrikethrough'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableStrikethrough'", nullptr);
            return 0;
        }
        cobj->enableStrikethrough();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableStrikethrough",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableStrikethrough'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_disableEffect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_disableEffect'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::LabelEffect arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:disableEffect");

            if (!ok) { break; }
            cobj->disableEffect(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->disableEffect();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Label:disableEffect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_disableEffect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_isShadowEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_isShadowEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_isShadowEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isShadowEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:isShadowEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_isShadowEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getShadowOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getShadowOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getShadowOffset'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getShadowOffset();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getShadowOffset",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getShadowOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getShadowBlurRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getShadowBlurRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getShadowBlurRadius'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getShadowBlurRadius();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getShadowBlurRadius",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getShadowBlurRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getShadowColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getShadowColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getShadowColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getShadowColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getShadowColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getShadowColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getOutlineSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getOutlineSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getOutlineSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOutlineSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getOutlineSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getOutlineSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getLabelEffectType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getLabelEffectType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getLabelEffectType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getLabelEffectType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getLabelEffectType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getLabelEffectType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getEffectColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getEffectColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getEffectColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEffectColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getEffectColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getEffectColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setAlignment'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::TextHAlignment arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setAlignment");

            if (!ok) { break; }
            ax::TextVAlignment arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:setAlignment");

            if (!ok) { break; }
            cobj->setAlignment(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::TextHAlignment arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setAlignment");

            if (!ok) { break; }
            cobj->setAlignment(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Label:setAlignment",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getTextAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getTextAlignment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getTextAlignment'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getTextAlignment();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getTextAlignment",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getTextAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setHorizontalAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setHorizontalAlignment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextHAlignment arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setHorizontalAlignment");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setHorizontalAlignment'", nullptr);
            return 0;
        }
        cobj->setHorizontalAlignment(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setHorizontalAlignment",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setHorizontalAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getHorizontalAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getHorizontalAlignment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getHorizontalAlignment'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getHorizontalAlignment();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getHorizontalAlignment",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getHorizontalAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setVerticalAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setVerticalAlignment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextVAlignment arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setVerticalAlignment");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setVerticalAlignment'", nullptr);
            return 0;
        }
        cobj->setVerticalAlignment(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setVerticalAlignment",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setVerticalAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getVerticalAlignment(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getVerticalAlignment'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getVerticalAlignment'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getVerticalAlignment();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getVerticalAlignment",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getVerticalAlignment'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setLineBreakWithoutSpace(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setLineBreakWithoutSpace'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Label:setLineBreakWithoutSpace");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setLineBreakWithoutSpace'", nullptr);
            return 0;
        }
        cobj->setLineBreakWithoutSpace(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setLineBreakWithoutSpace",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setLineBreakWithoutSpace'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setMaxLineWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setMaxLineWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setMaxLineWidth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setMaxLineWidth'", nullptr);
            return 0;
        }
        cobj->setMaxLineWidth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setMaxLineWidth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setMaxLineWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getMaxLineWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getMaxLineWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getMaxLineWidth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMaxLineWidth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getMaxLineWidth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getMaxLineWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setTTFFaceSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setTTFFaceSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setTTFFaceSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setTTFFaceSize'", nullptr);
            return 0;
        }
        cobj->setTTFFaceSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setTTFFaceSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setTTFFaceSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getTTFFaceSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getTTFFaceSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getTTFFaceSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTTFFaceSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getTTFFaceSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getTTFFaceSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setBMFontSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setBMFontSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setBMFontSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setBMFontSize'", nullptr);
            return 0;
        }
        cobj->setBMFontSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setBMFontSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setBMFontSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getBMFontSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getBMFontSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getBMFontSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBMFontSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getBMFontSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getBMFontSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_enableWrap(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_enableWrap'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Label:enableWrap");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_enableWrap'", nullptr);
            return 0;
        }
        cobj->enableWrap(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:enableWrap",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_enableWrap'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_isWrapEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_isWrapEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_isWrapEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isWrapEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:isWrapEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_isWrapEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setOverflow(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setOverflow'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Label::Overflow arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:setOverflow");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setOverflow'", nullptr);
            return 0;
        }
        cobj->setOverflow(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setOverflow",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setOverflow'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getOverflow(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getOverflow'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getOverflow'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getOverflow();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getOverflow",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getOverflow'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setWidth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setWidth'", nullptr);
            return 0;
        }
        cobj->setWidth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setWidth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getWidth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getWidth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getWidth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setHeight");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setHeight'", nullptr);
            return 0;
        }
        cobj->setHeight(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setHeight",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getHeight'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHeight();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getHeight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setDimensions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setDimensions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setDimensions");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Label:setDimensions");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setDimensions'", nullptr);
            return 0;
        }
        cobj->setDimensions(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setDimensions",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setDimensions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getDimensions(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getDimensions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getDimensions'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDimensions();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getDimensions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getDimensions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_updateContent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_updateContent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_updateContent'", nullptr);
            return 0;
        }
        cobj->updateContent();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:updateContent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_updateContent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getLetter(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getLetter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Label:getLetter");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getLetter'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLetter(arg0);
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getLetter",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getLetter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setClipMarginEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setClipMarginEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Label:setClipMarginEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setClipMarginEnabled'", nullptr);
            return 0;
        }
        cobj->setClipMarginEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setClipMarginEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setClipMarginEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_isClipMarginEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_isClipMarginEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_isClipMarginEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isClipMarginEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:isClipMarginEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_isClipMarginEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setLineHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setLineHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setLineHeight");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setLineHeight'", nullptr);
            return 0;
        }
        cobj->setLineHeight(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setLineHeight",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setLineHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getLineHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getLineHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getLineHeight'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLineHeight();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getLineHeight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getLineHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setLineSpacing(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setLineSpacing'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setLineSpacing");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setLineSpacing'", nullptr);
            return 0;
        }
        cobj->setLineSpacing(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setLineSpacing",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setLineSpacing'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getLineSpacing(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getLineSpacing'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getLineSpacing'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLineSpacing();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getLineSpacing",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getLineSpacing'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getLabelType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getLabelType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getLabelType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getLabelType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getLabelType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getLabelType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getRenderingFontSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getRenderingFontSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getRenderingFontSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderingFontSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getRenderingFontSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getRenderingFontSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setAdditionalKerning(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setAdditionalKerning'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Label:setAdditionalKerning");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setAdditionalKerning'", nullptr);
            return 0;
        }
        cobj->setAdditionalKerning(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setAdditionalKerning",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setAdditionalKerning'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getAdditionalKerning(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getAdditionalKerning'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getAdditionalKerning'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAdditionalKerning();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getAdditionalKerning",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getAdditionalKerning'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getFontAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getFontAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getFontAtlas'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFontAtlas();
        object_to_luaval<ax::FontAtlas>(tolua_S, "ax.FontAtlas",(ax::FontAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getFontAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getFontAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.Label:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Label:removeAllChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_removeAllChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Label:removeAllChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_initWithTTF(lua_State* tolua_S)
{
    int argc = 0;
    ax::Label* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Label*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Label_initWithTTF'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::_ttfConfig arg0;
            ok &= luaval_to_ttfconfig(tolua_S, 2, &arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::_ttfConfig arg0;
            ok &= luaval_to_ttfconfig(tolua_S, 2, &arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            ax::_ttfConfig arg0;
            ok &= luaval_to_ttfconfig(tolua_S, 2, &arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:initWithTTF");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:initWithTTF");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::TextHAlignment arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Label:initWithTTF");

            if (!ok) { break; }
            ax::TextVAlignment arg5;
            ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Label:initWithTTF");

            if (!ok) { break; }
            bool ret = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4, arg5);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Label:initWithTTF",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_initWithTTF'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Label_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Label::create();
        object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Label:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Label_createWithSystemFont(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        std::string_view arg0;
        std::string_view arg1;
        double arg2;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithSystemFont");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithSystemFont");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:createWithSystemFont");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_createWithSystemFont'", nullptr);
            return 0;
        }
        auto&& ret = ax::Label::createWithSystemFont(arg0, arg1, arg2);
        object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
        return 1;
    }
    if (argc == 4)
    {
        std::string_view arg0;
        std::string_view arg1;
        double arg2;
        ax::Vec2 arg3;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithSystemFont");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithSystemFont");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:createWithSystemFont");
        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:createWithSystemFont");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_createWithSystemFont'", nullptr);
            return 0;
        }
        auto&& ret = ax::Label::createWithSystemFont(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
        return 1;
    }
    if (argc == 5)
    {
        std::string_view arg0;
        std::string_view arg1;
        double arg2;
        ax::Vec2 arg3;
        ax::TextHAlignment arg4;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithSystemFont");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithSystemFont");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:createWithSystemFont");
        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:createWithSystemFont");
        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Label:createWithSystemFont");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_createWithSystemFont'", nullptr);
            return 0;
        }
        auto&& ret = ax::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4);
        object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
        return 1;
    }
    if (argc == 6)
    {
        std::string_view arg0;
        std::string_view arg1;
        double arg2;
        ax::Vec2 arg3;
        ax::TextHAlignment arg4;
        ax::TextVAlignment arg5;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithSystemFont");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithSystemFont");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Label:createWithSystemFont");
        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.Label:createWithSystemFont");
        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Label:createWithSystemFont");
        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Label:createWithSystemFont");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Label_createWithSystemFont'", nullptr);
            return 0;
        }
        auto&& ret = ax::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4, arg5);
        object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Label:createWithSystemFont",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_createWithSystemFont'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Label_createWithBMFont(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 6)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Rect arg4;
            ok &= luaval_to_rect(tolua_S, 6, &arg4, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            bool arg5;
            ok &= luaval_to_boolean(tolua_S, 7,&arg5, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4, arg5);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithBMFont(arg0, arg1);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithBMFont(arg0, arg1, arg2);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithBMFont(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::TextHAlignment arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.Label:createWithBMFont");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Label:createWithBMFont",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_createWithBMFont'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Label_createWithCharMap(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Label",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 4)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Label:createWithCharMap");
            if (!ok) { break; }
            ax::Label* ret = ax::Label::createWithCharMap(arg0);
            object_to_luaval<ax::Label>(tolua_S, "ax.Label",(ax::Label*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Label:createWithCharMap",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Label_createWithCharMap'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Label_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Label)");
    return 0;
}

int lua_register_ax_base_Label(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Label");
    tolua_cclass(tolua_S,"Label","ax.Label","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Label");
        tolua_function(tolua_S,"setTTFConfig",lua_ax_base_Label_setTTFConfig);
        tolua_function(tolua_S,"getTTFConfig",lua_ax_base_Label_getTTFConfig);
        tolua_function(tolua_S,"setBMFontFilePath",lua_ax_base_Label_setBMFontFilePath);
        tolua_function(tolua_S,"getBMFontFilePath",lua_ax_base_Label_getBMFontFilePath);
        tolua_function(tolua_S,"setCharMap",lua_ax_base_Label_setCharMap);
        tolua_function(tolua_S,"setSystemFontName",lua_ax_base_Label_setSystemFontName);
        tolua_function(tolua_S,"getSystemFontName",lua_ax_base_Label_getSystemFontName);
        tolua_function(tolua_S,"setSystemFontSize",lua_ax_base_Label_setSystemFontSize);
        tolua_function(tolua_S,"getSystemFontSize",lua_ax_base_Label_getSystemFontSize);
        tolua_function(tolua_S,"requestSystemFontRefresh",lua_ax_base_Label_requestSystemFontRefresh);
        tolua_function(tolua_S,"setString",lua_ax_base_Label_setString);
        tolua_function(tolua_S,"getString",lua_ax_base_Label_getString);
        tolua_function(tolua_S,"getStringNumLines",lua_ax_base_Label_getStringNumLines);
        tolua_function(tolua_S,"getStringLength",lua_ax_base_Label_getStringLength);
        tolua_function(tolua_S,"setTextColor",lua_ax_base_Label_setTextColor);
        tolua_function(tolua_S,"getTextColor",lua_ax_base_Label_getTextColor);
        tolua_function(tolua_S,"enableShadow",lua_ax_base_Label_enableShadow);
        tolua_function(tolua_S,"enableOutline",lua_ax_base_Label_enableOutline);
        tolua_function(tolua_S,"enableGlow",lua_ax_base_Label_enableGlow);
        tolua_function(tolua_S,"enableItalics",lua_ax_base_Label_enableItalics);
        tolua_function(tolua_S,"enableBold",lua_ax_base_Label_enableBold);
        tolua_function(tolua_S,"enableUnderline",lua_ax_base_Label_enableUnderline);
        tolua_function(tolua_S,"enableStrikethrough",lua_ax_base_Label_enableStrikethrough);
        tolua_function(tolua_S,"disableEffect",lua_ax_base_Label_disableEffect);
        tolua_function(tolua_S,"isShadowEnabled",lua_ax_base_Label_isShadowEnabled);
        tolua_function(tolua_S,"getShadowOffset",lua_ax_base_Label_getShadowOffset);
        tolua_function(tolua_S,"getShadowBlurRadius",lua_ax_base_Label_getShadowBlurRadius);
        tolua_function(tolua_S,"getShadowColor",lua_ax_base_Label_getShadowColor);
        tolua_function(tolua_S,"getOutlineSize",lua_ax_base_Label_getOutlineSize);
        tolua_function(tolua_S,"getLabelEffectType",lua_ax_base_Label_getLabelEffectType);
        tolua_function(tolua_S,"getEffectColor",lua_ax_base_Label_getEffectColor);
        tolua_function(tolua_S,"setAlignment",lua_ax_base_Label_setAlignment);
        tolua_function(tolua_S,"getTextAlignment",lua_ax_base_Label_getTextAlignment);
        tolua_function(tolua_S,"setHorizontalAlignment",lua_ax_base_Label_setHorizontalAlignment);
        tolua_function(tolua_S,"getHorizontalAlignment",lua_ax_base_Label_getHorizontalAlignment);
        tolua_function(tolua_S,"setVerticalAlignment",lua_ax_base_Label_setVerticalAlignment);
        tolua_function(tolua_S,"getVerticalAlignment",lua_ax_base_Label_getVerticalAlignment);
        tolua_function(tolua_S,"setLineBreakWithoutSpace",lua_ax_base_Label_setLineBreakWithoutSpace);
        tolua_function(tolua_S,"setMaxLineWidth",lua_ax_base_Label_setMaxLineWidth);
        tolua_function(tolua_S,"getMaxLineWidth",lua_ax_base_Label_getMaxLineWidth);
        tolua_function(tolua_S,"setTTFFaceSize",lua_ax_base_Label_setTTFFaceSize);
        tolua_function(tolua_S,"getTTFFaceSize",lua_ax_base_Label_getTTFFaceSize);
        tolua_function(tolua_S,"setBMFontSize",lua_ax_base_Label_setBMFontSize);
        tolua_function(tolua_S,"getBMFontSize",lua_ax_base_Label_getBMFontSize);
        tolua_function(tolua_S,"enableWrap",lua_ax_base_Label_enableWrap);
        tolua_function(tolua_S,"isWrapEnabled",lua_ax_base_Label_isWrapEnabled);
        tolua_function(tolua_S,"setOverflow",lua_ax_base_Label_setOverflow);
        tolua_function(tolua_S,"getOverflow",lua_ax_base_Label_getOverflow);
        tolua_function(tolua_S,"setWidth",lua_ax_base_Label_setWidth);
        tolua_function(tolua_S,"getWidth",lua_ax_base_Label_getWidth);
        tolua_function(tolua_S,"setHeight",lua_ax_base_Label_setHeight);
        tolua_function(tolua_S,"getHeight",lua_ax_base_Label_getHeight);
        tolua_function(tolua_S,"setDimensions",lua_ax_base_Label_setDimensions);
        tolua_function(tolua_S,"getDimensions",lua_ax_base_Label_getDimensions);
        tolua_function(tolua_S,"updateContent",lua_ax_base_Label_updateContent);
        tolua_function(tolua_S,"getLetter",lua_ax_base_Label_getLetter);
        tolua_function(tolua_S,"setClipMarginEnabled",lua_ax_base_Label_setClipMarginEnabled);
        tolua_function(tolua_S,"isClipMarginEnabled",lua_ax_base_Label_isClipMarginEnabled);
        tolua_function(tolua_S,"setLineHeight",lua_ax_base_Label_setLineHeight);
        tolua_function(tolua_S,"getLineHeight",lua_ax_base_Label_getLineHeight);
        tolua_function(tolua_S,"setLineSpacing",lua_ax_base_Label_setLineSpacing);
        tolua_function(tolua_S,"getLineSpacing",lua_ax_base_Label_getLineSpacing);
        tolua_function(tolua_S,"getLabelType",lua_ax_base_Label_getLabelType);
        tolua_function(tolua_S,"getRenderingFontSize",lua_ax_base_Label_getRenderingFontSize);
        tolua_function(tolua_S,"setAdditionalKerning",lua_ax_base_Label_setAdditionalKerning);
        tolua_function(tolua_S,"getAdditionalKerning",lua_ax_base_Label_getAdditionalKerning);
        tolua_function(tolua_S,"getFontAtlas",lua_ax_base_Label_getFontAtlas);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_Label_getBlendFunc);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_Label_setBlendFunc);
        tolua_function(tolua_S,"removeAllChildrenWithCleanup",lua_ax_base_Label_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"initWithTTF",lua_ax_base_Label_initWithTTF);
        tolua_function(tolua_S,"create", lua_ax_base_Label_create);
        tolua_function(tolua_S,"createWithSystemFont", lua_ax_base_Label_createWithSystemFont);
        tolua_function(tolua_S,"createWithBMFont", lua_ax_base_Label_createWithBMFont);
        tolua_function(tolua_S,"createWithCharMap", lua_ax_base_Label_createWithCharMap);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Label).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Label";
    g_typeCast[typeName] = "ax.Label";
    return 1;
}

int lua_ax_base_LabelAtlas_initWithString(lua_State* tolua_S)
{
    int argc = 0;
    ax::LabelAtlas* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LabelAtlas",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LabelAtlas*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LabelAtlas_initWithString'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.LabelAtlas:initWithString");

            if (!ok) { break; }
            bool ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LabelAtlas:initWithString",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LabelAtlas_initWithString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LabelAtlas_setString(lua_State* tolua_S)
{
    int argc = 0;
    ax::LabelAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LabelAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LabelAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LabelAtlas_setString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:setString");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LabelAtlas_setString'", nullptr);
            return 0;
        }
        cobj->setString(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LabelAtlas:setString",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LabelAtlas_setString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LabelAtlas_getString(lua_State* tolua_S)
{
    int argc = 0;
    ax::LabelAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LabelAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LabelAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LabelAtlas_getString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LabelAtlas_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LabelAtlas:getString",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LabelAtlas_getString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LabelAtlas_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.LabelAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:create");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.LabelAtlas:create");
            if (!ok) { break; }
            ax::LabelAtlas* ret = ax::LabelAtlas::create(arg0, arg1);
            object_to_luaval<ax::LabelAtlas>(tolua_S, "ax.LabelAtlas",(ax::LabelAtlas*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:create");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.LabelAtlas:create");
            if (!ok) { break; }
            ax::LabelAtlas* ret = ax::LabelAtlas::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::LabelAtlas>(tolua_S, "ax.LabelAtlas",(ax::LabelAtlas*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.LabelAtlas:create");
            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.LabelAtlas:create");
            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.LabelAtlas:create");
            if (!ok) { break; }
            ax::LabelAtlas* ret = ax::LabelAtlas::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::LabelAtlas>(tolua_S, "ax.LabelAtlas",(ax::LabelAtlas*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.LabelAtlas:create",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LabelAtlas_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_LabelAtlas_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LabelAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LabelAtlas_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::LabelAtlas();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.LabelAtlas");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LabelAtlas:LabelAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LabelAtlas_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_LabelAtlas_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (LabelAtlas)");
    return 0;
}

int lua_register_ax_base_LabelAtlas(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.LabelAtlas");
    tolua_cclass(tolua_S,"LabelAtlas","ax.LabelAtlas","ax.AtlasNode",nullptr);

    tolua_beginmodule(tolua_S,"LabelAtlas");
        tolua_function(tolua_S,"new",lua_ax_base_LabelAtlas_constructor);
        tolua_function(tolua_S,"initWithString",lua_ax_base_LabelAtlas_initWithString);
        tolua_function(tolua_S,"setString",lua_ax_base_LabelAtlas_setString);
        tolua_function(tolua_S,"getString",lua_ax_base_LabelAtlas_getString);
        tolua_function(tolua_S,"_create", lua_ax_base_LabelAtlas_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::LabelAtlas).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.LabelAtlas";
    g_typeCast[typeName] = "ax.LabelAtlas";
    return 1;
}

int lua_ax_base_Sprite_getBatchNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getBatchNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getBatchNode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBatchNode();
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getBatchNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getBatchNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setBatchNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setBatchNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteBatchNode* arg0;

        ok &= luaval_to_object<ax::SpriteBatchNode>(tolua_S, 2, "ax.SpriteBatchNode",&arg0, "ax.Sprite:setBatchNode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setBatchNode'", nullptr);
            return 0;
        }
        cobj->setBatchNode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setBatchNode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setBatchNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setTexture'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:setTexture");

            if (!ok) { break; }
            cobj->setTexture(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:setTexture");

            if (!ok) { break; }
            cobj->setTexture(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Sprite:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setTextureRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setTextureRect'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            ax::Rect arg0;
            ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Sprite:setTextureRect");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.Sprite:setTextureRect");

            if (!ok) { break; }
            ax::Vec2 arg2;
            ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.Sprite:setTextureRect");

            if (!ok) { break; }
            cobj->setTextureRect(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Rect arg0;
            ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Sprite:setTextureRect");

            if (!ok) { break; }
            cobj->setTextureRect(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Sprite:setTextureRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setTextureRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setVertexRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setVertexRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Sprite:setVertexRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setVertexRect'", nullptr);
            return 0;
        }
        cobj->setVertexRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setVertexRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setVertexRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setCenterRectNormalized(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setCenterRectNormalized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Sprite:setCenterRectNormalized");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setCenterRectNormalized'", nullptr);
            return 0;
        }
        cobj->setCenterRectNormalized(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setCenterRectNormalized",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setCenterRectNormalized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getCenterRectNormalized(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getCenterRectNormalized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getCenterRectNormalized'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCenterRectNormalized();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getCenterRectNormalized",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getCenterRectNormalized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setCenterRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setCenterRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.Sprite:setCenterRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setCenterRect'", nullptr);
            return 0;
        }
        cobj->setCenterRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setCenterRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setCenterRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getCenterRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getCenterRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getCenterRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCenterRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getCenterRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getCenterRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setSpriteFrame'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::SpriteFrame* arg0;
            ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.Sprite:setSpriteFrame");

            if (!ok) { break; }
            cobj->setSpriteFrame(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:setSpriteFrame");

            if (!ok) { break; }
            cobj->setSpriteFrame(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Sprite:setSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isFrameDisplayed(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isFrameDisplayed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.Sprite:isFrameDisplayed");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isFrameDisplayed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFrameDisplayed(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isFrameDisplayed",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isFrameDisplayed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getSpriteFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpriteFrame();
        object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getSpriteFrame",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setDisplayFrameWithAnimationName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setDisplayFrameWithAnimationName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        unsigned int arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:setDisplayFrameWithAnimationName");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Sprite:setDisplayFrameWithAnimationName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setDisplayFrameWithAnimationName'", nullptr);
            return 0;
        }
        cobj->setDisplayFrameWithAnimationName(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setDisplayFrameWithAnimationName",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setDisplayFrameWithAnimationName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isDirty(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isDirty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isDirty'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isDirty();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isDirty",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isDirty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setDirty(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setDirty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setDirty");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setDirty'", nullptr);
            return 0;
        }
        cobj->setDirty(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setDirty",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setDirty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:removeAllChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_removeAllChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:removeAllChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isTextureRectRotated(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isTextureRectRotated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isTextureRectRotated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isTextureRectRotated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isTextureRectRotated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isTextureRectRotated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getAtlasIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getAtlasIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getAtlasIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAtlasIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getAtlasIndex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getAtlasIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setAtlasIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setAtlasIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Sprite:setAtlasIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setAtlasIndex'", nullptr);
            return 0;
        }
        cobj->setAtlasIndex(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setAtlasIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setAtlasIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getTextureRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getTextureRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getTextureRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getTextureRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getTextureRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getTextureAtlas'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureAtlas();
        object_to_luaval<ax::TextureAtlas>(tolua_S, "ax.TextureAtlas",(ax::TextureAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getTextureAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextureAtlas* arg0;

        ok &= luaval_to_object<ax::TextureAtlas>(tolua_S, 2, "ax.TextureAtlas",&arg0, "ax.Sprite:setTextureAtlas");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setTextureAtlas'", nullptr);
            return 0;
        }
        cobj->setTextureAtlas(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setTextureAtlas",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getOffsetPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getOffsetPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getOffsetPosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOffsetPosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getOffsetPosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getOffsetPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isFlippedX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isFlippedX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isFlippedX'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFlippedX();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isFlippedX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isFlippedX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setFlippedX(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setFlippedX'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setFlippedX");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setFlippedX'", nullptr);
            return 0;
        }
        cobj->setFlippedX(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setFlippedX",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setFlippedX'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isFlippedY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isFlippedY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isFlippedY'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFlippedY();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isFlippedY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isFlippedY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setFlippedY(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setFlippedY'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setFlippedY");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setFlippedY'", nullptr);
            return 0;
        }
        cobj->setFlippedY(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setFlippedY",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setFlippedY'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setStretchEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setStretchEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setStretchEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setStretchEnabled'", nullptr);
            return 0;
        }
        cobj->setStretchEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setStretchEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setStretchEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_isStretchEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_isStretchEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_isStretchEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStretchEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:isStretchEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_isStretchEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.Sprite:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getResourceType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getResourceType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getResourceType'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getResourceType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getResourceType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getResourceType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_getResourceName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_getResourceName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_getResourceName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getResourceName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:getResourceName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_getResourceName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_initWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_initWithTexture'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            bool ret = cobj->initWithTexture(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            bool ret = cobj->initWithTexture(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Sprite:initWithTexture");

            if (!ok) { break; }
            bool ret = cobj->initWithTexture(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Sprite:initWithTexture",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_initWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_initWithSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_initWithSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.Sprite:initWithSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_initWithSpriteFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrame(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:initWithSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_initWithSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_initWithSpriteFrameName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_initWithSpriteFrameName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:initWithSpriteFrameName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_initWithSpriteFrameName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSpriteFrameName(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:initWithSpriteFrameName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_initWithSpriteFrameName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_initWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_initWithFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:initWithFile");

            if (!ok) { break; }
            ax::backend::PixelFormat arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Sprite:initWithFile");

            if (!ok) { break; }
            bool ret = cobj->initWithFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:initWithFile");

            if (!ok) { break; }
            bool ret = cobj->initWithFile(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:initWithFile");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Sprite:initWithFile");

            if (!ok) { break; }
            bool ret = cobj->initWithFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Sprite:initWithFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_initWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setVertexLayout(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setVertexLayout'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setVertexLayout'", nullptr);
            return 0;
        }
        cobj->setVertexLayout();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setVertexLayout",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setVertexLayout'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setAutoUpdatePS(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setAutoUpdatePS'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setAutoUpdatePS");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setAutoUpdatePS'", nullptr);
            return 0;
        }
        cobj->setAutoUpdatePS(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setAutoUpdatePS",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setAutoUpdatePS'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_setAutoSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Sprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Sprite_setAutoSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Sprite:setAutoSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_setAutoSize'", nullptr);
            return 0;
        }
        cobj->setAutoSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:setAutoSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_setAutoSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Sprite_createWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            ax::Sprite* ret = ax::Sprite::createWithTexture(arg0, arg1);
            object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            ax::Sprite* ret = ax::Sprite::createWithTexture(arg0, arg1, arg2);
            object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::Texture2D* arg0;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.Sprite:createWithTexture");
            if (!ok) { break; }
            ax::Sprite* ret = ax::Sprite::createWithTexture(arg0);
            object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Sprite:createWithTexture",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_createWithTexture'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Sprite_createWithSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::SpriteFrame* arg0;
        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.Sprite:createWithSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_createWithSpriteFrame'", nullptr);
            return 0;
        }
        auto&& ret = ax::Sprite::createWithSpriteFrame(arg0);
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Sprite:createWithSpriteFrame",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_createWithSpriteFrame'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Sprite_createWithSpriteFrameName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Sprite",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Sprite:createWithSpriteFrameName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_createWithSpriteFrameName'", nullptr);
            return 0;
        }
        auto&& ret = ax::Sprite::createWithSpriteFrameName(arg0);
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Sprite:createWithSpriteFrameName",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_createWithSpriteFrameName'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Sprite_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Sprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Sprite_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Sprite();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Sprite");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Sprite:Sprite",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Sprite_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Sprite_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Sprite)");
    return 0;
}

int lua_register_ax_base_Sprite(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Sprite");
    tolua_cclass(tolua_S,"Sprite","ax.Sprite","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Sprite");
        tolua_function(tolua_S,"new",lua_ax_base_Sprite_constructor);
        tolua_function(tolua_S,"getBatchNode",lua_ax_base_Sprite_getBatchNode);
        tolua_function(tolua_S,"setBatchNode",lua_ax_base_Sprite_setBatchNode);
        tolua_function(tolua_S,"setTexture",lua_ax_base_Sprite_setTexture);
        tolua_function(tolua_S,"getTexture",lua_ax_base_Sprite_getTexture);
        tolua_function(tolua_S,"setTextureRect",lua_ax_base_Sprite_setTextureRect);
        tolua_function(tolua_S,"setVertexRect",lua_ax_base_Sprite_setVertexRect);
        tolua_function(tolua_S,"setCenterRectNormalized",lua_ax_base_Sprite_setCenterRectNormalized);
        tolua_function(tolua_S,"getCenterRectNormalized",lua_ax_base_Sprite_getCenterRectNormalized);
        tolua_function(tolua_S,"setCenterRect",lua_ax_base_Sprite_setCenterRect);
        tolua_function(tolua_S,"getCenterRect",lua_ax_base_Sprite_getCenterRect);
        tolua_function(tolua_S,"setSpriteFrame",lua_ax_base_Sprite_setSpriteFrame);
        tolua_function(tolua_S,"isFrameDisplayed",lua_ax_base_Sprite_isFrameDisplayed);
        tolua_function(tolua_S,"getSpriteFrame",lua_ax_base_Sprite_getSpriteFrame);
        tolua_function(tolua_S,"setDisplayFrameWithAnimationName",lua_ax_base_Sprite_setDisplayFrameWithAnimationName);
        tolua_function(tolua_S,"isDirty",lua_ax_base_Sprite_isDirty);
        tolua_function(tolua_S,"setDirty",lua_ax_base_Sprite_setDirty);
        tolua_function(tolua_S,"removeAllChildrenWithCleanup",lua_ax_base_Sprite_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"isTextureRectRotated",lua_ax_base_Sprite_isTextureRectRotated);
        tolua_function(tolua_S,"getAtlasIndex",lua_ax_base_Sprite_getAtlasIndex);
        tolua_function(tolua_S,"setAtlasIndex",lua_ax_base_Sprite_setAtlasIndex);
        tolua_function(tolua_S,"getTextureRect",lua_ax_base_Sprite_getTextureRect);
        tolua_function(tolua_S,"getTextureAtlas",lua_ax_base_Sprite_getTextureAtlas);
        tolua_function(tolua_S,"setTextureAtlas",lua_ax_base_Sprite_setTextureAtlas);
        tolua_function(tolua_S,"getOffsetPosition",lua_ax_base_Sprite_getOffsetPosition);
        tolua_function(tolua_S,"isFlippedX",lua_ax_base_Sprite_isFlippedX);
        tolua_function(tolua_S,"setFlippedX",lua_ax_base_Sprite_setFlippedX);
        tolua_function(tolua_S,"isFlippedY",lua_ax_base_Sprite_isFlippedY);
        tolua_function(tolua_S,"setFlippedY",lua_ax_base_Sprite_setFlippedY);
        tolua_function(tolua_S,"setStretchEnabled",lua_ax_base_Sprite_setStretchEnabled);
        tolua_function(tolua_S,"isStretchEnabled",lua_ax_base_Sprite_isStretchEnabled);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_Sprite_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_Sprite_getBlendFunc);
        tolua_function(tolua_S,"getResourceType",lua_ax_base_Sprite_getResourceType);
        tolua_function(tolua_S,"getResourceName",lua_ax_base_Sprite_getResourceName);
        tolua_function(tolua_S,"initWithTexture",lua_ax_base_Sprite_initWithTexture);
        tolua_function(tolua_S,"initWithSpriteFrame",lua_ax_base_Sprite_initWithSpriteFrame);
        tolua_function(tolua_S,"initWithSpriteFrameName",lua_ax_base_Sprite_initWithSpriteFrameName);
        tolua_function(tolua_S,"initWithFile",lua_ax_base_Sprite_initWithFile);
        tolua_function(tolua_S,"setVertexLayout",lua_ax_base_Sprite_setVertexLayout);
        tolua_function(tolua_S,"setAutoUpdatePS",lua_ax_base_Sprite_setAutoUpdatePS);
        tolua_function(tolua_S,"setAutoSize",lua_ax_base_Sprite_setAutoSize);
        tolua_function(tolua_S,"createWithTexture", lua_ax_base_Sprite_createWithTexture);
        tolua_function(tolua_S,"createWithSpriteFrame", lua_ax_base_Sprite_createWithSpriteFrame);
        tolua_function(tolua_S,"createWithSpriteFrameName", lua_ax_base_Sprite_createWithSpriteFrameName);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Sprite).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Sprite";
    g_typeCast[typeName] = "ax.Sprite";
    return 1;
}

int lua_ax_base_Layer_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Layer",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Layer_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Layer::create();
        object_to_luaval<ax::Layer>(tolua_S, "ax.Layer",(ax::Layer*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Layer:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Layer_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Layer_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Layer)");
    return 0;
}

int lua_register_ax_base_Layer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Layer");
    tolua_cclass(tolua_S,"Layer","ax.Layer","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Layer");
        tolua_function(tolua_S,"create", lua_ax_base_Layer_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Layer).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Layer";
    g_typeCast[typeName] = "ax.Layer";
    return 1;
}

int lua_ax_base_LayerColor_changeWidth(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerColor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerColor",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerColor*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerColor_changeWidth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.LayerColor:changeWidth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerColor_changeWidth'", nullptr);
            return 0;
        }
        cobj->changeWidth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerColor:changeWidth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_changeWidth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerColor_changeHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerColor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerColor",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerColor*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerColor_changeHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.LayerColor:changeHeight");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerColor_changeHeight'", nullptr);
            return 0;
        }
        cobj->changeHeight(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerColor:changeHeight",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_changeHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerColor_changeWidthAndHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerColor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerColor",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerColor*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerColor_changeWidthAndHeight'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.LayerColor:changeWidthAndHeight");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.LayerColor:changeWidthAndHeight");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerColor_changeWidthAndHeight'", nullptr);
            return 0;
        }
        cobj->changeWidthAndHeight(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerColor:changeWidthAndHeight",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_changeWidthAndHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerColor_initWithColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerColor* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerColor",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LayerColor*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerColor_initWithColor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerColor:initWithColor");

            if (!ok) { break; }
            bool ret = cobj->initWithColor(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerColor:initWithColor");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.LayerColor:initWithColor");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.LayerColor:initWithColor");

            if (!ok) { break; }
            bool ret = cobj->initWithColor(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LayerColor:initWithColor",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_initWithColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerColor_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.LayerColor",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerColor:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.LayerColor:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.LayerColor:create");
            if (!ok) { break; }
            ax::LayerColor* ret = ax::LayerColor::create(arg0, arg1, arg2);
            object_to_luaval<ax::LayerColor>(tolua_S, "ax.LayerColor",(ax::LayerColor*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::LayerColor* ret = ax::LayerColor::create();
            object_to_luaval<ax::LayerColor>(tolua_S, "ax.LayerColor",(ax::LayerColor*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerColor:create");
            if (!ok) { break; }
            ax::LayerColor* ret = ax::LayerColor::create(arg0);
            object_to_luaval<ax::LayerColor>(tolua_S, "ax.LayerColor",(ax::LayerColor*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.LayerColor:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_LayerColor_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerColor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerColor_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::LayerColor();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.LayerColor");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerColor:LayerColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerColor_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_LayerColor_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (LayerColor)");
    return 0;
}

int lua_register_ax_base_LayerColor(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.LayerColor");
    tolua_cclass(tolua_S,"LayerColor","ax.LayerColor","ax.Sprite",nullptr);

    tolua_beginmodule(tolua_S,"LayerColor");
        tolua_function(tolua_S,"new",lua_ax_base_LayerColor_constructor);
        tolua_function(tolua_S,"changeWidth",lua_ax_base_LayerColor_changeWidth);
        tolua_function(tolua_S,"changeHeight",lua_ax_base_LayerColor_changeHeight);
        tolua_function(tolua_S,"changeWidthAndHeight",lua_ax_base_LayerColor_changeWidthAndHeight);
        tolua_function(tolua_S,"initWithColor",lua_ax_base_LayerColor_initWithColor);
        tolua_function(tolua_S,"create", lua_ax_base_LayerColor_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::LayerColor).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.LayerColor";
    g_typeCast[typeName] = "ax.LayerColor";
    return 1;
}

int lua_ax_base_LayerGradient_setCompressedInterpolation(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setCompressedInterpolation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.LayerGradient:setCompressedInterpolation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setCompressedInterpolation'", nullptr);
            return 0;
        }
        cobj->setCompressedInterpolation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setCompressedInterpolation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setCompressedInterpolation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_isCompressedInterpolation(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_isCompressedInterpolation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_isCompressedInterpolation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isCompressedInterpolation();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:isCompressedInterpolation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_isCompressedInterpolation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_setStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setStartColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.LayerGradient:setStartColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setStartColor'", nullptr);
            return 0;
        }
        cobj->setStartColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setStartColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_getStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_getStartColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_getStartColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartColor();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:getStartColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_getStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_setEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setEndColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.LayerGradient:setEndColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setEndColor'", nullptr);
            return 0;
        }
        cobj->setEndColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setEndColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_getEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_getEndColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_getEndColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndColor();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:getEndColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_getEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_setStartOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setStartOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.LayerGradient:setStartOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setStartOpacity'", nullptr);
            return 0;
        }
        cobj->setStartOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setStartOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setStartOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_getStartOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_getStartOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_getStartOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:getStartOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_getStartOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_setEndOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setEndOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.LayerGradient:setEndOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setEndOpacity'", nullptr);
            return 0;
        }
        cobj->setEndOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setEndOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setEndOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_getEndOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_getEndOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_getEndOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:getEndOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_getEndOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_setVector(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_setVector'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.LayerGradient:setVector");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_setVector'", nullptr);
            return 0;
        }
        cobj->setVector(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:setVector",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_setVector'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_getVector(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_getVector'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_getVector'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVector();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:getVector",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_getVector'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_initWithColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LayerGradient*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerGradient_initWithColor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerGradient:initWithColor");

            if (!ok) { break; }
            ax::Color4B arg1;
            ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerGradient:initWithColor");

            if (!ok) { break; }
            ax::Vec2 arg2;
            ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.LayerGradient:initWithColor");

            if (!ok) { break; }
            bool ret = cobj->initWithColor(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerGradient:initWithColor");

            if (!ok) { break; }
            ax::Color4B arg1;
            ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerGradient:initWithColor");

            if (!ok) { break; }
            bool ret = cobj->initWithColor(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LayerGradient:initWithColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_initWithColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerGradient_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.LayerGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerGradient:create");
            if (!ok) { break; }
            ax::Color4B arg1;
            ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerGradient:create");
            if (!ok) { break; }
            ax::LayerGradient* ret = ax::LayerGradient::create(arg0, arg1);
            object_to_luaval<ax::LayerGradient>(tolua_S, "ax.LayerGradient",(ax::LayerGradient*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::LayerGradient* ret = ax::LayerGradient::create();
            object_to_luaval<ax::LayerGradient>(tolua_S, "ax.LayerGradient",(ax::LayerGradient*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerGradient:create");
            if (!ok) { break; }
            ax::Color4B arg1;
            ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerGradient:create");
            if (!ok) { break; }
            ax::Vec2 arg2;
            ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.LayerGradient:create");
            if (!ok) { break; }
            ax::LayerGradient* ret = ax::LayerGradient::create(arg0, arg1, arg2);
            object_to_luaval<ax::LayerGradient>(tolua_S, "ax.LayerGradient",(ax::LayerGradient*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.LayerGradient:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_LayerGradient_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerGradient_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::LayerGradient();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.LayerGradient");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerGradient:LayerGradient",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerGradient_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_LayerGradient_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (LayerGradient)");
    return 0;
}

int lua_register_ax_base_LayerGradient(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.LayerGradient");
    tolua_cclass(tolua_S,"LayerGradient","ax.LayerGradient","ax.LayerColor",nullptr);

    tolua_beginmodule(tolua_S,"LayerGradient");
        tolua_function(tolua_S,"new",lua_ax_base_LayerGradient_constructor);
        tolua_function(tolua_S,"setCompressedInterpolation",lua_ax_base_LayerGradient_setCompressedInterpolation);
        tolua_function(tolua_S,"isCompressedInterpolation",lua_ax_base_LayerGradient_isCompressedInterpolation);
        tolua_function(tolua_S,"setStartColor",lua_ax_base_LayerGradient_setStartColor);
        tolua_function(tolua_S,"getStartColor",lua_ax_base_LayerGradient_getStartColor);
        tolua_function(tolua_S,"setEndColor",lua_ax_base_LayerGradient_setEndColor);
        tolua_function(tolua_S,"getEndColor",lua_ax_base_LayerGradient_getEndColor);
        tolua_function(tolua_S,"setStartOpacity",lua_ax_base_LayerGradient_setStartOpacity);
        tolua_function(tolua_S,"getStartOpacity",lua_ax_base_LayerGradient_getStartOpacity);
        tolua_function(tolua_S,"setEndOpacity",lua_ax_base_LayerGradient_setEndOpacity);
        tolua_function(tolua_S,"getEndOpacity",lua_ax_base_LayerGradient_getEndOpacity);
        tolua_function(tolua_S,"setVector",lua_ax_base_LayerGradient_setVector);
        tolua_function(tolua_S,"getVector",lua_ax_base_LayerGradient_getVector);
        tolua_function(tolua_S,"initWithColor",lua_ax_base_LayerGradient_initWithColor);
        tolua_function(tolua_S,"create", lua_ax_base_LayerGradient_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::LayerGradient).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.LayerGradient";
    g_typeCast[typeName] = "ax.LayerGradient";
    return 1;
}

int lua_ax_base_LayerRadialGradient_setStartOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setStartOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.LayerRadialGradient:setStartOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setStartOpacity'", nullptr);
            return 0;
        }
        cobj->setStartOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setStartOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setStartOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getStartOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getStartOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getStartOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getStartOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getStartOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setEndOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setEndOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        uint16_t arg0;

        ok &= luaval_to_uint16(tolua_S, 2,&arg0, "ax.LayerRadialGradient:setEndOpacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setEndOpacity'", nullptr);
            return 0;
        }
        cobj->setEndOpacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setEndOpacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setEndOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getEndOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getEndOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getEndOpacity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndOpacity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getEndOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getEndOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.LayerRadialGradient:setRadius");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setRadius'", nullptr);
            return 0;
        }
        cobj->setRadius(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setRadius",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getRadius'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRadius();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getRadius",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setCenter(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setCenter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setCenter");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setCenter'", nullptr);
            return 0;
        }
        cobj->setCenter(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setCenter",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setCenter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getCenter(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getCenter'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getCenter'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCenter();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getCenter",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getCenter'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setExpand(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setExpand'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.LayerRadialGradient:setExpand");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setExpand'", nullptr);
            return 0;
        }
        cobj->setExpand(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setExpand",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setExpand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getExpand(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getExpand'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getExpand'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getExpand();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getExpand",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getExpand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setStartColor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setStartColor");

            if (!ok) { break; }
            cobj->setStartColor(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Color3B arg0;
            ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setStartColor");

            if (!ok) { break; }
            cobj->setStartColor(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LayerRadialGradient:setStartColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getStartColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getStartColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartColor();
        color4b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getStartColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getStartColor3B(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getStartColor3B'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getStartColor3B'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartColor3B();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getStartColor3B",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getStartColor3B'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setEndColor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setEndColor");

            if (!ok) { break; }
            cobj->setEndColor(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Color3B arg0;
            ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setEndColor");

            if (!ok) { break; }
            cobj->setEndColor(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LayerRadialGradient:setEndColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getEndColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getEndColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndColor();
        color4b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getEndColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getEndColor3B(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getEndColor3B'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getEndColor3B'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndColor3B();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getEndColor3B",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getEndColor3B'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.LayerRadialGradient:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_initWithColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerRadialGradient*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerRadialGradient_initWithColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        ax::Color4B arg0;
        ax::Color4B arg1;
        double arg2;
        ax::Vec2 arg3;
        double arg4;

        ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:initWithColor");

        ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerRadialGradient:initWithColor");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.LayerRadialGradient:initWithColor");

        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.LayerRadialGradient:initWithColor");

        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.LayerRadialGradient:initWithColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_initWithColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithColor(arg0, arg1, arg2, arg3, arg4);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:initWithColor",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_initWithColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerRadialGradient_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.LayerRadialGradient",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 0)
        {
            ax::LayerRadialGradient* ret = ax::LayerRadialGradient::create();
            object_to_luaval<ax::LayerRadialGradient>(tolua_S, "ax.LayerRadialGradient",(ax::LayerRadialGradient*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            ax::Color4B arg0;
            ok &=luaval_to_color4b(tolua_S, 2, &arg0, "ax.LayerRadialGradient:create");
            if (!ok) { break; }
            ax::Color4B arg1;
            ok &=luaval_to_color4b(tolua_S, 3, &arg1, "ax.LayerRadialGradient:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.LayerRadialGradient:create");
            if (!ok) { break; }
            ax::Vec2 arg3;
            ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.LayerRadialGradient:create");
            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.LayerRadialGradient:create");
            if (!ok) { break; }
            ax::LayerRadialGradient* ret = ax::LayerRadialGradient::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::LayerRadialGradient>(tolua_S, "ax.LayerRadialGradient",(ax::LayerRadialGradient*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.LayerRadialGradient:create",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_LayerRadialGradient_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerRadialGradient* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerRadialGradient_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::LayerRadialGradient();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.LayerRadialGradient");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerRadialGradient:LayerRadialGradient",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerRadialGradient_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_LayerRadialGradient_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (LayerRadialGradient)");
    return 0;
}

int lua_register_ax_base_LayerRadialGradient(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.LayerRadialGradient");
    tolua_cclass(tolua_S,"LayerRadialGradient","ax.LayerRadialGradient","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"LayerRadialGradient");
        tolua_function(tolua_S,"new",lua_ax_base_LayerRadialGradient_constructor);
        tolua_function(tolua_S,"setStartOpacity",lua_ax_base_LayerRadialGradient_setStartOpacity);
        tolua_function(tolua_S,"getStartOpacity",lua_ax_base_LayerRadialGradient_getStartOpacity);
        tolua_function(tolua_S,"setEndOpacity",lua_ax_base_LayerRadialGradient_setEndOpacity);
        tolua_function(tolua_S,"getEndOpacity",lua_ax_base_LayerRadialGradient_getEndOpacity);
        tolua_function(tolua_S,"setRadius",lua_ax_base_LayerRadialGradient_setRadius);
        tolua_function(tolua_S,"getRadius",lua_ax_base_LayerRadialGradient_getRadius);
        tolua_function(tolua_S,"setCenter",lua_ax_base_LayerRadialGradient_setCenter);
        tolua_function(tolua_S,"getCenter",lua_ax_base_LayerRadialGradient_getCenter);
        tolua_function(tolua_S,"setExpand",lua_ax_base_LayerRadialGradient_setExpand);
        tolua_function(tolua_S,"getExpand",lua_ax_base_LayerRadialGradient_getExpand);
        tolua_function(tolua_S,"setStartColor",lua_ax_base_LayerRadialGradient_setStartColor);
        tolua_function(tolua_S,"getStartColor",lua_ax_base_LayerRadialGradient_getStartColor);
        tolua_function(tolua_S,"getStartColor3B",lua_ax_base_LayerRadialGradient_getStartColor3B);
        tolua_function(tolua_S,"setEndColor",lua_ax_base_LayerRadialGradient_setEndColor);
        tolua_function(tolua_S,"getEndColor",lua_ax_base_LayerRadialGradient_getEndColor);
        tolua_function(tolua_S,"getEndColor3B",lua_ax_base_LayerRadialGradient_getEndColor3B);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_LayerRadialGradient_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_LayerRadialGradient_getBlendFunc);
        tolua_function(tolua_S,"initWithColor",lua_ax_base_LayerRadialGradient_initWithColor);
        tolua_function(tolua_S,"create", lua_ax_base_LayerRadialGradient_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::LayerRadialGradient).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.LayerRadialGradient";
    g_typeCast[typeName] = "ax.LayerRadialGradient";
    return 1;
}

int lua_ax_base_LayerMultiplex_addLayer(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerMultiplex* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerMultiplex",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerMultiplex*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerMultiplex_addLayer'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.LayerMultiplex:addLayer");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerMultiplex_addLayer'", nullptr);
            return 0;
        }
        cobj->addLayer(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerMultiplex:addLayer",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerMultiplex_addLayer'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerMultiplex_switchTo(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerMultiplex* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerMultiplex",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::LayerMultiplex*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerMultiplex_switchTo'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.LayerMultiplex:switchTo");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.LayerMultiplex:switchTo");

            if (!ok) { break; }
            cobj->switchTo(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.LayerMultiplex:switchTo");

            if (!ok) { break; }
            cobj->switchTo(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.LayerMultiplex:switchTo",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerMultiplex_switchTo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerMultiplex_switchToAndReleaseMe(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerMultiplex* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerMultiplex",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerMultiplex*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerMultiplex_switchToAndReleaseMe'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.LayerMultiplex:switchToAndReleaseMe");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerMultiplex_switchToAndReleaseMe'", nullptr);
            return 0;
        }
        cobj->switchToAndReleaseMe(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerMultiplex:switchToAndReleaseMe",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerMultiplex_switchToAndReleaseMe'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerMultiplex_initWithArray(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerMultiplex* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.LayerMultiplex",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::LayerMultiplex*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_LayerMultiplex_initWithArray'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::Node *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.LayerMultiplex:initWithArray");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerMultiplex_initWithArray'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithArray(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerMultiplex:initWithArray",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerMultiplex_initWithArray'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_LayerMultiplex_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::LayerMultiplex* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_LayerMultiplex_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::LayerMultiplex();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.LayerMultiplex");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.LayerMultiplex:LayerMultiplex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_LayerMultiplex_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_LayerMultiplex_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (LayerMultiplex)");
    return 0;
}

int lua_register_ax_base_LayerMultiplex(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.LayerMultiplex");
    tolua_cclass(tolua_S,"LayerMultiplex","ax.LayerMultiplex","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"LayerMultiplex");
        tolua_function(tolua_S,"new",lua_ax_base_LayerMultiplex_constructor);
        tolua_function(tolua_S,"addLayer",lua_ax_base_LayerMultiplex_addLayer);
        tolua_function(tolua_S,"switchTo",lua_ax_base_LayerMultiplex_switchTo);
        tolua_function(tolua_S,"switchToAndReleaseMe",lua_ax_base_LayerMultiplex_switchToAndReleaseMe);
        tolua_function(tolua_S,"initWithArray",lua_ax_base_LayerMultiplex_initWithArray);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::LayerMultiplex).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.LayerMultiplex";
    g_typeCast[typeName] = "ax.LayerMultiplex";
    return 1;
}

int lua_ax_base_MenuItem_rect(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_rect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_rect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->rect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:rect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_rect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_activate(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_activate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_activate'", nullptr);
            return 0;
        }
        cobj->activate();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:activate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_activate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_selected(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_selected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_selected'", nullptr);
            return 0;
        }
        cobj->selected();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:selected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_selected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_unselected(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_unselected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_unselected'", nullptr);
            return 0;
        }
        cobj->unselected();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:unselected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_unselected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_isEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.MenuItem:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_isSelected(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItem_isSelected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_isSelected'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSelected();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:isSelected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_isSelected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItem_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItem();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItem");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItem:MenuItem",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItem_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItem_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItem)");
    return 0;
}

int lua_register_ax_base_MenuItem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItem");
    tolua_cclass(tolua_S,"MenuItem","ax.MenuItem","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"MenuItem");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItem_constructor);
        tolua_function(tolua_S,"rect",lua_ax_base_MenuItem_rect);
        tolua_function(tolua_S,"activate",lua_ax_base_MenuItem_activate);
        tolua_function(tolua_S,"selected",lua_ax_base_MenuItem_selected);
        tolua_function(tolua_S,"unselected",lua_ax_base_MenuItem_unselected);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_MenuItem_isEnabled);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_MenuItem_setEnabled);
        tolua_function(tolua_S,"isSelected",lua_ax_base_MenuItem_isSelected);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItem).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItem";
    g_typeCast[typeName] = "ax.MenuItem";
    return 1;
}

int lua_ax_base_MenuItemLabel_setString(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_setString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemLabel:setString");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_setString'", nullptr);
            return 0;
        }
        cobj->setString(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:setString",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_setString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_getString(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_getString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_getString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getString();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:getString",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_getString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_getDisabledColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_getDisabledColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_getDisabledColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDisabledColor();
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:getDisabledColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_getDisabledColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_setDisabledColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_setDisabledColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.MenuItemLabel:setDisabledColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_setDisabledColor'", nullptr);
            return 0;
        }
        cobj->setDisabledColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:setDisabledColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_setDisabledColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_getLabel(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_getLabel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_getLabel'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLabel();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:getLabel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_getLabel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_setLabel(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_setLabel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemLabel:setLabel");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_setLabel'", nullptr);
            return 0;
        }
        cobj->setLabel(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:setLabel",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_setLabel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_initWithLabel(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemLabel",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemLabel*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemLabel_initWithLabel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Node* arg0;
        std::function<void (ax::Object *)> arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemLabel:initWithLabel");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_initWithLabel'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithLabel(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:initWithLabel",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_initWithLabel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemLabel_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemLabel* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemLabel_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemLabel();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemLabel");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemLabel:MenuItemLabel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemLabel_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemLabel_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemLabel)");
    return 0;
}

int lua_register_ax_base_MenuItemLabel(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemLabel");
    tolua_cclass(tolua_S,"MenuItemLabel","ax.MenuItemLabel","ax.MenuItem",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemLabel");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemLabel_constructor);
        tolua_function(tolua_S,"setString",lua_ax_base_MenuItemLabel_setString);
        tolua_function(tolua_S,"getString",lua_ax_base_MenuItemLabel_getString);
        tolua_function(tolua_S,"getDisabledColor",lua_ax_base_MenuItemLabel_getDisabledColor);
        tolua_function(tolua_S,"setDisabledColor",lua_ax_base_MenuItemLabel_setDisabledColor);
        tolua_function(tolua_S,"getLabel",lua_ax_base_MenuItemLabel_getLabel);
        tolua_function(tolua_S,"setLabel",lua_ax_base_MenuItemLabel_setLabel);
        tolua_function(tolua_S,"initWithLabel",lua_ax_base_MenuItemLabel_initWithLabel);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemLabel).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemLabel";
    g_typeCast[typeName] = "ax.MenuItemLabel";
    return 1;
}

int lua_ax_base_MenuItemAtlasFont_initWithString(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemAtlasFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemAtlasFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemAtlasFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemAtlasFont_initWithString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 6) 
    {
        std::string_view arg0;
        std::string_view arg1;
        int arg2;
        int arg3;
        int32_t arg4;
        std::function<void (ax::Object *)> arg5;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemAtlasFont:initWithString");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.MenuItemAtlasFont:initWithString");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.MenuItemAtlasFont:initWithString");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.MenuItemAtlasFont:initWithString");

        ok &= luaval_to_int32(tolua_S, 6,&arg4, "ax.MenuItemAtlasFont:initWithString");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemAtlasFont_initWithString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemAtlasFont:initWithString",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemAtlasFont_initWithString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemAtlasFont_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemAtlasFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemAtlasFont_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemAtlasFont();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemAtlasFont");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemAtlasFont:MenuItemAtlasFont",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemAtlasFont_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemAtlasFont_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemAtlasFont)");
    return 0;
}

int lua_register_ax_base_MenuItemAtlasFont(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemAtlasFont");
    tolua_cclass(tolua_S,"MenuItemAtlasFont","ax.MenuItemAtlasFont","ax.MenuItemLabel",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemAtlasFont");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemAtlasFont_constructor);
        tolua_function(tolua_S,"initWithString",lua_ax_base_MenuItemAtlasFont_initWithString);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemAtlasFont).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemAtlasFont";
    g_typeCast[typeName] = "ax.MenuItemAtlasFont";
    return 1;
}

int lua_ax_base_MenuItemFont_setFontSizeObj(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemFont_setFontSizeObj'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.MenuItemFont:setFontSizeObj");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_setFontSizeObj'", nullptr);
            return 0;
        }
        cobj->setFontSizeObj(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:setFontSizeObj",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_setFontSizeObj'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemFont_getFontSizeObj(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemFont_getFontSizeObj'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_getFontSizeObj'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFontSizeObj();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:getFontSizeObj",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_getFontSizeObj'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemFont_setFontNameObj(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemFont_setFontNameObj'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemFont:setFontNameObj");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_setFontNameObj'", nullptr);
            return 0;
        }
        cobj->setFontNameObj(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:setFontNameObj",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_setFontNameObj'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemFont_getFontNameObj(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemFont_getFontNameObj'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_getFontNameObj'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFontNameObj();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:getFontNameObj",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_getFontNameObj'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemFont_initWithString(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemFont*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemFont_initWithString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::function<void (ax::Object *)> arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemFont:initWithString");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_initWithString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithString(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:initWithString",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_initWithString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemFont_setFontSize(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.MenuItemFont:setFontSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_setFontSize'", nullptr);
            return 0;
        }
        ax::MenuItemFont::setFontSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.MenuItemFont:setFontSize",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_setFontSize'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MenuItemFont_getFontSize(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_getFontSize'", nullptr);
            return 0;
        }
        auto&& ret = ax::MenuItemFont::getFontSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.MenuItemFont:getFontSize",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_getFontSize'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MenuItemFont_setFontName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemFont:setFontName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_setFontName'", nullptr);
            return 0;
        }
        ax::MenuItemFont::setFontName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.MenuItemFont:setFontName",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_setFontName'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MenuItemFont_getFontName(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MenuItemFont",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_getFontName'", nullptr);
            return 0;
        }
        auto&& ret = ax::MenuItemFont::getFontName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.MenuItemFont:getFontName",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_getFontName'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MenuItemFont_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemFont* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemFont_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemFont();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemFont");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemFont:MenuItemFont",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemFont_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemFont_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemFont)");
    return 0;
}

int lua_register_ax_base_MenuItemFont(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemFont");
    tolua_cclass(tolua_S,"MenuItemFont","ax.MenuItemFont","ax.MenuItemLabel",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemFont");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemFont_constructor);
        tolua_function(tolua_S,"setFontSizeObj",lua_ax_base_MenuItemFont_setFontSizeObj);
        tolua_function(tolua_S,"getFontSizeObj",lua_ax_base_MenuItemFont_getFontSizeObj);
        tolua_function(tolua_S,"setFontNameObj",lua_ax_base_MenuItemFont_setFontNameObj);
        tolua_function(tolua_S,"getFontNameObj",lua_ax_base_MenuItemFont_getFontNameObj);
        tolua_function(tolua_S,"initWithString",lua_ax_base_MenuItemFont_initWithString);
        tolua_function(tolua_S,"setFontSize", lua_ax_base_MenuItemFont_setFontSize);
        tolua_function(tolua_S,"getFontSize", lua_ax_base_MenuItemFont_getFontSize);
        tolua_function(tolua_S,"setFontName", lua_ax_base_MenuItemFont_setFontName);
        tolua_function(tolua_S,"getFontName", lua_ax_base_MenuItemFont_getFontName);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemFont).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemFont";
    g_typeCast[typeName] = "ax.MenuItemFont";
    return 1;
}

int lua_ax_base_MenuItemSprite_getNormalImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_getNormalImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_getNormalImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNormalImage();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:getNormalImage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_getNormalImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_setNormalImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_setNormalImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemSprite:setNormalImage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_setNormalImage'", nullptr);
            return 0;
        }
        cobj->setNormalImage(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:setNormalImage",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_setNormalImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_getSelectedImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_getSelectedImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_getSelectedImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSelectedImage();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:getSelectedImage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_getSelectedImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_setSelectedImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_setSelectedImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemSprite:setSelectedImage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_setSelectedImage'", nullptr);
            return 0;
        }
        cobj->setSelectedImage(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:setSelectedImage",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_setSelectedImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_getDisabledImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_getDisabledImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_getDisabledImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDisabledImage();
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:getDisabledImage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_getDisabledImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_setDisabledImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_setDisabledImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemSprite:setDisabledImage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_setDisabledImage'", nullptr);
            return 0;
        }
        cobj->setDisabledImage(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:setDisabledImage",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_setDisabledImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_selected(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_selected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_selected'", nullptr);
            return 0;
        }
        cobj->selected();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:selected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_selected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_unselected(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_unselected'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_unselected'", nullptr);
            return 0;
        }
        cobj->unselected();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:unselected",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_unselected'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.MenuItemSprite:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_initWithNormalSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemSprite",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemSprite*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemSprite_initWithNormalSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ax::Node* arg0;
        ax::Node* arg1;
        ax::Node* arg2;
        std::function<void (ax::Object *)> arg3;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.MenuItemSprite:initWithNormalSprite");

        ok &= luaval_to_object<ax::Node>(tolua_S, 3, "ax.Node",&arg1, "ax.MenuItemSprite:initWithNormalSprite");

        ok &= luaval_to_object<ax::Node>(tolua_S, 4, "ax.Node",&arg2, "ax.MenuItemSprite:initWithNormalSprite");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_initWithNormalSprite'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithNormalSprite(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:initWithNormalSprite",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_initWithNormalSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemSprite_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemSprite* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemSprite_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemSprite();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemSprite");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemSprite:MenuItemSprite",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemSprite_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemSprite_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemSprite)");
    return 0;
}

int lua_register_ax_base_MenuItemSprite(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemSprite");
    tolua_cclass(tolua_S,"MenuItemSprite","ax.MenuItemSprite","ax.MenuItem",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemSprite");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemSprite_constructor);
        tolua_function(tolua_S,"getNormalImage",lua_ax_base_MenuItemSprite_getNormalImage);
        tolua_function(tolua_S,"setNormalImage",lua_ax_base_MenuItemSprite_setNormalImage);
        tolua_function(tolua_S,"getSelectedImage",lua_ax_base_MenuItemSprite_getSelectedImage);
        tolua_function(tolua_S,"setSelectedImage",lua_ax_base_MenuItemSprite_setSelectedImage);
        tolua_function(tolua_S,"getDisabledImage",lua_ax_base_MenuItemSprite_getDisabledImage);
        tolua_function(tolua_S,"setDisabledImage",lua_ax_base_MenuItemSprite_setDisabledImage);
        tolua_function(tolua_S,"selected",lua_ax_base_MenuItemSprite_selected);
        tolua_function(tolua_S,"unselected",lua_ax_base_MenuItemSprite_unselected);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_MenuItemSprite_setEnabled);
        tolua_function(tolua_S,"initWithNormalSprite",lua_ax_base_MenuItemSprite_initWithNormalSprite);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemSprite).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemSprite";
    g_typeCast[typeName] = "ax.MenuItemSprite";
    return 1;
}

int lua_ax_base_MenuItemImage_setNormalSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemImage",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemImage*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemImage_setNormalSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.MenuItemImage:setNormalSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_setNormalSpriteFrame'", nullptr);
            return 0;
        }
        cobj->setNormalSpriteFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:setNormalSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_setNormalSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemImage_setSelectedSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemImage",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemImage*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemImage_setSelectedSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.MenuItemImage:setSelectedSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_setSelectedSpriteFrame'", nullptr);
            return 0;
        }
        cobj->setSelectedSpriteFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:setSelectedSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_setSelectedSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemImage_setDisabledSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemImage",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemImage*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemImage_setDisabledSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.MenuItemImage:setDisabledSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_setDisabledSpriteFrame'", nullptr);
            return 0;
        }
        cobj->setDisabledSpriteFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:setDisabledSpriteFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_setDisabledSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemImage_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemImage",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemImage*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemImage_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemImage_initWithNormalImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemImage",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemImage*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemImage_initWithNormalImage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string_view arg0;
        std::string_view arg1;
        std::string_view arg2;
        std::function<void (ax::Object *)> arg3;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.MenuItemImage:initWithNormalImage");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.MenuItemImage:initWithNormalImage");

        ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.MenuItemImage:initWithNormalImage");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_initWithNormalImage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithNormalImage(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:initWithNormalImage",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_initWithNormalImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemImage_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemImage* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemImage_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemImage();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemImage");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemImage:MenuItemImage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemImage_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemImage_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemImage)");
    return 0;
}

int lua_register_ax_base_MenuItemImage(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemImage");
    tolua_cclass(tolua_S,"MenuItemImage","ax.MenuItemImage","ax.MenuItemSprite",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemImage");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemImage_constructor);
        tolua_function(tolua_S,"setNormalSpriteFrame",lua_ax_base_MenuItemImage_setNormalSpriteFrame);
        tolua_function(tolua_S,"setSelectedSpriteFrame",lua_ax_base_MenuItemImage_setSelectedSpriteFrame);
        tolua_function(tolua_S,"setDisabledSpriteFrame",lua_ax_base_MenuItemImage_setDisabledSpriteFrame);
        tolua_function(tolua_S,"init",lua_ax_base_MenuItemImage_init);
        tolua_function(tolua_S,"initWithNormalImage",lua_ax_base_MenuItemImage_initWithNormalImage);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemImage).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemImage";
    g_typeCast[typeName] = "ax.MenuItemImage";
    return 1;
}

int lua_ax_base_MenuItemToggle_addSubItem(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_addSubItem'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MenuItem* arg0;

        ok &= luaval_to_object<ax::MenuItem>(tolua_S, 2, "ax.MenuItem",&arg0, "ax.MenuItemToggle:addSubItem");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_addSubItem'", nullptr);
            return 0;
        }
        cobj->addSubItem(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:addSubItem",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_addSubItem'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_getSelectedItem(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_getSelectedItem'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_getSelectedItem'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSelectedItem();
        object_to_luaval<ax::MenuItem>(tolua_S, "ax.MenuItem",(ax::MenuItem*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:getSelectedItem",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_getSelectedItem'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_getSelectedIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_getSelectedIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_getSelectedIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSelectedIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:getSelectedIndex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_getSelectedIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_setSelectedIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_setSelectedIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.MenuItemToggle:setSelectedIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_setSelectedIndex'", nullptr);
            return 0;
        }
        cobj->setSelectedIndex(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:setSelectedIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_setSelectedIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_setSubItems(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_setSubItems'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::MenuItem *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.MenuItemToggle:setSubItems");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_setSubItems'", nullptr);
            return 0;
        }
        cobj->setSubItems(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:setSubItems",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_setSubItems'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_initWithItem(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MenuItemToggle",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MenuItemToggle*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MenuItemToggle_initWithItem'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::MenuItem* arg0;

        ok &= luaval_to_object<ax::MenuItem>(tolua_S, 2, "ax.MenuItem",&arg0, "ax.MenuItemToggle:initWithItem");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_initWithItem'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithItem(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:initWithItem",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_initWithItem'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MenuItemToggle_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MenuItemToggle* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MenuItemToggle_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MenuItemToggle();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MenuItemToggle");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MenuItemToggle:MenuItemToggle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MenuItemToggle_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MenuItemToggle_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MenuItemToggle)");
    return 0;
}

int lua_register_ax_base_MenuItemToggle(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MenuItemToggle");
    tolua_cclass(tolua_S,"MenuItemToggle","ax.MenuItemToggle","ax.MenuItem",nullptr);

    tolua_beginmodule(tolua_S,"MenuItemToggle");
        tolua_function(tolua_S,"new",lua_ax_base_MenuItemToggle_constructor);
        tolua_function(tolua_S,"addSubItem",lua_ax_base_MenuItemToggle_addSubItem);
        tolua_function(tolua_S,"getSelectedItem",lua_ax_base_MenuItemToggle_getSelectedItem);
        tolua_function(tolua_S,"getSelectedIndex",lua_ax_base_MenuItemToggle_getSelectedIndex);
        tolua_function(tolua_S,"setSelectedIndex",lua_ax_base_MenuItemToggle_setSelectedIndex);
        tolua_function(tolua_S,"setSubItems",lua_ax_base_MenuItemToggle_setSubItems);
        tolua_function(tolua_S,"initWithItem",lua_ax_base_MenuItemToggle_initWithItem);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MenuItemToggle).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MenuItemToggle";
    g_typeCast[typeName] = "ax.MenuItemToggle";
    return 1;
}

int lua_ax_base_Menu_alignItemsVertically(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_alignItemsVertically'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_alignItemsVertically'", nullptr);
            return 0;
        }
        cobj->alignItemsVertically();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:alignItemsVertically",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_alignItemsVertically'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_alignItemsVerticallyWithPadding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_alignItemsVerticallyWithPadding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Menu:alignItemsVerticallyWithPadding");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_alignItemsVerticallyWithPadding'", nullptr);
            return 0;
        }
        cobj->alignItemsVerticallyWithPadding(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:alignItemsVerticallyWithPadding",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_alignItemsVerticallyWithPadding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_alignItemsHorizontally(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_alignItemsHorizontally'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_alignItemsHorizontally'", nullptr);
            return 0;
        }
        cobj->alignItemsHorizontally();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:alignItemsHorizontally",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_alignItemsHorizontally'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_alignItemsHorizontallyWithPadding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_alignItemsHorizontallyWithPadding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Menu:alignItemsHorizontallyWithPadding");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_alignItemsHorizontallyWithPadding'", nullptr);
            return 0;
        }
        cobj->alignItemsHorizontallyWithPadding(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:alignItemsHorizontallyWithPadding",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_alignItemsHorizontallyWithPadding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_isEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Menu:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_initWithArray(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Menu",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Menu*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Menu_initWithArray'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::MenuItem *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.Menu:initWithArray");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_initWithArray'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithArray(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:initWithArray",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_initWithArray'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Menu_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Menu* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Menu_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Menu();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Menu");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Menu:Menu",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Menu_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Menu_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Menu)");
    return 0;
}

int lua_register_ax_base_Menu(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Menu");
    tolua_cclass(tolua_S,"Menu","ax.Menu","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Menu");
        tolua_function(tolua_S,"new",lua_ax_base_Menu_constructor);
        tolua_function(tolua_S,"alignItemsVertically",lua_ax_base_Menu_alignItemsVertically);
        tolua_function(tolua_S,"alignItemsVerticallyWithPadding",lua_ax_base_Menu_alignItemsVerticallyWithPadding);
        tolua_function(tolua_S,"alignItemsHorizontally",lua_ax_base_Menu_alignItemsHorizontally);
        tolua_function(tolua_S,"alignItemsHorizontallyWithPadding",lua_ax_base_Menu_alignItemsHorizontallyWithPadding);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_Menu_isEnabled);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_Menu_setEnabled);
        tolua_function(tolua_S,"initWithArray",lua_ax_base_Menu_initWithArray);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Menu).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Menu";
    g_typeCast[typeName] = "ax.Menu";
    return 1;
}

int lua_ax_base_MotionStreak_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.MotionStreak:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.MotionStreak:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_tintWithColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_tintWithColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.MotionStreak:tintWithColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_tintWithColor'", nullptr);
            return 0;
        }
        cobj->tintWithColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:tintWithColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_tintWithColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_reset(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_reset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_reset'", nullptr);
            return 0;
        }
        cobj->reset();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:reset",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_reset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_isFastMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_isFastMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_isFastMode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFastMode();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:isFastMode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_isFastMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_setFastMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_setFastMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.MotionStreak:setFastMode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_setFastMode'", nullptr);
            return 0;
        }
        cobj->setFastMode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:setFastMode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_setFastMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_getStroke(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_getStroke'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_getStroke'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStroke();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:getStroke",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_getStroke'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_setStroke(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_setStroke'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak:setStroke");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_setStroke'", nullptr);
            return 0;
        }
        cobj->setStroke(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:setStroke",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_setStroke'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_isStartingPositionInitialized(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_isStartingPositionInitialized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_isStartingPositionInitialized'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStartingPositionInitialized();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:isStartingPositionInitialized",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_isStartingPositionInitialized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_setStartingPositionInitialized(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_setStartingPositionInitialized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.MotionStreak:setStartingPositionInitialized");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_setStartingPositionInitialized'", nullptr);
            return 0;
        }
        cobj->setStartingPositionInitialized(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:setStartingPositionInitialized",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_setStartingPositionInitialized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_initWithFade(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::MotionStreak*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak_initWithFade'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            ax::Texture2D* arg4;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 6, "ax.Texture2D",&arg4, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            bool ret = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.MotionStreak:initWithFade");

            if (!ok) { break; }
            bool ret = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.MotionStreak:initWithFade",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_initWithFade'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MotionStreak",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 5)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak:create");
            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak:create");
            if (!ok) { break; }
            ax::Texture2D* arg4;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 6, "ax.Texture2D",&arg4, "ax.MotionStreak:create");
            if (!ok) { break; }
            ax::MotionStreak* ret = ax::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::MotionStreak>(tolua_S, "ax.MotionStreak",(ax::MotionStreak*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak:create");
            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak:create");
            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.MotionStreak:create");
            if (!ok) { break; }
            ax::MotionStreak* ret = ax::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::MotionStreak>(tolua_S, "ax.MotionStreak",(ax::MotionStreak*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.MotionStreak:create",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MotionStreak_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MotionStreak();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MotionStreak");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak:MotionStreak",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MotionStreak_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MotionStreak)");
    return 0;
}

int lua_register_ax_base_MotionStreak(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MotionStreak");
    tolua_cclass(tolua_S,"MotionStreak","ax.MotionStreak","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"MotionStreak");
        tolua_function(tolua_S,"new",lua_ax_base_MotionStreak_constructor);
        tolua_function(tolua_S,"getTexture",lua_ax_base_MotionStreak_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_MotionStreak_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_MotionStreak_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_MotionStreak_getBlendFunc);
        tolua_function(tolua_S,"tintWithColor",lua_ax_base_MotionStreak_tintWithColor);
        tolua_function(tolua_S,"reset",lua_ax_base_MotionStreak_reset);
        tolua_function(tolua_S,"isFastMode",lua_ax_base_MotionStreak_isFastMode);
        tolua_function(tolua_S,"setFastMode",lua_ax_base_MotionStreak_setFastMode);
        tolua_function(tolua_S,"getStroke",lua_ax_base_MotionStreak_getStroke);
        tolua_function(tolua_S,"setStroke",lua_ax_base_MotionStreak_setStroke);
        tolua_function(tolua_S,"isStartingPositionInitialized",lua_ax_base_MotionStreak_isStartingPositionInitialized);
        tolua_function(tolua_S,"setStartingPositionInitialized",lua_ax_base_MotionStreak_setStartingPositionInitialized);
        tolua_function(tolua_S,"initWithFade",lua_ax_base_MotionStreak_initWithFade);
        tolua_function(tolua_S,"create", lua_ax_base_MotionStreak_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MotionStreak).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MotionStreak";
    g_typeCast[typeName] = "ax.MotionStreak";
    return 1;
}

int lua_ax_base_NodeGrid_getGrid(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::NodeGrid*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_NodeGrid_getGrid'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            const ax::GridBase* ret = cobj->getGrid();
            object_to_luaval<ax::GridBase>(tolua_S, "ax.GridBase",(ax::GridBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::GridBase* ret = cobj->getGrid();
            object_to_luaval<ax::GridBase>(tolua_S, "ax.GridBase",(ax::GridBase*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.NodeGrid:getGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_getGrid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_NodeGrid_setGrid(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::NodeGrid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_NodeGrid_setGrid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::GridBase* arg0;

        ok &= luaval_to_object<ax::GridBase>(tolua_S, 2, "ax.GridBase",&arg0, "ax.NodeGrid:setGrid");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_NodeGrid_setGrid'", nullptr);
            return 0;
        }
        cobj->setGrid(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.NodeGrid:setGrid",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_setGrid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_NodeGrid_setTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::NodeGrid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_NodeGrid_setTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.NodeGrid:setTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_NodeGrid_setTarget'", nullptr);
            return 0;
        }
        cobj->setTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.NodeGrid:setTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_setTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_NodeGrid_setGridRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::NodeGrid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_NodeGrid_setGridRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.NodeGrid:setGridRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_NodeGrid_setGridRect'", nullptr);
            return 0;
        }
        cobj->setGridRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.NodeGrid:setGridRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_setGridRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_NodeGrid_getGridRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::NodeGrid*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_NodeGrid_getGridRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_NodeGrid_getGridRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGridRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.NodeGrid:getGridRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_getGridRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_NodeGrid_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.NodeGrid",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 1)
        {
            ax::Rect arg0;
            ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.NodeGrid:create");
            if (!ok) { break; }
            ax::NodeGrid* ret = ax::NodeGrid::create(arg0);
            object_to_luaval<ax::NodeGrid>(tolua_S, "ax.NodeGrid",(ax::NodeGrid*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::NodeGrid* ret = ax::NodeGrid::create();
            object_to_luaval<ax::NodeGrid>(tolua_S, "ax.NodeGrid",(ax::NodeGrid*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.NodeGrid:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_NodeGrid_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::NodeGrid* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_NodeGrid_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::NodeGrid();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.NodeGrid");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.NodeGrid:NodeGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_NodeGrid_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_NodeGrid_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (NodeGrid)");
    return 0;
}

int lua_register_ax_base_NodeGrid(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.NodeGrid");
    tolua_cclass(tolua_S,"NodeGrid","ax.NodeGrid","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"NodeGrid");
        tolua_function(tolua_S,"new",lua_ax_base_NodeGrid_constructor);
        tolua_function(tolua_S,"getGrid",lua_ax_base_NodeGrid_getGrid);
        tolua_function(tolua_S,"setGrid",lua_ax_base_NodeGrid_setGrid);
        tolua_function(tolua_S,"setTarget",lua_ax_base_NodeGrid_setTarget);
        tolua_function(tolua_S,"setGridRect",lua_ax_base_NodeGrid_setGridRect);
        tolua_function(tolua_S,"getGridRect",lua_ax_base_NodeGrid_getGridRect);
        tolua_function(tolua_S,"create", lua_ax_base_NodeGrid_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::NodeGrid).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.NodeGrid";
    g_typeCast[typeName] = "ax.NodeGrid";
    return 1;
}

int lua_ax_base_ParticleBatchNode_insertChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_insertChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ParticleSystem* arg0;
        int arg1;

        ok &= luaval_to_object<ax::ParticleSystem>(tolua_S, 2, "ax.ParticleSystem",&arg0, "ax.ParticleBatchNode:insertChild");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleBatchNode:insertChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_insertChild'", nullptr);
            return 0;
        }
        cobj->insertChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:insertChild",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_insertChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_removeChildAtIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_removeChildAtIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleBatchNode:removeChildAtIndex");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.ParticleBatchNode:removeChildAtIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_removeChildAtIndex'", nullptr);
            return 0;
        }
        cobj->removeChildAtIndex(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:removeChildAtIndex",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_removeChildAtIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleBatchNode:removeAllChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_removeAllChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:removeAllChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_disableParticle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_disableParticle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleBatchNode:disableParticle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_disableParticle'", nullptr);
            return 0;
        }
        cobj->disableParticle(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:disableParticle",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_disableParticle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_getTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_getTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_getTextureAtlas'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureAtlas();
        object_to_luaval<ax::TextureAtlas>(tolua_S, "ax.TextureAtlas",(ax::TextureAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:getTextureAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_getTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_setTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_setTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextureAtlas* arg0;

        ok &= luaval_to_object<ax::TextureAtlas>(tolua_S, 2, "ax.TextureAtlas",&arg0, "ax.ParticleBatchNode:setTextureAtlas");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_setTextureAtlas'", nullptr);
            return 0;
        }
        cobj->setTextureAtlas(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:setTextureAtlas",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_setTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleBatchNode:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.ParticleBatchNode:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_initWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_initWithTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Texture2D* arg0;
        int arg1;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleBatchNode:initWithTexture");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleBatchNode:initWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_initWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTexture(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:initWithTexture",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_initWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_initWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleBatchNode_initWithFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        int arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleBatchNode:initWithFile");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleBatchNode:initWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_initWithFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFile(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:initWithFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_initWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleBatchNode_createWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Texture2D* arg0;
        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleBatchNode:createWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_createWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleBatchNode::createWithTexture(arg0);
        object_to_luaval<ax::ParticleBatchNode>(tolua_S, "ax.ParticleBatchNode",(ax::ParticleBatchNode*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::Texture2D* arg0;
        int arg1;
        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleBatchNode:createWithTexture");
        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleBatchNode:createWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_createWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleBatchNode::createWithTexture(arg0, arg1);
        object_to_luaval<ax::ParticleBatchNode>(tolua_S, "ax.ParticleBatchNode",(ax::ParticleBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleBatchNode:createWithTexture",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_createWithTexture'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleBatchNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleBatchNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleBatchNode::create(arg0);
        object_to_luaval<ax::ParticleBatchNode>(tolua_S, "ax.ParticleBatchNode",(ax::ParticleBatchNode*)ret);
        return 1;
    }
    if (argc == 2)
    {
        std::string_view arg0;
        int arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleBatchNode:create");
        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleBatchNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleBatchNode::create(arg0, arg1);
        object_to_luaval<ax::ParticleBatchNode>(tolua_S, "ax.ParticleBatchNode",(ax::ParticleBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleBatchNode:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleBatchNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleBatchNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleBatchNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleBatchNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleBatchNode:ParticleBatchNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleBatchNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleBatchNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleBatchNode)");
    return 0;
}

int lua_register_ax_base_ParticleBatchNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleBatchNode");
    tolua_cclass(tolua_S,"ParticleBatchNode","ax.ParticleBatchNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ParticleBatchNode");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleBatchNode_constructor);
        tolua_function(tolua_S,"insertChild",lua_ax_base_ParticleBatchNode_insertChild);
        tolua_function(tolua_S,"removeChildAtIndex",lua_ax_base_ParticleBatchNode_removeChildAtIndex);
        tolua_function(tolua_S,"removeAllChildrenWithCleanup",lua_ax_base_ParticleBatchNode_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"disableParticle",lua_ax_base_ParticleBatchNode_disableParticle);
        tolua_function(tolua_S,"getTextureAtlas",lua_ax_base_ParticleBatchNode_getTextureAtlas);
        tolua_function(tolua_S,"setTextureAtlas",lua_ax_base_ParticleBatchNode_setTextureAtlas);
        tolua_function(tolua_S,"getTexture",lua_ax_base_ParticleBatchNode_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_ParticleBatchNode_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_ParticleBatchNode_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_ParticleBatchNode_getBlendFunc);
        tolua_function(tolua_S,"initWithTexture",lua_ax_base_ParticleBatchNode_initWithTexture);
        tolua_function(tolua_S,"initWithFile",lua_ax_base_ParticleBatchNode_initWithFile);
        tolua_function(tolua_S,"createWithTexture", lua_ax_base_ParticleBatchNode_createWithTexture);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleBatchNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleBatchNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleBatchNode";
    g_typeCast[typeName] = "ax.ParticleBatchNode";
    return 1;
}

static int lua_ax_base_SpriteSheet_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SpriteSheet)");
    return 0;
}

int lua_register_ax_base_SpriteSheet(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SpriteSheet");
    tolua_cclass(tolua_S,"SpriteSheet","ax.SpriteSheet","",nullptr);

    tolua_beginmodule(tolua_S,"SpriteSheet");
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SpriteSheet).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SpriteSheet";
    g_typeCast[typeName] = "ax.SpriteSheet";
    return 1;
}

int lua_ax_base_SpriteFrameCache_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_addSpriteFramesWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_addSpriteFramesWithFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            unsigned int arg1;
            ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            unsigned int arg2;
            ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.SpriteFrameCache:addSpriteFramesWithFile");

            if (!ok) { break; }
            cobj->addSpriteFramesWithFile(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.SpriteFrameCache:addSpriteFramesWithFile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_addSpriteFramesWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_addSpriteFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_addSpriteFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::SpriteFrame* arg0;
        std::string_view arg1;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.SpriteFrameCache:addSpriteFrame");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.SpriteFrameCache:addSpriteFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_addSpriteFrame'", nullptr);
            return 0;
        }
        cobj->addSpriteFrame(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:addSpriteFrame",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_addSpriteFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_isSpriteFramesWithFileLoaded(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_isSpriteFramesWithFileLoaded'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:isSpriteFramesWithFileLoaded");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_isSpriteFramesWithFileLoaded'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSpriteFramesWithFileLoaded(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:isSpriteFramesWithFileLoaded",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_isSpriteFramesWithFileLoaded'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeSpriteFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrames'", nullptr);
            return 0;
        }
        cobj->removeSpriteFrames();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeSpriteFrames",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeUnusedSpriteFrames(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteFrames'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteFrames'", nullptr);
            return 0;
        }
        cobj->removeUnusedSpriteFrames();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeUnusedSpriteFrames",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteFrames'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeUnusedSpriteSheets(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteSheets'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteSheets'", nullptr);
            return 0;
        }
        cobj->removeUnusedSpriteSheets();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeUnusedSpriteSheets",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeUnusedSpriteSheets'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeSpriteFrameByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrameByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:removeSpriteFrameByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrameByName'", nullptr);
            return 0;
        }
        cobj->removeSpriteFrameByName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeSpriteFrameByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeSpriteFrameByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:removeSpriteFramesFromFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFile'", nullptr);
            return 0;
        }
        cobj->removeSpriteFramesFromFile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeSpriteFramesFromFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFileContent(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFileContent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:removeSpriteFramesFromFileContent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFileContent'", nullptr);
            return 0;
        }
        cobj->removeSpriteFramesFromFileContent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeSpriteFramesFromFileContent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFileContent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_removeSpriteFramesFromTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteFrameCache:removeSpriteFramesFromTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromTexture'", nullptr);
            return 0;
        }
        cobj->removeSpriteFramesFromTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:removeSpriteFramesFromTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_removeSpriteFramesFromTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_getSpriteFrameByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:getSpriteFrameByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameByName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpriteFrameByName(arg0);
        object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:getSpriteFrameByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_reloadTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_reloadTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:reloadTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_reloadTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->reloadTexture(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:reloadTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_reloadTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_findFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_findFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:findFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_findFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->findFrame(arg0);
        object_to_luaval<ax::SpriteFrame>(tolua_S, "ax.SpriteFrame",(ax::SpriteFrame*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:findFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_findFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_getSpriteFrameName(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.SpriteFrameCache:getSpriteFrameName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpriteFrameName(arg0);
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:getSpriteFrameName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_getSpriteFrameName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_eraseFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_eraseFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteFrameCache:eraseFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_eraseFrame'", nullptr);
            return 0;
        }
        auto&& ret = cobj->eraseFrame(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:eraseFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_eraseFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_addSpriteFrameCapInset(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_addSpriteFrameCapInset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::SpriteFrame* arg0;
        ax::Rect arg1;
        ax::Texture2D* arg2;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.SpriteFrameCache:addSpriteFrameCapInset");

        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.SpriteFrameCache:addSpriteFrameCapInset");

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 4, "ax.Texture2D",&arg2, "ax.SpriteFrameCache:addSpriteFrameCapInset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_addSpriteFrameCapInset'", nullptr);
            return 0;
        }
        cobj->addSpriteFrameCapInset(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:addSpriteFrameCapInset",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_addSpriteFrameCapInset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_deregisterSpriteSheetLoader(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_deregisterSpriteSheetLoader'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.SpriteFrameCache:deregisterSpriteSheetLoader");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_deregisterSpriteSheetLoader'", nullptr);
            return 0;
        }
        cobj->deregisterSpriteSheetLoader(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:deregisterSpriteSheetLoader",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_deregisterSpriteSheetLoader'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_getSpriteSheetLoader(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteFrameCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteFrameCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteFrameCache_getSpriteSheetLoader'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.SpriteFrameCache:getSpriteSheetLoader");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_getSpriteSheetLoader'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpriteSheetLoader(arg0);
        object_to_luaval<ax::ISpriteSheetLoader>(tolua_S, "ax.ISpriteSheetLoader",(ax::ISpriteSheetLoader*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteFrameCache:getSpriteSheetLoader",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_getSpriteSheetLoader'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteFrameCache_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpriteFrameCache::getInstance();
        object_to_luaval<ax::SpriteFrameCache>(tolua_S, "ax.SpriteFrameCache",(ax::SpriteFrameCache*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SpriteFrameCache:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpriteFrameCache_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteFrameCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteFrameCache_destroyInstance'", nullptr);
            return 0;
        }
        ax::SpriteFrameCache::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SpriteFrameCache:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteFrameCache_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_SpriteFrameCache_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SpriteFrameCache)");
    return 0;
}

int lua_register_ax_base_SpriteFrameCache(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SpriteFrameCache");
    tolua_cclass(tolua_S,"SpriteFrameCache","ax.SpriteFrameCache","",nullptr);

    tolua_beginmodule(tolua_S,"SpriteFrameCache");
        tolua_function(tolua_S,"init",lua_ax_base_SpriteFrameCache_init);
        tolua_function(tolua_S,"addSpriteFrames",lua_ax_base_SpriteFrameCache_addSpriteFramesWithFile);
        tolua_function(tolua_S,"addSpriteFrame",lua_ax_base_SpriteFrameCache_addSpriteFrame);
        tolua_function(tolua_S,"isSpriteFramesWithFileLoaded",lua_ax_base_SpriteFrameCache_isSpriteFramesWithFileLoaded);
        tolua_function(tolua_S,"removeSpriteFrames",lua_ax_base_SpriteFrameCache_removeSpriteFrames);
        tolua_function(tolua_S,"removeUnusedSpriteFrames",lua_ax_base_SpriteFrameCache_removeUnusedSpriteFrames);
        tolua_function(tolua_S,"removeUnusedSpriteSheets",lua_ax_base_SpriteFrameCache_removeUnusedSpriteSheets);
        tolua_function(tolua_S,"removeSpriteFrameByName",lua_ax_base_SpriteFrameCache_removeSpriteFrameByName);
        tolua_function(tolua_S,"removeSpriteFramesFromFile",lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFile);
        tolua_function(tolua_S,"removeSpriteFramesFromFileContent",lua_ax_base_SpriteFrameCache_removeSpriteFramesFromFileContent);
        tolua_function(tolua_S,"removeSpriteFramesFromTexture",lua_ax_base_SpriteFrameCache_removeSpriteFramesFromTexture);
        tolua_function(tolua_S,"getSpriteFrame",lua_ax_base_SpriteFrameCache_getSpriteFrameByName);
        tolua_function(tolua_S,"reloadTexture",lua_ax_base_SpriteFrameCache_reloadTexture);
        tolua_function(tolua_S,"findFrame",lua_ax_base_SpriteFrameCache_findFrame);
        tolua_function(tolua_S,"getSpriteFrameName",lua_ax_base_SpriteFrameCache_getSpriteFrameName);
        tolua_function(tolua_S,"eraseFrame",lua_ax_base_SpriteFrameCache_eraseFrame);
        tolua_function(tolua_S,"addSpriteFrameCapInset",lua_ax_base_SpriteFrameCache_addSpriteFrameCapInset);
        tolua_function(tolua_S,"deregisterSpriteSheetLoader",lua_ax_base_SpriteFrameCache_deregisterSpriteSheetLoader);
        tolua_function(tolua_S,"getSpriteSheetLoader",lua_ax_base_SpriteFrameCache_getSpriteSheetLoader);
        tolua_function(tolua_S,"getInstance", lua_ax_base_SpriteFrameCache_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_SpriteFrameCache_destroyInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SpriteFrameCache).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SpriteFrameCache";
    g_typeCast[typeName] = "ax.SpriteFrameCache";
    return 1;
}

int lua_ax_base_ParticleData_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleData* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleData",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleData*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleData_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleData:init");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleData_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleData:init",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleData_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleData_release(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleData* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleData",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleData*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleData_release'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleData_release'", nullptr);
            return 0;
        }
        cobj->release();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleData:release",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleData_release'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleData_getMaxCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleData* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleData",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleData*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleData_getMaxCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleData_getMaxCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMaxCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleData:getMaxCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleData_getMaxCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleData_copyParticle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleData* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleData",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleData*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleData_copyParticle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleData:copyParticle");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleData:copyParticle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleData_copyParticle'", nullptr);
            return 0;
        }
        cobj->copyParticle(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleData:copyParticle",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleData_copyParticle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleData_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleData* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleData_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleData();
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.ParticleData");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleData:ParticleData",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleData_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleData_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleData)");
    return 0;
}

int lua_register_ax_base_ParticleData(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleData");
    tolua_cclass(tolua_S,"ParticleData","ax.ParticleData","",nullptr);

    tolua_beginmodule(tolua_S,"ParticleData");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleData_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleData_init);
        tolua_function(tolua_S,"release",lua_ax_base_ParticleData_release);
        tolua_function(tolua_S,"getMaxCount",lua_ax_base_ParticleData_getMaxCount);
        tolua_function(tolua_S,"copyParticle",lua_ax_base_ParticleData_copyParticle);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleData).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleData";
    g_typeCast[typeName] = "ax.ParticleData";
    return 1;
}

int lua_ax_base_ParticleEmissionMaskCache_bakeEmissionMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleEmissionMaskCache* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleEmissionMaskCache",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleEmissionMaskCache*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleEmissionMaskCache_bakeEmissionMask'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            ax::Image* arg1;
            ok &= luaval_to_object<ax::Image>(tolua_S, 3, "ax.Image",&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            ax::Image* arg1;
            ok &= luaval_to_object<ax::Image>(tolua_S, 3, "ax.Image",&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            ax::Image* arg1;
            ok &= luaval_to_object<ax::Image>(tolua_S, 3, "ax.Image",&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            ax::Image* arg1;
            ok &= luaval_to_object<ax::Image>(tolua_S, 3, "ax.Image",&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            int arg4;
            ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.ParticleEmissionMaskCache:bakeEmissionMask");

            if (!ok) { break; }
            cobj->bakeEmissionMask(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleEmissionMaskCache:bakeEmissionMask",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleEmissionMaskCache_bakeEmissionMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleEmissionMaskCache_getEmissionMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleEmissionMaskCache* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleEmissionMaskCache",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleEmissionMaskCache*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleEmissionMaskCache_getEmissionMask'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:getEmissionMask");

            if (!ok) { break; }
            const ax::ParticleEmissionMaskDescriptor& ret = cobj->getEmissionMask(arg0);
            #pragma warning NO CONVERSION FROM NATIVE FOR ParticleEmissionMaskDescriptor;
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:getEmissionMask");

            if (!ok) { break; }
            const ax::ParticleEmissionMaskDescriptor& ret = cobj->getEmissionMask(arg0);
            #pragma warning NO CONVERSION FROM NATIVE FOR ParticleEmissionMaskDescriptor;
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleEmissionMaskCache:getEmissionMask",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleEmissionMaskCache_getEmissionMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleEmissionMaskCache_removeMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleEmissionMaskCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleEmissionMaskCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleEmissionMaskCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleEmissionMaskCache_removeMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleEmissionMaskCache:removeMask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleEmissionMaskCache_removeMask'", nullptr);
            return 0;
        }
        cobj->removeMask(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleEmissionMaskCache:removeMask",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleEmissionMaskCache_removeMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleEmissionMaskCache_removeAllMasks(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleEmissionMaskCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleEmissionMaskCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleEmissionMaskCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleEmissionMaskCache_removeAllMasks'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleEmissionMaskCache_removeAllMasks'", nullptr);
            return 0;
        }
        cobj->removeAllMasks();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleEmissionMaskCache:removeAllMasks",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleEmissionMaskCache_removeAllMasks'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleEmissionMaskCache_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleEmissionMaskCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleEmissionMaskCache_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleEmissionMaskCache::getInstance();
        object_to_luaval<ax::ParticleEmissionMaskCache>(tolua_S, "ax.ParticleEmissionMaskCache",(ax::ParticleEmissionMaskCache*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleEmissionMaskCache:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleEmissionMaskCache_getInstance'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_ParticleEmissionMaskCache_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleEmissionMaskCache)");
    return 0;
}

int lua_register_ax_base_ParticleEmissionMaskCache(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleEmissionMaskCache");
    tolua_cclass(tolua_S,"ParticleEmissionMaskCache","ax.ParticleEmissionMaskCache","",nullptr);

    tolua_beginmodule(tolua_S,"ParticleEmissionMaskCache");
        tolua_function(tolua_S,"bakeEmissionMask",lua_ax_base_ParticleEmissionMaskCache_bakeEmissionMask);
        tolua_function(tolua_S,"getEmissionMask",lua_ax_base_ParticleEmissionMaskCache_getEmissionMask);
        tolua_function(tolua_S,"removeMask",lua_ax_base_ParticleEmissionMaskCache_removeMask);
        tolua_function(tolua_S,"removeAllMasks",lua_ax_base_ParticleEmissionMaskCache_removeAllMasks);
        tolua_function(tolua_S,"getInstance", lua_ax_base_ParticleEmissionMaskCache_getInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleEmissionMaskCache).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleEmissionMaskCache";
    g_typeCast[typeName] = "ax.ParticleEmissionMaskCache";
    return 1;
}

int lua_ax_base_ParticleSystem_addParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_addParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:addParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_addParticles'", nullptr);
            return 0;
        }
        cobj->addParticles(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        int arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:addParticles");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleSystem:addParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_addParticles'", nullptr);
            return 0;
        }
        cobj->addParticles(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 3) 
    {
        int arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:addParticles");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleSystem:addParticles");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ParticleSystem:addParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_addParticles'", nullptr);
            return 0;
        }
        cobj->addParticles(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:addParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_addParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_stopSystem(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_stopSystem'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_stopSystem'", nullptr);
            return 0;
        }
        cobj->stopSystem();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:stopSystem",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_stopSystem'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resetSystem(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resetSystem'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resetSystem'", nullptr);
            return 0;
        }
        cobj->resetSystem();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resetSystem",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resetSystem'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isFull(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isFull'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isFull'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isFull();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isFull",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isFull'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_updateParticleQuads(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_updateParticleQuads'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_updateParticleQuads'", nullptr);
            return 0;
        }
        cobj->updateParticleQuads();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:updateParticleQuads",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_updateParticleQuads'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_postStep(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_postStep'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_postStep'", nullptr);
            return 0;
        }
        cobj->postStep();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:postStep",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_postStep'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_updateWithNoTime(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_updateWithNoTime'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_updateWithNoTime'", nullptr);
            return 0;
        }
        cobj->updateWithNoTime();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:updateWithNoTime",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_updateWithNoTime'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isAutoRemoveOnFinish(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isAutoRemoveOnFinish'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isAutoRemoveOnFinish'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAutoRemoveOnFinish();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isAutoRemoveOnFinish",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isAutoRemoveOnFinish'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAutoRemoveOnFinish(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAutoRemoveOnFinish'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setAutoRemoveOnFinish");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAutoRemoveOnFinish'", nullptr);
            return 0;
        }
        cobj->setAutoRemoveOnFinish(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAutoRemoveOnFinish",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAutoRemoveOnFinish'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getGravity(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getGravity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getGravity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGravity();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getGravity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getGravity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setGravity(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setGravity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:setGravity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setGravity'", nullptr);
            return 0;
        }
        cobj->setGravity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setGravity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setGravity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpeed(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpeed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpeed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpeed();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpeed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpeed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpeed(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpeed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpeed");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpeed'", nullptr);
            return 0;
        }
        cobj->setSpeed(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpeed",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpeed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpeedVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpeedVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpeedVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpeedVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpeedVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpeedVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpeedVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpeedVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpeedVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpeedVar'", nullptr);
            return 0;
        }
        cobj->setSpeedVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpeedVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpeedVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTangentialAccel(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTangentialAccel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTangentialAccel'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTangentialAccel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTangentialAccel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTangentialAccel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setTangentialAccel(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setTangentialAccel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setTangentialAccel");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTangentialAccel'", nullptr);
            return 0;
        }
        cobj->setTangentialAccel(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setTangentialAccel",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setTangentialAccel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTangentialAccelVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTangentialAccelVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTangentialAccelVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTangentialAccelVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTangentialAccelVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTangentialAccelVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setTangentialAccelVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setTangentialAccelVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setTangentialAccelVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTangentialAccelVar'", nullptr);
            return 0;
        }
        cobj->setTangentialAccelVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setTangentialAccelVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setTangentialAccelVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getRadialAccel(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getRadialAccel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getRadialAccel'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRadialAccel();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getRadialAccel",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getRadialAccel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRadialAccel(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRadialAccel'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setRadialAccel");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRadialAccel'", nullptr);
            return 0;
        }
        cobj->setRadialAccel(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRadialAccel",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRadialAccel'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getRadialAccelVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getRadialAccelVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getRadialAccelVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRadialAccelVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getRadialAccelVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getRadialAccelVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRadialAccelVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRadialAccelVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setRadialAccelVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRadialAccelVar'", nullptr);
            return 0;
        }
        cobj->setRadialAccelVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRadialAccelVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRadialAccelVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getRotationIsDir(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getRotationIsDir'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getRotationIsDir'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotationIsDir();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getRotationIsDir",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getRotationIsDir'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRotationIsDir(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRotationIsDir'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setRotationIsDir");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRotationIsDir'", nullptr);
            return 0;
        }
        cobj->setRotationIsDir(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRotationIsDir",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRotationIsDir'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartRadius'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartRadius();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartRadius",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartRadius");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartRadius'", nullptr);
            return 0;
        }
        cobj->setStartRadius(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartRadius",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartRadiusVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartRadiusVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartRadiusVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartRadiusVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartRadiusVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartRadiusVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartRadiusVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartRadiusVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartRadiusVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartRadiusVar'", nullptr);
            return 0;
        }
        cobj->setStartRadiusVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartRadiusVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartRadiusVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndRadius'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndRadius();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndRadius",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndRadius(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndRadius'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndRadius");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndRadius'", nullptr);
            return 0;
        }
        cobj->setEndRadius(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndRadius",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndRadius'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndRadiusVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndRadiusVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndRadiusVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndRadiusVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndRadiusVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndRadiusVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndRadiusVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndRadiusVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndRadiusVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndRadiusVar'", nullptr);
            return 0;
        }
        cobj->setEndRadiusVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndRadiusVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndRadiusVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getRotatePerSecond(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getRotatePerSecond'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getRotatePerSecond'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotatePerSecond();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getRotatePerSecond",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getRotatePerSecond'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRotatePerSecond(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRotatePerSecond'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setRotatePerSecond");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRotatePerSecond'", nullptr);
            return 0;
        }
        cobj->setRotatePerSecond(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRotatePerSecond",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRotatePerSecond'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getRotatePerSecondVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getRotatePerSecondVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getRotatePerSecondVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRotatePerSecondVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getRotatePerSecondVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getRotatePerSecondVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRotatePerSecondVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRotatePerSecondVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setRotatePerSecondVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRotatePerSecondVar'", nullptr);
            return 0;
        }
        cobj->setRotatePerSecondVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRotatePerSecondVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRotatePerSecondVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isActive(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isActive'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isActive'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isActive",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isActive'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isBlendAdditive(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isBlendAdditive'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isBlendAdditive'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isBlendAdditive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isBlendAdditive",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isBlendAdditive'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setBlendAdditive(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setBlendAdditive'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setBlendAdditive");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setBlendAdditive'", nullptr);
            return 0;
        }
        cobj->setBlendAdditive(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setBlendAdditive",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setBlendAdditive'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getBatchNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getBatchNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getBatchNode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBatchNode();
        object_to_luaval<ax::ParticleBatchNode>(tolua_S, "ax.ParticleBatchNode",(ax::ParticleBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getBatchNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getBatchNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setBatchNode(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setBatchNode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ParticleBatchNode* arg0;

        ok &= luaval_to_object<ax::ParticleBatchNode>(tolua_S, 2, "ax.ParticleBatchNode",&arg0, "ax.ParticleSystem:setBatchNode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setBatchNode'", nullptr);
            return 0;
        }
        cobj->setBatchNode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setBatchNode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setBatchNode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getAtlasIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getAtlasIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getAtlasIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAtlasIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getAtlasIndex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getAtlasIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAtlasIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAtlasIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:setAtlasIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAtlasIndex'", nullptr);
            return 0;
        }
        cobj->setAtlasIndex(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAtlasIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAtlasIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getParticleCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getParticleCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getParticleCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getParticleCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getParticleCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getParticleCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDuration();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getDuration",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setDuration'", nullptr);
            return 0;
        }
        cobj->setDuration(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setDuration",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSourcePosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSourcePosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSourcePosition'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSourcePosition();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSourcePosition",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSourcePosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSourcePosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSourcePosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:setSourcePosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSourcePosition'", nullptr);
            return 0;
        }
        cobj->setSourcePosition(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSourcePosition",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSourcePosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getPosVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getPosVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getPosVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPosVar();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getPosVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getPosVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setPosVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setPosVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:setPosVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setPosVar'", nullptr);
            return 0;
        }
        cobj->setPosVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setPosVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setPosVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getLife(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getLife'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getLife'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLife();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getLife",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getLife'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setLife(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setLife'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setLife");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setLife'", nullptr);
            return 0;
        }
        cobj->setLife(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setLife",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setLife'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getLifeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getLifeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getLifeVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLifeVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getLifeVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getLifeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setLifeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setLifeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setLifeVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setLifeVar'", nullptr);
            return 0;
        }
        cobj->setLifeVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setLifeVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setLifeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAngle'", nullptr);
            return 0;
        }
        cobj->setAngle(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAngle",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getAngleVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getAngleVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getAngleVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAngleVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getAngleVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getAngleVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAngleVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAngleVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setAngleVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAngleVar'", nullptr);
            return 0;
        }
        cobj->setAngleVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAngleVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAngleVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEmitterMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEmitterMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEmitterMode'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getEmitterMode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEmitterMode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEmitterMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEmitterMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEmitterMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ParticleSystem::Mode arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:setEmitterMode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEmitterMode'", nullptr);
            return 0;
        }
        cobj->setEmitterMode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEmitterMode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEmitterMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartSize'", nullptr);
            return 0;
        }
        cobj->setStartSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartSizeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartSizeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartSizeVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartSizeVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartSizeVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartSizeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartSizeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartSizeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartSizeVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartSizeVar'", nullptr);
            return 0;
        }
        cobj->setStartSizeVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartSizeVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartSizeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndSize();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndSize'", nullptr);
            return 0;
        }
        cobj->setEndSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndSizeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndSizeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndSizeVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndSizeVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndSizeVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndSizeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndSizeVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndSizeVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndSizeVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndSizeVar'", nullptr);
            return 0;
        }
        cobj->setEndSizeVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndSizeVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndSizeVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.ParticleSystem:setStartColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartColor'", nullptr);
            return 0;
        }
        cobj->setStartColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartColorVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartColorVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartColorVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartColorVar();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartColorVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartColorVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartColorVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartColorVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.ParticleSystem:setStartColorVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartColorVar'", nullptr);
            return 0;
        }
        cobj->setStartColorVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartColorVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartColorVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.ParticleSystem:setEndColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndColor'", nullptr);
            return 0;
        }
        cobj->setEndColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndColorVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndColorVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndColorVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndColorVar();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndColorVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndColorVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndColorVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndColorVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.ParticleSystem:setEndColorVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndColorVar'", nullptr);
            return 0;
        }
        cobj->setEndColorVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndColorVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndColorVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_useHSV(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_useHSV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:useHSV");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_useHSV'", nullptr);
            return 0;
        }
        cobj->useHSV(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:useHSV",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_useHSV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isHSV(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isHSV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isHSV'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isHSV();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isHSV",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isHSV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getHue(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getHue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getHue'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getHue",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getHue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setHue(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setHue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setHue");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setHue'", nullptr);
            return 0;
        }
        cobj->setHue(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setHue",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setHue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getHueVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getHueVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getHueVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHueVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getHueVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getHueVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setHueVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setHueVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setHueVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setHueVar'", nullptr);
            return 0;
        }
        cobj->setHueVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setHueVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setHueVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getHSV(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getHSV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getHSV'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHSV();
        #pragma warning NO CONVERSION FROM NATIVE FOR HSV;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getHSV",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getHSV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setHSV(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setHSV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::HSV arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR HSV
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setHSV'", nullptr);
            return 0;
        }
        cobj->setHSV(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setHSV",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setHSV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getHSVVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getHSVVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getHSVVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHSVVar();
        #pragma warning NO CONVERSION FROM NATIVE FOR HSV;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getHSVVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getHSVVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setHSVVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setHSVVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::HSV arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR HSV
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setHSVVar'", nullptr);
            return 0;
        }
        cobj->setHSVVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setHSVVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setHSVVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartSpin(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartSpin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartSpin'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartSpin();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartSpin",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartSpin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartSpin(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartSpin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartSpin");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartSpin'", nullptr);
            return 0;
        }
        cobj->setStartSpin(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartSpin",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartSpin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getStartSpinVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getStartSpinVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getStartSpinVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStartSpinVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getStartSpinVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getStartSpinVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setStartSpinVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setStartSpinVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setStartSpinVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setStartSpinVar'", nullptr);
            return 0;
        }
        cobj->setStartSpinVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setStartSpinVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setStartSpinVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndSpin(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndSpin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndSpin'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndSpin();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndSpin",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndSpin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndSpin(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndSpin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndSpin");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndSpin'", nullptr);
            return 0;
        }
        cobj->setEndSpin(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndSpin",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndSpin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEndSpinVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEndSpinVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEndSpinVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEndSpinVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEndSpinVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEndSpinVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEndSpinVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEndSpinVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEndSpinVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEndSpinVar'", nullptr);
            return 0;
        }
        cobj->setEndSpinVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEndSpinVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEndSpinVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnAngle'", nullptr);
            return 0;
        }
        cobj->setSpawnAngle(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnAngle",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnAngleVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnAngleVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnAngleVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnAngleVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnAngleVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnAngleVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnAngleVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnAngleVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnAngleVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnAngleVar'", nullptr);
            return 0;
        }
        cobj->setSpawnAngleVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnAngleVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnAngleVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnFadeIn(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnFadeIn'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnFadeIn'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnFadeIn();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnFadeIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnFadeIn'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnFadeIn(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnFadeIn'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnFadeIn");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnFadeIn'", nullptr);
            return 0;
        }
        cobj->setSpawnFadeIn(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnFadeIn",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnFadeIn'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnFadeInVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnFadeInVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnFadeInVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnFadeInVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnFadeInVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnFadeInVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnFadeInVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnFadeInVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnFadeInVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnFadeInVar'", nullptr);
            return 0;
        }
        cobj->setSpawnFadeInVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnFadeInVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnFadeInVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnScaleIn(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnScaleIn'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnScaleIn'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnScaleIn();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnScaleIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnScaleIn'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnScaleIn(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnScaleIn'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnScaleIn");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnScaleIn'", nullptr);
            return 0;
        }
        cobj->setSpawnScaleIn(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnScaleIn",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnScaleIn'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getSpawnScaleInVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getSpawnScaleInVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getSpawnScaleInVar'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSpawnScaleInVar();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getSpawnScaleInVar",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getSpawnScaleInVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSpawnScaleInVar(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSpawnScaleInVar'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setSpawnScaleInVar");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSpawnScaleInVar'", nullptr);
            return 0;
        }
        cobj->setSpawnScaleInVar(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSpawnScaleInVar",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSpawnScaleInVar'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getEmissionRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getEmissionRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getEmissionRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getEmissionRate();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getEmissionRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getEmissionRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEmissionRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEmissionRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setEmissionRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEmissionRate'", nullptr);
            return 0;
        }
        cobj->setEmissionRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEmissionRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEmissionRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTotalParticles();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTotalParticles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:setTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTotalParticles'", nullptr);
            return 0;
        }
        cobj->setTotalParticles(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setLifeAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setLifeAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setLifeAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setLifeAnimation'", nullptr);
            return 0;
        }
        cobj->setLifeAnimation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setLifeAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setLifeAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEmitterAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEmitterAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setEmitterAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEmitterAnimation'", nullptr);
            return 0;
        }
        cobj->setEmitterAnimation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEmitterAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEmitterAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setLoopAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setLoopAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setLoopAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setLoopAnimation'", nullptr);
            return 0;
        }
        cobj->setLoopAnimation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setLoopAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setLoopAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isLifeAnimated(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isLifeAnimated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isLifeAnimated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isLifeAnimated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isLifeAnimated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isLifeAnimated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isEmitterAnimated(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isEmitterAnimated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isEmitterAnimated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEmitterAnimated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isEmitterAnimated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isEmitterAnimated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isLoopAnimated(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isLoopAnimated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isLoopAnimated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isLoopAnimated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isLoopAnimated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isLoopAnimated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTotalAnimationIndices(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTotalAnimationIndices'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTotalAnimationIndices'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTotalAnimationIndices();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTotalAnimationIndices",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTotalAnimationIndices'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAnimationReverse(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAnimationReverse'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setAnimationReverse");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAnimationReverse'", nullptr);
            return 0;
        }
        cobj->setAnimationReverse(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAnimationReverse",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAnimationReverse'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isAnimationReversed(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isAnimationReversed'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isAnimationReversed'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAnimationReversed();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isAnimationReversed",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isAnimationReversed'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resetAnimationIndices(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resetAnimationIndices'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resetAnimationIndices'", nullptr);
            return 0;
        }
        cobj->resetAnimationIndices();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resetAnimationIndices",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resetAnimationIndices'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resetAnimationDescriptors(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resetAnimationDescriptors'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resetAnimationDescriptors'", nullptr);
            return 0;
        }
        cobj->resetAnimationDescriptors();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resetAnimationDescriptors",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resetAnimationDescriptors'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setMultiAnimationRandomSpecific(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandomSpecific'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::vector<unsigned short> arg0;

        ok &= luaval_to_std_vector_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setMultiAnimationRandomSpecific");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandomSpecific'", nullptr);
            return 0;
        }
        cobj->setMultiAnimationRandomSpecific(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setMultiAnimationRandomSpecific",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandomSpecific'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setMultiAnimationRandom(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandom'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandom'", nullptr);
            return 0;
        }
        cobj->setMultiAnimationRandom();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setMultiAnimationRandom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setMultiAnimationRandom'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAnimationIndicesAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAnimationIndicesAtlas'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.ParticleSystem:setAnimationIndicesAtlas");

            if (!ok) { break; }
            cobj->setAnimationIndicesAtlas(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            unsigned int arg0;
            ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.ParticleSystem:setAnimationIndicesAtlas");

            if (!ok) { break; }
            ax::ParticleSystem::TexAnimDir arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParticleSystem:setAnimationIndicesAtlas");

            if (!ok) { break; }
            cobj->setAnimationIndicesAtlas(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            cobj->setAnimationIndicesAtlas();
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleSystem:setAnimationIndicesAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAnimationIndicesAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_addAnimationIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_addAnimationIndex'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::SpriteFrame* arg0;
            ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            ax::SpriteFrame* arg1;
            ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 3, "ax.SpriteFrame",&arg1, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.ParticleSystem:addAnimationIndex");

            if (!ok) { break; }
            bool ret = cobj->addAnimationIndex(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleSystem:addAnimationIndex",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_addAnimationIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setRectForUndefinedIndices(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setRectForUndefinedIndices'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.ParticleSystem:setRectForUndefinedIndices");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setRectForUndefinedIndices'", nullptr);
            return 0;
        }
        cobj->setRectForUndefinedIndices(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setRectForUndefinedIndices",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setRectForUndefinedIndices'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAnimationDescriptor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAnimationDescriptor'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 1) {
            std::vector<unsigned short> arg0;
            ok &= luaval_to_std_vector_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            cobj->setAnimationDescriptor(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::vector<unsigned short> arg0;
            ok &= luaval_to_std_vector_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            cobj->setAnimationDescriptor(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            std::vector<unsigned short> arg3;
            ok &= luaval_to_std_vector_ushort(tolua_S, 5, &arg3, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            cobj->setAnimationDescriptor(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            unsigned short arg0;
            ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            std::vector<unsigned short> arg3;
            ok &= luaval_to_std_vector_ushort(tolua_S, 5, &arg3, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.ParticleSystem:setAnimationDescriptor");

            if (!ok) { break; }
            cobj->setAnimationDescriptor(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleSystem:setAnimationDescriptor",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAnimationDescriptor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setAnimationSpeedTimescaleIndependent(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setAnimationSpeedTimescaleIndependent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setAnimationSpeedTimescaleIndependent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setAnimationSpeedTimescaleIndependent'", nullptr);
            return 0;
        }
        cobj->setAnimationSpeedTimescaleIndependent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setAnimationSpeedTimescaleIndependent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setAnimationSpeedTimescaleIndependent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isAnimationSpeedTimescaleIndependent(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isAnimationSpeedTimescaleIndependent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isAnimationSpeedTimescaleIndependent'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAnimationSpeedTimescaleIndependent();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isAnimationSpeedTimescaleIndependent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isAnimationSpeedTimescaleIndependent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEmissionShapes(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEmissionShapes'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setEmissionShapes");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEmissionShapes'", nullptr);
            return 0;
        }
        cobj->setEmissionShapes(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEmissionShapes",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEmissionShapes'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isEmissionShapes(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isEmissionShapes'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isEmissionShapes'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEmissionShapes();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isEmissionShapes",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isEmissionShapes'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resetEmissionShapes(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resetEmissionShapes'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resetEmissionShapes'", nullptr);
            return 0;
        }
        cobj->resetEmissionShapes();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resetEmissionShapes",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resetEmissionShapes'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_addEmissionShape(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_addEmissionShape'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EmissionShape arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR EmissionShape
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_addEmissionShape'", nullptr);
            return 0;
        }
        cobj->addEmissionShape(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:addEmissionShape",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_addEmissionShape'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setEmissionShape(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setEmissionShape'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned short arg0;
        ax::EmissionShape arg1;

        ok &= luaval_to_ushort(tolua_S, 2, &arg0, "ax.ParticleSystem:setEmissionShape");

        #pragma warning NO CONVERSION TO NATIVE FOR EmissionShape
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setEmissionShape'", nullptr);
            return 0;
        }
        cobj->setEmissionShape(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setEmissionShape",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setEmissionShape'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getPositionType(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getPositionType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getPositionType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getPositionType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getPositionType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getPositionType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setPositionType(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setPositionType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ParticleSystem::PositionType arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:setPositionType");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setPositionType'", nullptr);
            return 0;
        }
        cobj->setPositionType(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setPositionType",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setPositionType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_simulate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_simulate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_simulate'", nullptr);
            return 0;
        }
        cobj->simulate();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:simulate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_simulate'", nullptr);
            return 0;
        }
        cobj->simulate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:simulate");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:simulate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_simulate'", nullptr);
            return 0;
        }
        cobj->simulate(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:simulate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_simulate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resimulate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resimulate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resimulate'", nullptr);
            return 0;
        }
        cobj->resimulate();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:resimulate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resimulate'", nullptr);
            return 0;
        }
        cobj->resimulate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        double arg0;
        double arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:resimulate");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:resimulate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resimulate'", nullptr);
            return 0;
        }
        cobj->resimulate(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resimulate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resimulate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleSystem:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.ParticleSystem:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getResourceFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getResourceFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getResourceFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getResourceFile();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getResourceFile",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getResourceFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_start(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_start'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_start'", nullptr);
            return 0;
        }
        cobj->start();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:start",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_start'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_stop(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_stop'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_stop'", nullptr);
            return 0;
        }
        cobj->stop();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:stop",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_stop'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setSourcePositionCompatible(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setSourcePositionCompatible'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParticleSystem:setSourcePositionCompatible");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setSourcePositionCompatible'", nullptr);
            return 0;
        }
        cobj->setSourcePositionCompatible(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setSourcePositionCompatible",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setSourcePositionCompatible'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isSourcePositionCompatible(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isSourcePositionCompatible'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isSourcePositionCompatible'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSourcePositionCompatible();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isSourcePositionCompatible",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isSourcePositionCompatible'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_initWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_initWithFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:initWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_initWithFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:initWithFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_initWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_initWithDictionary(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_initWithDictionary'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::ValueMap arg0;
            ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.ParticleSystem:initWithDictionary");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.ParticleSystem:initWithDictionary");

            if (!ok) { break; }
            bool ret = cobj->initWithDictionary(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::ValueMap arg0;
            ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.ParticleSystem:initWithDictionary");

            if (!ok) { break; }
            bool ret = cobj->initWithDictionary(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ParticleSystem:initWithDictionary",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_initWithDictionary'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_isPaused(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_isPaused'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_isPaused'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isPaused();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:isPaused",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_isPaused'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_pauseEmissions(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_pauseEmissions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_pauseEmissions'", nullptr);
            return 0;
        }
        cobj->pauseEmissions();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:pauseEmissions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_pauseEmissions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_resumeEmissions(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_resumeEmissions'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_resumeEmissions'", nullptr);
            return 0;
        }
        cobj->resumeEmissions();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:resumeEmissions",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_resumeEmissions'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getFixedFPS(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getFixedFPS'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getFixedFPS'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFixedFPS();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getFixedFPS",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getFixedFPS'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setFixedFPS(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setFixedFPS'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setFixedFPS'", nullptr);
            return 0;
        }
        cobj->setFixedFPS();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setFixedFPS");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setFixedFPS'", nullptr);
            return 0;
        }
        cobj->setFixedFPS(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setFixedFPS",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setFixedFPS'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_getTimeScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_getTimeScale'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getTimeScale'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTimeScale();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:getTimeScale",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getTimeScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_setTimeScale(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystem*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystem_setTimeScale'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTimeScale'", nullptr);
            return 0;
        }
        cobj->setTimeScale();
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ParticleSystem:setTimeScale");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_setTimeScale'", nullptr);
            return 0;
        }
        cobj->setTimeScale(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:setTimeScale",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_setTimeScale'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystem_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::create(arg0);
        object_to_luaval<ax::ParticleSystem>(tolua_S, "ax.ParticleSystem",(ax::ParticleSystem*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystem:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSystem>(tolua_S, "ax.ParticleSystem",(ax::ParticleSystem*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_getAllParticleSystems(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_getAllParticleSystems'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::getAllParticleSystems();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:getAllParticleSystems",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_getAllParticleSystems'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createMaskShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:createMaskShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createMaskShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createMaskShape(arg0);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 2)
    {
        std::string_view arg0;
        ax::Vec2 arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ParticleSystem:createMaskShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createMaskShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createMaskShape(arg0, arg1);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 3)
    {
        std::string_view arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.ParticleSystem:createMaskShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createMaskShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createMaskShape(arg0, arg1, arg2);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 4)
    {
        std::string_view arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        ax::Vec2 arg3;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.ParticleSystem:createMaskShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createMaskShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createMaskShape(arg0, arg1, arg2, arg3);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 5)
    {
        std::string_view arg0;
        ax::Vec2 arg1;
        ax::Vec2 arg2;
        ax::Vec2 arg3;
        double arg4;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.ParticleSystem:createMaskShape");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.ParticleSystem:createMaskShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createMaskShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createMaskShape(arg0, arg1, arg2, arg3, arg4);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createMaskShape",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createMaskShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createPointShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Vec2 arg0;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createPointShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createPointShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createPointShape(arg0);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createPointShape",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createPointShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createRectShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Vec2 arg0;
        ax::Size arg1;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createRectShape");
        ok &= luaval_to_size(tolua_S, 3, &arg1, "ax.ParticleSystem:createRectShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createRectShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createRectShape(arg0, arg1);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createRectShape",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createRectShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createRectTorusShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::Vec2 arg0;
        ax::Size arg1;
        ax::Size arg2;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createRectTorusShape");
        ok &= luaval_to_size(tolua_S, 3, &arg1, "ax.ParticleSystem:createRectTorusShape");
        ok &= luaval_to_size(tolua_S, 4, &arg2, "ax.ParticleSystem:createRectTorusShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createRectTorusShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createRectTorusShape(arg0, arg1, arg2);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createRectTorusShape",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createRectTorusShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createCircleShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Vec2 arg0;
        double arg1;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createCircleShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createCircleShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createCircleShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createCircleShape(arg0, arg1);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 3)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createCircleShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createCircleShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createCircleShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createCircleShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createCircleShape(arg0, arg1, arg2);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createCircleShape",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createCircleShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createConeShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        double arg3;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ParticleSystem:createConeShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createConeShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createConeShape(arg0, arg1, arg2, arg3);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 5)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        double arg3;
        double arg4;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ParticleSystem:createConeShape");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.ParticleSystem:createConeShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createConeShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createConeShape(arg0, arg1, arg2, arg3, arg4);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createConeShape",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createConeShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createTorusShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createTorusShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createTorusShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createTorusShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createTorusShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createTorusShape(arg0, arg1, arg2);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 4)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        double arg3;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createTorusShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createTorusShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createTorusShape");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ParticleSystem:createTorusShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createTorusShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createTorusShape(arg0, arg1, arg2, arg3);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createTorusShape",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createTorusShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_createConeTorusShape(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystem",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 5)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        double arg3;
        double arg4;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.ParticleSystem:createConeTorusShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createConeTorusShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createConeTorusShape(arg0, arg1, arg2, arg3, arg4);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    if (argc == 6)
    {
        ax::Vec2 arg0;
        double arg1;
        double arg2;
        double arg3;
        double arg4;
        double arg5;
        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.ParticleSystem:createConeTorusShape");
        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.ParticleSystem:createConeTorusShape");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_createConeTorusShape'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystem::createConeTorusShape(arg0, arg1, arg2, arg3, arg4, arg5);
        #pragma warning NO CONVERSION FROM NATIVE FOR EmissionShape;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystem:createConeTorusShape",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_createConeTorusShape'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystem_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystem* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystem_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSystem();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSystem");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystem:ParticleSystem",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystem_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSystem_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSystem)");
    return 0;
}

int lua_register_ax_base_ParticleSystem(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSystem");
    tolua_cclass(tolua_S,"ParticleSystem","ax.ParticleSystem","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSystem");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSystem_constructor);
        tolua_function(tolua_S,"addParticles",lua_ax_base_ParticleSystem_addParticles);
        tolua_function(tolua_S,"stopSystem",lua_ax_base_ParticleSystem_stopSystem);
        tolua_function(tolua_S,"resetSystem",lua_ax_base_ParticleSystem_resetSystem);
        tolua_function(tolua_S,"isFull",lua_ax_base_ParticleSystem_isFull);
        tolua_function(tolua_S,"updateParticleQuads",lua_ax_base_ParticleSystem_updateParticleQuads);
        tolua_function(tolua_S,"postStep",lua_ax_base_ParticleSystem_postStep);
        tolua_function(tolua_S,"updateWithNoTime",lua_ax_base_ParticleSystem_updateWithNoTime);
        tolua_function(tolua_S,"isAutoRemoveOnFinish",lua_ax_base_ParticleSystem_isAutoRemoveOnFinish);
        tolua_function(tolua_S,"setAutoRemoveOnFinish",lua_ax_base_ParticleSystem_setAutoRemoveOnFinish);
        tolua_function(tolua_S,"getGravity",lua_ax_base_ParticleSystem_getGravity);
        tolua_function(tolua_S,"setGravity",lua_ax_base_ParticleSystem_setGravity);
        tolua_function(tolua_S,"getSpeed",lua_ax_base_ParticleSystem_getSpeed);
        tolua_function(tolua_S,"setSpeed",lua_ax_base_ParticleSystem_setSpeed);
        tolua_function(tolua_S,"getSpeedVar",lua_ax_base_ParticleSystem_getSpeedVar);
        tolua_function(tolua_S,"setSpeedVar",lua_ax_base_ParticleSystem_setSpeedVar);
        tolua_function(tolua_S,"getTangentialAccel",lua_ax_base_ParticleSystem_getTangentialAccel);
        tolua_function(tolua_S,"setTangentialAccel",lua_ax_base_ParticleSystem_setTangentialAccel);
        tolua_function(tolua_S,"getTangentialAccelVar",lua_ax_base_ParticleSystem_getTangentialAccelVar);
        tolua_function(tolua_S,"setTangentialAccelVar",lua_ax_base_ParticleSystem_setTangentialAccelVar);
        tolua_function(tolua_S,"getRadialAccel",lua_ax_base_ParticleSystem_getRadialAccel);
        tolua_function(tolua_S,"setRadialAccel",lua_ax_base_ParticleSystem_setRadialAccel);
        tolua_function(tolua_S,"getRadialAccelVar",lua_ax_base_ParticleSystem_getRadialAccelVar);
        tolua_function(tolua_S,"setRadialAccelVar",lua_ax_base_ParticleSystem_setRadialAccelVar);
        tolua_function(tolua_S,"getRotationIsDir",lua_ax_base_ParticleSystem_getRotationIsDir);
        tolua_function(tolua_S,"setRotationIsDir",lua_ax_base_ParticleSystem_setRotationIsDir);
        tolua_function(tolua_S,"getStartRadius",lua_ax_base_ParticleSystem_getStartRadius);
        tolua_function(tolua_S,"setStartRadius",lua_ax_base_ParticleSystem_setStartRadius);
        tolua_function(tolua_S,"getStartRadiusVar",lua_ax_base_ParticleSystem_getStartRadiusVar);
        tolua_function(tolua_S,"setStartRadiusVar",lua_ax_base_ParticleSystem_setStartRadiusVar);
        tolua_function(tolua_S,"getEndRadius",lua_ax_base_ParticleSystem_getEndRadius);
        tolua_function(tolua_S,"setEndRadius",lua_ax_base_ParticleSystem_setEndRadius);
        tolua_function(tolua_S,"getEndRadiusVar",lua_ax_base_ParticleSystem_getEndRadiusVar);
        tolua_function(tolua_S,"setEndRadiusVar",lua_ax_base_ParticleSystem_setEndRadiusVar);
        tolua_function(tolua_S,"getRotatePerSecond",lua_ax_base_ParticleSystem_getRotatePerSecond);
        tolua_function(tolua_S,"setRotatePerSecond",lua_ax_base_ParticleSystem_setRotatePerSecond);
        tolua_function(tolua_S,"getRotatePerSecondVar",lua_ax_base_ParticleSystem_getRotatePerSecondVar);
        tolua_function(tolua_S,"setRotatePerSecondVar",lua_ax_base_ParticleSystem_setRotatePerSecondVar);
        tolua_function(tolua_S,"isActive",lua_ax_base_ParticleSystem_isActive);
        tolua_function(tolua_S,"isBlendAdditive",lua_ax_base_ParticleSystem_isBlendAdditive);
        tolua_function(tolua_S,"setBlendAdditive",lua_ax_base_ParticleSystem_setBlendAdditive);
        tolua_function(tolua_S,"getBatchNode",lua_ax_base_ParticleSystem_getBatchNode);
        tolua_function(tolua_S,"setBatchNode",lua_ax_base_ParticleSystem_setBatchNode);
        tolua_function(tolua_S,"getAtlasIndex",lua_ax_base_ParticleSystem_getAtlasIndex);
        tolua_function(tolua_S,"setAtlasIndex",lua_ax_base_ParticleSystem_setAtlasIndex);
        tolua_function(tolua_S,"getParticleCount",lua_ax_base_ParticleSystem_getParticleCount);
        tolua_function(tolua_S,"getDuration",lua_ax_base_ParticleSystem_getDuration);
        tolua_function(tolua_S,"setDuration",lua_ax_base_ParticleSystem_setDuration);
        tolua_function(tolua_S,"getSourcePosition",lua_ax_base_ParticleSystem_getSourcePosition);
        tolua_function(tolua_S,"setSourcePosition",lua_ax_base_ParticleSystem_setSourcePosition);
        tolua_function(tolua_S,"getPosVar",lua_ax_base_ParticleSystem_getPosVar);
        tolua_function(tolua_S,"setPosVar",lua_ax_base_ParticleSystem_setPosVar);
        tolua_function(tolua_S,"getLife",lua_ax_base_ParticleSystem_getLife);
        tolua_function(tolua_S,"setLife",lua_ax_base_ParticleSystem_setLife);
        tolua_function(tolua_S,"getLifeVar",lua_ax_base_ParticleSystem_getLifeVar);
        tolua_function(tolua_S,"setLifeVar",lua_ax_base_ParticleSystem_setLifeVar);
        tolua_function(tolua_S,"getAngle",lua_ax_base_ParticleSystem_getAngle);
        tolua_function(tolua_S,"setAngle",lua_ax_base_ParticleSystem_setAngle);
        tolua_function(tolua_S,"getAngleVar",lua_ax_base_ParticleSystem_getAngleVar);
        tolua_function(tolua_S,"setAngleVar",lua_ax_base_ParticleSystem_setAngleVar);
        tolua_function(tolua_S,"getEmitterMode",lua_ax_base_ParticleSystem_getEmitterMode);
        tolua_function(tolua_S,"setEmitterMode",lua_ax_base_ParticleSystem_setEmitterMode);
        tolua_function(tolua_S,"getStartSize",lua_ax_base_ParticleSystem_getStartSize);
        tolua_function(tolua_S,"setStartSize",lua_ax_base_ParticleSystem_setStartSize);
        tolua_function(tolua_S,"getStartSizeVar",lua_ax_base_ParticleSystem_getStartSizeVar);
        tolua_function(tolua_S,"setStartSizeVar",lua_ax_base_ParticleSystem_setStartSizeVar);
        tolua_function(tolua_S,"getEndSize",lua_ax_base_ParticleSystem_getEndSize);
        tolua_function(tolua_S,"setEndSize",lua_ax_base_ParticleSystem_setEndSize);
        tolua_function(tolua_S,"getEndSizeVar",lua_ax_base_ParticleSystem_getEndSizeVar);
        tolua_function(tolua_S,"setEndSizeVar",lua_ax_base_ParticleSystem_setEndSizeVar);
        tolua_function(tolua_S,"getStartColor",lua_ax_base_ParticleSystem_getStartColor);
        tolua_function(tolua_S,"setStartColor",lua_ax_base_ParticleSystem_setStartColor);
        tolua_function(tolua_S,"getStartColorVar",lua_ax_base_ParticleSystem_getStartColorVar);
        tolua_function(tolua_S,"setStartColorVar",lua_ax_base_ParticleSystem_setStartColorVar);
        tolua_function(tolua_S,"getEndColor",lua_ax_base_ParticleSystem_getEndColor);
        tolua_function(tolua_S,"setEndColor",lua_ax_base_ParticleSystem_setEndColor);
        tolua_function(tolua_S,"getEndColorVar",lua_ax_base_ParticleSystem_getEndColorVar);
        tolua_function(tolua_S,"setEndColorVar",lua_ax_base_ParticleSystem_setEndColorVar);
        tolua_function(tolua_S,"useHSV",lua_ax_base_ParticleSystem_useHSV);
        tolua_function(tolua_S,"isHSV",lua_ax_base_ParticleSystem_isHSV);
        tolua_function(tolua_S,"getHue",lua_ax_base_ParticleSystem_getHue);
        tolua_function(tolua_S,"setHue",lua_ax_base_ParticleSystem_setHue);
        tolua_function(tolua_S,"getHueVar",lua_ax_base_ParticleSystem_getHueVar);
        tolua_function(tolua_S,"setHueVar",lua_ax_base_ParticleSystem_setHueVar);
        tolua_function(tolua_S,"getHSV",lua_ax_base_ParticleSystem_getHSV);
        tolua_function(tolua_S,"setHSV",lua_ax_base_ParticleSystem_setHSV);
        tolua_function(tolua_S,"getHSVVar",lua_ax_base_ParticleSystem_getHSVVar);
        tolua_function(tolua_S,"setHSVVar",lua_ax_base_ParticleSystem_setHSVVar);
        tolua_function(tolua_S,"getStartSpin",lua_ax_base_ParticleSystem_getStartSpin);
        tolua_function(tolua_S,"setStartSpin",lua_ax_base_ParticleSystem_setStartSpin);
        tolua_function(tolua_S,"getStartSpinVar",lua_ax_base_ParticleSystem_getStartSpinVar);
        tolua_function(tolua_S,"setStartSpinVar",lua_ax_base_ParticleSystem_setStartSpinVar);
        tolua_function(tolua_S,"getEndSpin",lua_ax_base_ParticleSystem_getEndSpin);
        tolua_function(tolua_S,"setEndSpin",lua_ax_base_ParticleSystem_setEndSpin);
        tolua_function(tolua_S,"getEndSpinVar",lua_ax_base_ParticleSystem_getEndSpinVar);
        tolua_function(tolua_S,"setEndSpinVar",lua_ax_base_ParticleSystem_setEndSpinVar);
        tolua_function(tolua_S,"getSpawnAngle",lua_ax_base_ParticleSystem_getSpawnAngle);
        tolua_function(tolua_S,"setSpawnAngle",lua_ax_base_ParticleSystem_setSpawnAngle);
        tolua_function(tolua_S,"getSpawnAngleVar",lua_ax_base_ParticleSystem_getSpawnAngleVar);
        tolua_function(tolua_S,"setSpawnAngleVar",lua_ax_base_ParticleSystem_setSpawnAngleVar);
        tolua_function(tolua_S,"getSpawnFadeIn",lua_ax_base_ParticleSystem_getSpawnFadeIn);
        tolua_function(tolua_S,"setSpawnFadeIn",lua_ax_base_ParticleSystem_setSpawnFadeIn);
        tolua_function(tolua_S,"getSpawnFadeInVar",lua_ax_base_ParticleSystem_getSpawnFadeInVar);
        tolua_function(tolua_S,"setSpawnFadeInVar",lua_ax_base_ParticleSystem_setSpawnFadeInVar);
        tolua_function(tolua_S,"getSpawnScaleIn",lua_ax_base_ParticleSystem_getSpawnScaleIn);
        tolua_function(tolua_S,"setSpawnScaleIn",lua_ax_base_ParticleSystem_setSpawnScaleIn);
        tolua_function(tolua_S,"getSpawnScaleInVar",lua_ax_base_ParticleSystem_getSpawnScaleInVar);
        tolua_function(tolua_S,"setSpawnScaleInVar",lua_ax_base_ParticleSystem_setSpawnScaleInVar);
        tolua_function(tolua_S,"getEmissionRate",lua_ax_base_ParticleSystem_getEmissionRate);
        tolua_function(tolua_S,"setEmissionRate",lua_ax_base_ParticleSystem_setEmissionRate);
        tolua_function(tolua_S,"getTotalParticles",lua_ax_base_ParticleSystem_getTotalParticles);
        tolua_function(tolua_S,"setTotalParticles",lua_ax_base_ParticleSystem_setTotalParticles);
        tolua_function(tolua_S,"setLifeAnimation",lua_ax_base_ParticleSystem_setLifeAnimation);
        tolua_function(tolua_S,"setEmitterAnimation",lua_ax_base_ParticleSystem_setEmitterAnimation);
        tolua_function(tolua_S,"setLoopAnimation",lua_ax_base_ParticleSystem_setLoopAnimation);
        tolua_function(tolua_S,"isLifeAnimated",lua_ax_base_ParticleSystem_isLifeAnimated);
        tolua_function(tolua_S,"isEmitterAnimated",lua_ax_base_ParticleSystem_isEmitterAnimated);
        tolua_function(tolua_S,"isLoopAnimated",lua_ax_base_ParticleSystem_isLoopAnimated);
        tolua_function(tolua_S,"getTotalAnimationIndices",lua_ax_base_ParticleSystem_getTotalAnimationIndices);
        tolua_function(tolua_S,"setAnimationReverse",lua_ax_base_ParticleSystem_setAnimationReverse);
        tolua_function(tolua_S,"isAnimationReversed",lua_ax_base_ParticleSystem_isAnimationReversed);
        tolua_function(tolua_S,"resetAnimationIndices",lua_ax_base_ParticleSystem_resetAnimationIndices);
        tolua_function(tolua_S,"resetAnimationDescriptors",lua_ax_base_ParticleSystem_resetAnimationDescriptors);
        tolua_function(tolua_S,"setMultiAnimationRandomSpecific",lua_ax_base_ParticleSystem_setMultiAnimationRandomSpecific);
        tolua_function(tolua_S,"setMultiAnimationRandom",lua_ax_base_ParticleSystem_setMultiAnimationRandom);
        tolua_function(tolua_S,"setAnimationIndicesAtlas",lua_ax_base_ParticleSystem_setAnimationIndicesAtlas);
        tolua_function(tolua_S,"addAnimationIndex",lua_ax_base_ParticleSystem_addAnimationIndex);
        tolua_function(tolua_S,"setRectForUndefinedIndices",lua_ax_base_ParticleSystem_setRectForUndefinedIndices);
        tolua_function(tolua_S,"setAnimationDescriptor",lua_ax_base_ParticleSystem_setAnimationDescriptor);
        tolua_function(tolua_S,"setAnimationSpeedTimescaleIndependent",lua_ax_base_ParticleSystem_setAnimationSpeedTimescaleIndependent);
        tolua_function(tolua_S,"isAnimationSpeedTimescaleIndependent",lua_ax_base_ParticleSystem_isAnimationSpeedTimescaleIndependent);
        tolua_function(tolua_S,"setEmissionShapes",lua_ax_base_ParticleSystem_setEmissionShapes);
        tolua_function(tolua_S,"isEmissionShapes",lua_ax_base_ParticleSystem_isEmissionShapes);
        tolua_function(tolua_S,"resetEmissionShapes",lua_ax_base_ParticleSystem_resetEmissionShapes);
        tolua_function(tolua_S,"addEmissionShape",lua_ax_base_ParticleSystem_addEmissionShape);
        tolua_function(tolua_S,"setEmissionShape",lua_ax_base_ParticleSystem_setEmissionShape);
        tolua_function(tolua_S,"getPositionType",lua_ax_base_ParticleSystem_getPositionType);
        tolua_function(tolua_S,"setPositionType",lua_ax_base_ParticleSystem_setPositionType);
        tolua_function(tolua_S,"simulate",lua_ax_base_ParticleSystem_simulate);
        tolua_function(tolua_S,"resimulate",lua_ax_base_ParticleSystem_resimulate);
        tolua_function(tolua_S,"getTexture",lua_ax_base_ParticleSystem_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_ParticleSystem_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_ParticleSystem_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_ParticleSystem_getBlendFunc);
        tolua_function(tolua_S,"getResourceFile",lua_ax_base_ParticleSystem_getResourceFile);
        tolua_function(tolua_S,"start",lua_ax_base_ParticleSystem_start);
        tolua_function(tolua_S,"stop",lua_ax_base_ParticleSystem_stop);
        tolua_function(tolua_S,"setSourcePositionCompatible",lua_ax_base_ParticleSystem_setSourcePositionCompatible);
        tolua_function(tolua_S,"isSourcePositionCompatible",lua_ax_base_ParticleSystem_isSourcePositionCompatible);
        tolua_function(tolua_S,"initWithFile",lua_ax_base_ParticleSystem_initWithFile);
        tolua_function(tolua_S,"initWithDictionary",lua_ax_base_ParticleSystem_initWithDictionary);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleSystem_initWithTotalParticles);
        tolua_function(tolua_S,"isPaused",lua_ax_base_ParticleSystem_isPaused);
        tolua_function(tolua_S,"pauseEmissions",lua_ax_base_ParticleSystem_pauseEmissions);
        tolua_function(tolua_S,"resumeEmissions",lua_ax_base_ParticleSystem_resumeEmissions);
        tolua_function(tolua_S,"getFixedFPS",lua_ax_base_ParticleSystem_getFixedFPS);
        tolua_function(tolua_S,"setFixedFPS",lua_ax_base_ParticleSystem_setFixedFPS);
        tolua_function(tolua_S,"getTimeScale",lua_ax_base_ParticleSystem_getTimeScale);
        tolua_function(tolua_S,"setTimeScale",lua_ax_base_ParticleSystem_setTimeScale);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSystem_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSystem_createWithTotalParticles);
        tolua_function(tolua_S,"getAllParticleSystems", lua_ax_base_ParticleSystem_getAllParticleSystems);
        tolua_function(tolua_S,"createMaskShape", lua_ax_base_ParticleSystem_createMaskShape);
        tolua_function(tolua_S,"createPointShape", lua_ax_base_ParticleSystem_createPointShape);
        tolua_function(tolua_S,"createRectShape", lua_ax_base_ParticleSystem_createRectShape);
        tolua_function(tolua_S,"createRectTorusShape", lua_ax_base_ParticleSystem_createRectTorusShape);
        tolua_function(tolua_S,"createCircleShape", lua_ax_base_ParticleSystem_createCircleShape);
        tolua_function(tolua_S,"createConeShape", lua_ax_base_ParticleSystem_createConeShape);
        tolua_function(tolua_S,"createTorusShape", lua_ax_base_ParticleSystem_createTorusShape);
        tolua_function(tolua_S,"createConeTorusShape", lua_ax_base_ParticleSystem_createConeTorusShape);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSystem).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSystem";
    g_typeCast[typeName] = "ax.ParticleSystem";
    return 1;
}

int lua_ax_base_ParticleSystemQuad_setDisplayFrame(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystemQuad* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystemQuad",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystemQuad*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystemQuad_setDisplayFrame'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::SpriteFrame* arg0;

        ok &= luaval_to_object<ax::SpriteFrame>(tolua_S, 2, "ax.SpriteFrame",&arg0, "ax.ParticleSystemQuad:setDisplayFrame");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystemQuad_setDisplayFrame'", nullptr);
            return 0;
        }
        cobj->setDisplayFrame(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystemQuad:setDisplayFrame",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_setDisplayFrame'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystemQuad_setTextureWithRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystemQuad* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystemQuad",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystemQuad*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystemQuad_setTextureWithRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Texture2D* arg0;
        ax::Rect arg1;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.ParticleSystemQuad:setTextureWithRect");

        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.ParticleSystemQuad:setTextureWithRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystemQuad_setTextureWithRect'", nullptr);
            return 0;
        }
        cobj->setTextureWithRect(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystemQuad:setTextureWithRect",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_setTextureWithRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystemQuad_listenRendererRecreated(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystemQuad* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSystemQuad",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSystemQuad*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSystemQuad_listenRendererRecreated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::EventCustom* arg0;

        ok &= luaval_to_object<ax::EventCustom>(tolua_S, 2, "ax.EventCustom",&arg0, "ax.ParticleSystemQuad:listenRendererRecreated");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystemQuad_listenRendererRecreated'", nullptr);
            return 0;
        }
        cobj->listenRendererRecreated(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystemQuad:listenRendererRecreated",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_listenRendererRecreated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSystemQuad_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystemQuad",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 1)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ParticleSystemQuad:create");
            if (!ok) { break; }
            ax::ParticleSystemQuad* ret = ax::ParticleSystemQuad::create(arg0);
            object_to_luaval<ax::ParticleSystemQuad>(tolua_S, "ax.ParticleSystemQuad",(ax::ParticleSystemQuad*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 0)
        {
            ax::ParticleSystemQuad* ret = ax::ParticleSystemQuad::create();
            object_to_luaval<ax::ParticleSystemQuad>(tolua_S, "ax.ParticleSystemQuad",(ax::ParticleSystemQuad*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::ValueMap arg0;
            ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.ParticleSystemQuad:create");
            if (!ok) { break; }
            ax::ParticleSystemQuad* ret = ax::ParticleSystemQuad::create(arg0);
            object_to_luaval<ax::ParticleSystemQuad>(tolua_S, "ax.ParticleSystemQuad",(ax::ParticleSystemQuad*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.ParticleSystemQuad:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystemQuad_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSystemQuad",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSystemQuad:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystemQuad_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSystemQuad::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSystemQuad>(tolua_S, "ax.ParticleSystemQuad",(ax::ParticleSystemQuad*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSystemQuad:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSystemQuad_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSystemQuad* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSystemQuad_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSystemQuad();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSystemQuad");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSystemQuad:ParticleSystemQuad",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSystemQuad_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSystemQuad_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSystemQuad)");
    return 0;
}

int lua_register_ax_base_ParticleSystemQuad(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSystemQuad");
    tolua_cclass(tolua_S,"ParticleSystemQuad","ax.ParticleSystemQuad","ax.ParticleSystem",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSystemQuad");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSystemQuad_constructor);
        tolua_function(tolua_S,"setDisplayFrame",lua_ax_base_ParticleSystemQuad_setDisplayFrame);
        tolua_function(tolua_S,"setTextureWithRect",lua_ax_base_ParticleSystemQuad_setTextureWithRect);
        tolua_function(tolua_S,"listenRendererRecreated",lua_ax_base_ParticleSystemQuad_listenRendererRecreated);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSystemQuad_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSystemQuad_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSystemQuad).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSystemQuad";
    g_typeCast[typeName] = "ax.ParticleSystemQuad";
    return 1;
}

int lua_ax_base_ParticleFire_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFire",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFire_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFire::create();
        object_to_luaval<ax::ParticleFire>(tolua_S, "ax.ParticleFire",(ax::ParticleFire*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFire:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFire_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFire_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFire",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleFire:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFire_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFire::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleFire>(tolua_S, "ax.ParticleFire",(ax::ParticleFire*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFire:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFire_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFire_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFire* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFire_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleFire();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleFire");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFire:ParticleFire",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFire_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleFire_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleFire)");
    return 0;
}

int lua_register_ax_base_ParticleFire(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleFire");
    tolua_cclass(tolua_S,"ParticleFire","ax.ParticleFire","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleFire");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleFire_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleFire_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleFire_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleFire).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleFire";
    g_typeCast[typeName] = "ax.ParticleFire";
    return 1;
}

int lua_ax_base_ParticleFireworks_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFireworks* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleFireworks",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleFireworks*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleFireworks_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFireworks_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFireworks:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFireworks_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleFireworks_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFireworks* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleFireworks",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleFireworks*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleFireworks_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleFireworks:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFireworks_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFireworks:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFireworks_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleFireworks_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFireworks",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFireworks_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFireworks::create();
        object_to_luaval<ax::ParticleFireworks>(tolua_S, "ax.ParticleFireworks",(ax::ParticleFireworks*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFireworks:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFireworks_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFireworks_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFireworks",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleFireworks:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFireworks_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFireworks::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleFireworks>(tolua_S, "ax.ParticleFireworks",(ax::ParticleFireworks*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFireworks:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFireworks_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFireworks_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFireworks* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFireworks_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleFireworks();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleFireworks");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFireworks:ParticleFireworks",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFireworks_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleFireworks_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleFireworks)");
    return 0;
}

int lua_register_ax_base_ParticleFireworks(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleFireworks");
    tolua_cclass(tolua_S,"ParticleFireworks","ax.ParticleFireworks","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleFireworks");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleFireworks_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleFireworks_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleFireworks_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleFireworks_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleFireworks_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleFireworks).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleFireworks";
    g_typeCast[typeName] = "ax.ParticleFireworks";
    return 1;
}

int lua_ax_base_ParticleSun_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSun* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSun",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSun*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSun_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSun_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSun:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSun_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSun_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSun* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSun",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSun*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSun_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSun:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSun_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSun:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSun_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSun_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSun",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSun_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSun::create();
        object_to_luaval<ax::ParticleSun>(tolua_S, "ax.ParticleSun",(ax::ParticleSun*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSun:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSun_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSun_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSun",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSun:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSun_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSun::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSun>(tolua_S, "ax.ParticleSun",(ax::ParticleSun*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSun:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSun_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSun_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSun* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSun_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSun();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSun");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSun:ParticleSun",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSun_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSun_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSun)");
    return 0;
}

int lua_register_ax_base_ParticleSun(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSun");
    tolua_cclass(tolua_S,"ParticleSun","ax.ParticleSun","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSun");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSun_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleSun_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleSun_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSun_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSun_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSun).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSun";
    g_typeCast[typeName] = "ax.ParticleSun";
    return 1;
}

int lua_ax_base_ParticleGalaxy_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleGalaxy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleGalaxy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleGalaxy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleGalaxy_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleGalaxy_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleGalaxy:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleGalaxy_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleGalaxy_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleGalaxy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleGalaxy",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleGalaxy*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleGalaxy_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleGalaxy:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleGalaxy_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleGalaxy:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleGalaxy_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleGalaxy_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleGalaxy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleGalaxy_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleGalaxy::create();
        object_to_luaval<ax::ParticleGalaxy>(tolua_S, "ax.ParticleGalaxy",(ax::ParticleGalaxy*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleGalaxy:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleGalaxy_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleGalaxy_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleGalaxy",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleGalaxy:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleGalaxy_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleGalaxy::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleGalaxy>(tolua_S, "ax.ParticleGalaxy",(ax::ParticleGalaxy*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleGalaxy:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleGalaxy_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleGalaxy_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleGalaxy* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleGalaxy_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleGalaxy();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleGalaxy");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleGalaxy:ParticleGalaxy",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleGalaxy_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleGalaxy_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleGalaxy)");
    return 0;
}

int lua_register_ax_base_ParticleGalaxy(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleGalaxy");
    tolua_cclass(tolua_S,"ParticleGalaxy","ax.ParticleGalaxy","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleGalaxy");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleGalaxy_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleGalaxy_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleGalaxy_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleGalaxy_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleGalaxy_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleGalaxy).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleGalaxy";
    g_typeCast[typeName] = "ax.ParticleGalaxy";
    return 1;
}

int lua_ax_base_ParticleFlower_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFlower* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleFlower",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleFlower*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleFlower_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFlower_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFlower:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFlower_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleFlower_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFlower* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleFlower",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleFlower*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleFlower_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleFlower:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFlower_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFlower:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFlower_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleFlower_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFlower",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFlower_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFlower::create();
        object_to_luaval<ax::ParticleFlower>(tolua_S, "ax.ParticleFlower",(ax::ParticleFlower*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFlower:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFlower_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFlower_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleFlower",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleFlower:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFlower_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleFlower::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleFlower>(tolua_S, "ax.ParticleFlower",(ax::ParticleFlower*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleFlower:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFlower_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleFlower_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleFlower* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleFlower_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleFlower();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleFlower");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleFlower:ParticleFlower",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleFlower_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleFlower_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleFlower)");
    return 0;
}

int lua_register_ax_base_ParticleFlower(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleFlower");
    tolua_cclass(tolua_S,"ParticleFlower","ax.ParticleFlower","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleFlower");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleFlower_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleFlower_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleFlower_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleFlower_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleFlower_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleFlower).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleFlower";
    g_typeCast[typeName] = "ax.ParticleFlower";
    return 1;
}

int lua_ax_base_ParticleMeteor_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleMeteor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleMeteor",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleMeteor*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleMeteor_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleMeteor_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleMeteor:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleMeteor_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleMeteor_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleMeteor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleMeteor",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleMeteor*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleMeteor_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleMeteor:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleMeteor_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleMeteor:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleMeteor_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleMeteor_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleMeteor",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleMeteor_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleMeteor::create();
        object_to_luaval<ax::ParticleMeteor>(tolua_S, "ax.ParticleMeteor",(ax::ParticleMeteor*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleMeteor:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleMeteor_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleMeteor_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleMeteor",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleMeteor:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleMeteor_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleMeteor::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleMeteor>(tolua_S, "ax.ParticleMeteor",(ax::ParticleMeteor*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleMeteor:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleMeteor_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleMeteor_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleMeteor* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleMeteor_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleMeteor();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleMeteor");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleMeteor:ParticleMeteor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleMeteor_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleMeteor_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleMeteor)");
    return 0;
}

int lua_register_ax_base_ParticleMeteor(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleMeteor");
    tolua_cclass(tolua_S,"ParticleMeteor","ax.ParticleMeteor","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleMeteor");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleMeteor_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleMeteor_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleMeteor_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleMeteor_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleMeteor_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleMeteor).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleMeteor";
    g_typeCast[typeName] = "ax.ParticleMeteor";
    return 1;
}

int lua_ax_base_ParticleSpiral_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSpiral* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSpiral",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSpiral*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSpiral_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSpiral_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSpiral:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSpiral_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSpiral_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSpiral* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSpiral",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSpiral*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSpiral_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSpiral:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSpiral_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSpiral:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSpiral_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSpiral_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSpiral",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSpiral_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSpiral::create();
        object_to_luaval<ax::ParticleSpiral>(tolua_S, "ax.ParticleSpiral",(ax::ParticleSpiral*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSpiral:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSpiral_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSpiral_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSpiral",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSpiral:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSpiral_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSpiral::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSpiral>(tolua_S, "ax.ParticleSpiral",(ax::ParticleSpiral*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSpiral:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSpiral_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSpiral_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSpiral* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSpiral_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSpiral();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSpiral");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSpiral:ParticleSpiral",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSpiral_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSpiral_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSpiral)");
    return 0;
}

int lua_register_ax_base_ParticleSpiral(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSpiral");
    tolua_cclass(tolua_S,"ParticleSpiral","ax.ParticleSpiral","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSpiral");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSpiral_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleSpiral_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleSpiral_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSpiral_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSpiral_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSpiral).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSpiral";
    g_typeCast[typeName] = "ax.ParticleSpiral";
    return 1;
}

int lua_ax_base_ParticleExplosion_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleExplosion* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleExplosion",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleExplosion*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleExplosion_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleExplosion_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleExplosion:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleExplosion_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleExplosion_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleExplosion* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleExplosion",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleExplosion*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleExplosion_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleExplosion:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleExplosion_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleExplosion:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleExplosion_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleExplosion_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleExplosion",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleExplosion_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleExplosion::create();
        object_to_luaval<ax::ParticleExplosion>(tolua_S, "ax.ParticleExplosion",(ax::ParticleExplosion*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleExplosion:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleExplosion_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleExplosion_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleExplosion",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleExplosion:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleExplosion_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleExplosion::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleExplosion>(tolua_S, "ax.ParticleExplosion",(ax::ParticleExplosion*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleExplosion:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleExplosion_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleExplosion_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleExplosion* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleExplosion_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleExplosion();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleExplosion");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleExplosion:ParticleExplosion",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleExplosion_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleExplosion_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleExplosion)");
    return 0;
}

int lua_register_ax_base_ParticleExplosion(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleExplosion");
    tolua_cclass(tolua_S,"ParticleExplosion","ax.ParticleExplosion","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleExplosion");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleExplosion_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleExplosion_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleExplosion_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleExplosion_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleExplosion_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleExplosion).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleExplosion";
    g_typeCast[typeName] = "ax.ParticleExplosion";
    return 1;
}

int lua_ax_base_ParticleSmoke_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSmoke* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSmoke",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSmoke*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSmoke_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSmoke_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSmoke:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSmoke_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSmoke_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSmoke* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSmoke",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSmoke*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSmoke_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSmoke:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSmoke_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSmoke:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSmoke_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSmoke_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSmoke",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSmoke_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSmoke::create();
        object_to_luaval<ax::ParticleSmoke>(tolua_S, "ax.ParticleSmoke",(ax::ParticleSmoke*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSmoke:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSmoke_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSmoke_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSmoke",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSmoke:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSmoke_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSmoke::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSmoke>(tolua_S, "ax.ParticleSmoke",(ax::ParticleSmoke*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSmoke:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSmoke_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSmoke_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSmoke* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSmoke_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSmoke();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSmoke");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSmoke:ParticleSmoke",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSmoke_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSmoke_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSmoke)");
    return 0;
}

int lua_register_ax_base_ParticleSmoke(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSmoke");
    tolua_cclass(tolua_S,"ParticleSmoke","ax.ParticleSmoke","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSmoke");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSmoke_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleSmoke_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleSmoke_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSmoke_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSmoke_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSmoke).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSmoke";
    g_typeCast[typeName] = "ax.ParticleSmoke";
    return 1;
}

int lua_ax_base_ParticleSnow_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSnow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSnow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSnow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSnow_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSnow_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSnow:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSnow_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSnow_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSnow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleSnow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleSnow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleSnow_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSnow:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSnow_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSnow:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSnow_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleSnow_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSnow",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSnow_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSnow::create();
        object_to_luaval<ax::ParticleSnow>(tolua_S, "ax.ParticleSnow",(ax::ParticleSnow*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSnow:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSnow_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSnow_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleSnow",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleSnow:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSnow_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleSnow::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleSnow>(tolua_S, "ax.ParticleSnow",(ax::ParticleSnow*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleSnow:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSnow_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleSnow_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleSnow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleSnow_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleSnow();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleSnow");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleSnow:ParticleSnow",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleSnow_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleSnow_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleSnow)");
    return 0;
}

int lua_register_ax_base_ParticleSnow(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleSnow");
    tolua_cclass(tolua_S,"ParticleSnow","ax.ParticleSnow","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleSnow");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleSnow_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleSnow_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleSnow_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleSnow_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleSnow_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleSnow).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleSnow";
    g_typeCast[typeName] = "ax.ParticleSnow";
    return 1;
}

int lua_ax_base_ParticleRain_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleRain* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleRain",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleRain*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleRain_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleRain_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleRain:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleRain_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleRain_initWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleRain* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParticleRain",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParticleRain*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParticleRain_initWithTotalParticles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleRain:initWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleRain_initWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTotalParticles(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleRain:initWithTotalParticles",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleRain_initWithTotalParticles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParticleRain_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleRain",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleRain_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleRain::create();
        object_to_luaval<ax::ParticleRain>(tolua_S, "ax.ParticleRain",(ax::ParticleRain*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleRain:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleRain_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleRain_createWithTotalParticles(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParticleRain",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        int arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ParticleRain:createWithTotalParticles");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleRain_createWithTotalParticles'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParticleRain::createWithTotalParticles(arg0);
        object_to_luaval<ax::ParticleRain>(tolua_S, "ax.ParticleRain",(ax::ParticleRain*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParticleRain:createWithTotalParticles",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleRain_createWithTotalParticles'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParticleRain_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParticleRain* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParticleRain_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParticleRain();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParticleRain");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParticleRain:ParticleRain",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParticleRain_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParticleRain_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParticleRain)");
    return 0;
}

int lua_register_ax_base_ParticleRain(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParticleRain");
    tolua_cclass(tolua_S,"ParticleRain","ax.ParticleRain","ax.ParticleSystemQuad",nullptr);

    tolua_beginmodule(tolua_S,"ParticleRain");
        tolua_function(tolua_S,"new",lua_ax_base_ParticleRain_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_ParticleRain_init);
        tolua_function(tolua_S,"initWithTotalParticles",lua_ax_base_ParticleRain_initWithTotalParticles);
        tolua_function(tolua_S,"create", lua_ax_base_ParticleRain_create);
        tolua_function(tolua_S,"createWithTotalParticles", lua_ax_base_ParticleRain_createWithTotalParticles);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParticleRain).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParticleRain";
    g_typeCast[typeName] = "ax.ParticleRain";
    return 1;
}

int lua_ax_base_ProgressTimer_getType(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_getType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_getType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:getType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_getType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_getPercentage(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_getPercentage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_getPercentage'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPercentage();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:getPercentage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_getPercentage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_getSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_getSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_getSprite'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSprite();
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:getSprite",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_getSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setPercentage(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setPercentage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ProgressTimer:setPercentage");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setPercentage'", nullptr);
            return 0;
        }
        cobj->setPercentage(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setPercentage",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setPercentage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.ProgressTimer:setSprite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setSprite'", nullptr);
            return 0;
        }
        cobj->setSprite(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setSprite",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setType(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ProgressTimer::Type arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ProgressTimer:setType");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setType'", nullptr);
            return 0;
        }
        cobj->setType(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setType",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_isReverseDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_isReverseDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_isReverseDirection'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isReverseDirection();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:isReverseDirection",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_isReverseDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setReverseDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setReverseDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ProgressTimer:setReverseDirection");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setReverseDirection'", nullptr);
            return 0;
        }
        cobj->setReverseDirection(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setReverseDirection",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setReverseDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setMidpoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setMidpoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ProgressTimer:setMidpoint");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setMidpoint'", nullptr);
            return 0;
        }
        cobj->setMidpoint(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setMidpoint",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setMidpoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_getMidpoint(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_getMidpoint'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_getMidpoint'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMidpoint();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:getMidpoint",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_getMidpoint'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_setBarChangeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_setBarChangeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.ProgressTimer:setBarChangeRate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_setBarChangeRate'", nullptr);
            return 0;
        }
        cobj->setBarChangeRate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:setBarChangeRate",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_setBarChangeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_getBarChangeRate(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_getBarChangeRate'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_getBarChangeRate'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBarChangeRate();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:getBarChangeRate",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_getBarChangeRate'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_initWithSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProgressTimer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProgressTimer_initWithSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.ProgressTimer:initWithSprite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_initWithSprite'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithSprite(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:initWithSprite",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_initWithSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProgressTimer_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ProgressTimer",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Sprite* arg0;
        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.ProgressTimer:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ProgressTimer::create(arg0);
        object_to_luaval<ax::ProgressTimer>(tolua_S, "ax.ProgressTimer",(ax::ProgressTimer*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ProgressTimer:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ProgressTimer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProgressTimer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProgressTimer_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ProgressTimer();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ProgressTimer");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProgressTimer:ProgressTimer",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProgressTimer_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ProgressTimer_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ProgressTimer)");
    return 0;
}

int lua_register_ax_base_ProgressTimer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ProgressTimer");
    tolua_cclass(tolua_S,"ProgressTimer","ax.ProgressTimer","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ProgressTimer");
        tolua_function(tolua_S,"new",lua_ax_base_ProgressTimer_constructor);
        tolua_function(tolua_S,"getType",lua_ax_base_ProgressTimer_getType);
        tolua_function(tolua_S,"getPercentage",lua_ax_base_ProgressTimer_getPercentage);
        tolua_function(tolua_S,"getSprite",lua_ax_base_ProgressTimer_getSprite);
        tolua_function(tolua_S,"setPercentage",lua_ax_base_ProgressTimer_setPercentage);
        tolua_function(tolua_S,"setSprite",lua_ax_base_ProgressTimer_setSprite);
        tolua_function(tolua_S,"setType",lua_ax_base_ProgressTimer_setType);
        tolua_function(tolua_S,"isReverseDirection",lua_ax_base_ProgressTimer_isReverseDirection);
        tolua_function(tolua_S,"setReverseDirection",lua_ax_base_ProgressTimer_setReverseDirection);
        tolua_function(tolua_S,"setMidpoint",lua_ax_base_ProgressTimer_setMidpoint);
        tolua_function(tolua_S,"getMidpoint",lua_ax_base_ProgressTimer_getMidpoint);
        tolua_function(tolua_S,"setBarChangeRate",lua_ax_base_ProgressTimer_setBarChangeRate);
        tolua_function(tolua_S,"getBarChangeRate",lua_ax_base_ProgressTimer_getBarChangeRate);
        tolua_function(tolua_S,"initWithSprite",lua_ax_base_ProgressTimer_initWithSprite);
        tolua_function(tolua_S,"create", lua_ax_base_ProgressTimer_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ProgressTimer).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ProgressTimer";
    g_typeCast[typeName] = "ax.ProgressTimer";
    return 1;
}

int lua_ax_base_ProtectedNode_addProtectedChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_addProtectedChild'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            cobj->addProtectedChild(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            cobj->addProtectedChild(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Node* arg0;
            ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            int arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.ProtectedNode:addProtectedChild");

            if (!ok) { break; }
            cobj->addProtectedChild(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.ProtectedNode:addProtectedChild",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_addProtectedChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_getProtectedChildByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_getProtectedChildByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ProtectedNode:getProtectedChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_getProtectedChildByTag'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProtectedChildByTag(arg0);
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:getProtectedChildByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_getProtectedChildByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_getProtectedChildByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_getProtectedChildByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ProtectedNode:getProtectedChildByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_getProtectedChildByName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProtectedChildByName(arg0);
        object_to_luaval<ax::Node>(tolua_S, "ax.Node",(ax::Node*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:getProtectedChildByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_getProtectedChildByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_removeProtectedChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_removeProtectedChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:removeProtectedChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeProtectedChild'", nullptr);
            return 0;
        }
        cobj->removeProtectedChild(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Node* arg0;
        bool arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:removeProtectedChild");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.ProtectedNode:removeProtectedChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeProtectedChild'", nullptr);
            return 0;
        }
        cobj->removeProtectedChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:removeProtectedChild",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_removeProtectedChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_removeProtectedChildByTag(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_removeProtectedChildByTag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ProtectedNode:removeProtectedChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeProtectedChildByTag'", nullptr);
            return 0;
        }
        cobj->removeProtectedChildByTag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        int arg0;
        bool arg1;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.ProtectedNode:removeProtectedChildByTag");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.ProtectedNode:removeProtectedChildByTag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeProtectedChildByTag'", nullptr);
            return 0;
        }
        cobj->removeProtectedChildByTag(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:removeProtectedChildByTag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_removeProtectedChildByTag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_removeAllProtectedChildren(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildren'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildren'", nullptr);
            return 0;
        }
        cobj->removeAllProtectedChildren();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:removeAllProtectedChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildren'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_removeAllProtectedChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ProtectedNode:removeAllProtectedChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllProtectedChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:removeAllProtectedChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_removeAllProtectedChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_reorderProtectedChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_reorderProtectedChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Node* arg0;
        int arg1;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ProtectedNode:reorderProtectedChild");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ProtectedNode:reorderProtectedChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_reorderProtectedChild'", nullptr);
            return 0;
        }
        cobj->reorderProtectedChild(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:reorderProtectedChild",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_reorderProtectedChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_sortAllProtectedChildren(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_sortAllProtectedChildren'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_sortAllProtectedChildren'", nullptr);
            return 0;
        }
        cobj->sortAllProtectedChildren();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:sortAllProtectedChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_sortAllProtectedChildren'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_getProtectedChildren(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_getProtectedChildren'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_getProtectedChildren'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProtectedChildren();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:getProtectedChildren",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_getProtectedChildren'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_disableCascadeColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_disableCascadeColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_disableCascadeColor'", nullptr);
            return 0;
        }
        cobj->disableCascadeColor();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:disableCascadeColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_disableCascadeColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_disableCascadeOpacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ProtectedNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ProtectedNode_disableCascadeOpacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_disableCascadeOpacity'", nullptr);
            return 0;
        }
        cobj->disableCascadeOpacity();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:disableCascadeOpacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_disableCascadeOpacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ProtectedNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ProtectedNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ProtectedNode::create();
        object_to_luaval<ax::ProtectedNode>(tolua_S, "ax.ProtectedNode",(ax::ProtectedNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ProtectedNode:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ProtectedNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ProtectedNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ProtectedNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ProtectedNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ProtectedNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ProtectedNode:ProtectedNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ProtectedNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ProtectedNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ProtectedNode)");
    return 0;
}

int lua_register_ax_base_ProtectedNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ProtectedNode");
    tolua_cclass(tolua_S,"ProtectedNode","ax.ProtectedNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ProtectedNode");
        tolua_function(tolua_S,"new",lua_ax_base_ProtectedNode_constructor);
        tolua_function(tolua_S,"addProtectedChild",lua_ax_base_ProtectedNode_addProtectedChild);
        tolua_function(tolua_S,"getProtectedChildByTag",lua_ax_base_ProtectedNode_getProtectedChildByTag);
        tolua_function(tolua_S,"getProtectedChildByName",lua_ax_base_ProtectedNode_getProtectedChildByName);
        tolua_function(tolua_S,"removeProtectedChild",lua_ax_base_ProtectedNode_removeProtectedChild);
        tolua_function(tolua_S,"removeProtectedChildByTag",lua_ax_base_ProtectedNode_removeProtectedChildByTag);
        tolua_function(tolua_S,"removeAllProtectedChildren",lua_ax_base_ProtectedNode_removeAllProtectedChildren);
        tolua_function(tolua_S,"removeAllProtectedChildrenWithCleanup",lua_ax_base_ProtectedNode_removeAllProtectedChildrenWithCleanup);
        tolua_function(tolua_S,"reorderProtectedChild",lua_ax_base_ProtectedNode_reorderProtectedChild);
        tolua_function(tolua_S,"sortAllProtectedChildren",lua_ax_base_ProtectedNode_sortAllProtectedChildren);
        tolua_function(tolua_S,"getProtectedChildren",lua_ax_base_ProtectedNode_getProtectedChildren);
        tolua_function(tolua_S,"disableCascadeColor",lua_ax_base_ProtectedNode_disableCascadeColor);
        tolua_function(tolua_S,"disableCascadeOpacity",lua_ax_base_ProtectedNode_disableCascadeOpacity);
        tolua_function(tolua_S,"create", lua_ax_base_ProtectedNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ProtectedNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ProtectedNode";
    g_typeCast[typeName] = "ax.ProtectedNode";
    return 1;
}

int lua_ax_base_RenderTexture_begin(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_begin'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_begin'", nullptr);
            return 0;
        }
        cobj->begin();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:begin",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_begin'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_beginWithClear(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_beginWithClear'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 6) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg3;
            ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            double arg4;
            ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            int arg5;
            ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.RenderTexture:beginWithClear");

            if (!ok) { break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4, arg5);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RenderTexture:beginWithClear",argc, 6);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_beginWithClear'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_end(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_end'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_end'", nullptr);
            return 0;
        }
        cobj->end();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:end",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_end'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_clear(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_clear'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:clear");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.RenderTexture:clear");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.RenderTexture:clear");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.RenderTexture:clear");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_clear'", nullptr);
            return 0;
        }
        cobj->clear(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:clear",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_clear'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_clearDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_clearDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:clearDepth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_clearDepth'", nullptr);
            return 0;
        }
        cobj->clearDepth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:clearDepth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_clearDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_clearStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_clearStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:clearStencil");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_clearStencil'", nullptr);
            return 0;
        }
        cobj->clearStencil(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:clearStencil",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_clearStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_saveToFileAsNonPMA(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_saveToFileAsNonPMA'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            ax::Image::Format arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            std::function<void (ax::RenderTexture *, std::string_view)> arg3;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            bool ret = cobj->saveToFileAsNonPMA(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            bool ret = cobj->saveToFileAsNonPMA(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            bool ret = cobj->saveToFileAsNonPMA(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.RenderTexture:saveToFileAsNonPMA");

            if (!ok) { break; }
            std::function<void (ax::RenderTexture *, std::string_view)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            bool ret = cobj->saveToFileAsNonPMA(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RenderTexture:saveToFileAsNonPMA",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_saveToFileAsNonPMA'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_saveToFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_saveToFile'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            ax::Image::Format arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            ax::Image::Format arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            ax::Image::Format arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            std::function<void (ax::RenderTexture *, std::string_view)> arg3;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            bool arg1;
            ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.RenderTexture:saveToFile");

            if (!ok) { break; }
            std::function<void (ax::RenderTexture *, std::string_view)> arg2;
            do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

            if (!ok) { break; }
            bool ret = cobj->saveToFile(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RenderTexture:saveToFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_saveToFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getClearFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getClearFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getClearFlags'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getClearFlags();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getClearFlags",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getClearFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setClearFlags(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setClearFlags'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::TargetBufferFlags arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:setClearFlags");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setClearFlags'", nullptr);
            return 0;
        }
        cobj->setClearFlags(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setClearFlags",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setClearFlags'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getClearColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getClearColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getClearColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getClearColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getClearColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setClearColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setClearColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.RenderTexture:setClearColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setClearColor'", nullptr);
            return 0;
        }
        cobj->setClearColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setClearColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setClearColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getClearDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getClearDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getClearDepth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearDepth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getClearDepth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getClearDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setClearDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setClearDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.RenderTexture:setClearDepth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setClearDepth'", nullptr);
            return 0;
        }
        cobj->setClearDepth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setClearDepth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setClearDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getClearStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getClearStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getClearStencil'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearStencil();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getClearStencil",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getClearStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setClearStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setClearStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:setClearStencil");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setClearStencil'", nullptr);
            return 0;
        }
        cobj->setClearStencil(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setClearStencil",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setClearStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_isAutoDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_isAutoDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_isAutoDraw'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isAutoDraw();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:isAutoDraw",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_isAutoDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setAutoDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setAutoDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.RenderTexture:setAutoDraw");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setAutoDraw'", nullptr);
            return 0;
        }
        cobj->setAutoDraw(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setAutoDraw",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setAutoDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getSprite'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSprite();
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getSprite",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_getRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_getRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_getRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderTarget();
        object_to_luaval<ax::backend::RenderTarget>(tolua_S, "axb.RenderTarget",(ax::backend::RenderTarget*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:getRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_getRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.RenderTexture:setSprite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setSprite'", nullptr);
            return 0;
        }
        cobj->setSprite(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setSprite",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setKeepMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setKeepMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.RenderTexture:setKeepMatrix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setKeepMatrix'", nullptr);
            return 0;
        }
        cobj->setKeepMatrix(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setKeepMatrix",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setKeepMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_setVirtualViewport(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_setVirtualViewport'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Vec2 arg0;
        ax::Rect arg1;
        ax::Rect arg2;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.RenderTexture:setVirtualViewport");

        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.RenderTexture:setVirtualViewport");

        ok &= luaval_to_rect(tolua_S, 4, &arg2, "ax.RenderTexture:setVirtualViewport");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_setVirtualViewport'", nullptr);
            return 0;
        }
        cobj->setVirtualViewport(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:setVirtualViewport",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_setVirtualViewport'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_isSharedRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_isSharedRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_isSharedRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isSharedRenderTarget();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:isSharedRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_isSharedRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_initWithWidthAndHeight(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::RenderTexture*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderTexture_initWithWidthAndHeight'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 4) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.RenderTexture:initWithWidthAndHeight");

            if (!ok) { break; }
            bool ret = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.RenderTexture:initWithWidthAndHeight",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_initWithWidthAndHeight'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderTexture_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.RenderTexture",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 3)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1, arg2);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:create");
            if (!ok) { break; }
            bool arg3;
            ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::backend::PixelFormat arg3;
            ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.RenderTexture:create");
            if (!ok) { break; }
            bool arg4;
            ok &= luaval_to_boolean(tolua_S, 6,&arg4, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 2)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.RenderTexture:create");
            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.RenderTexture:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.RenderTexture:create");
            if (!ok) { break; }
            ax::RenderTexture* ret = ax::RenderTexture::create(arg0, arg1, arg2);
            object_to_luaval<ax::RenderTexture>(tolua_S, "ax.RenderTexture",(ax::RenderTexture*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.RenderTexture:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_RenderTexture_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderTexture* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderTexture_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::RenderTexture();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.RenderTexture");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderTexture:RenderTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderTexture_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_RenderTexture_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RenderTexture)");
    return 0;
}

int lua_register_ax_base_RenderTexture(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RenderTexture");
    tolua_cclass(tolua_S,"RenderTexture","ax.RenderTexture","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"RenderTexture");
        tolua_function(tolua_S,"new",lua_ax_base_RenderTexture_constructor);
        tolua_function(tolua_S,"begin",lua_ax_base_RenderTexture_begin);
        tolua_function(tolua_S,"beginWithClear",lua_ax_base_RenderTexture_beginWithClear);
        tolua_function(tolua_S,"endToLua",lua_ax_base_RenderTexture_end);
        tolua_function(tolua_S,"clear",lua_ax_base_RenderTexture_clear);
        tolua_function(tolua_S,"clearDepth",lua_ax_base_RenderTexture_clearDepth);
        tolua_function(tolua_S,"clearStencil",lua_ax_base_RenderTexture_clearStencil);
        tolua_function(tolua_S,"saveToFileAsNonPMA",lua_ax_base_RenderTexture_saveToFileAsNonPMA);
        tolua_function(tolua_S,"saveToFile",lua_ax_base_RenderTexture_saveToFile);
        tolua_function(tolua_S,"getClearFlags",lua_ax_base_RenderTexture_getClearFlags);
        tolua_function(tolua_S,"setClearFlags",lua_ax_base_RenderTexture_setClearFlags);
        tolua_function(tolua_S,"getClearColor",lua_ax_base_RenderTexture_getClearColor);
        tolua_function(tolua_S,"setClearColor",lua_ax_base_RenderTexture_setClearColor);
        tolua_function(tolua_S,"getClearDepth",lua_ax_base_RenderTexture_getClearDepth);
        tolua_function(tolua_S,"setClearDepth",lua_ax_base_RenderTexture_setClearDepth);
        tolua_function(tolua_S,"getClearStencil",lua_ax_base_RenderTexture_getClearStencil);
        tolua_function(tolua_S,"setClearStencil",lua_ax_base_RenderTexture_setClearStencil);
        tolua_function(tolua_S,"isAutoDraw",lua_ax_base_RenderTexture_isAutoDraw);
        tolua_function(tolua_S,"setAutoDraw",lua_ax_base_RenderTexture_setAutoDraw);
        tolua_function(tolua_S,"getSprite",lua_ax_base_RenderTexture_getSprite);
        tolua_function(tolua_S,"getRenderTarget",lua_ax_base_RenderTexture_getRenderTarget);
        tolua_function(tolua_S,"setSprite",lua_ax_base_RenderTexture_setSprite);
        tolua_function(tolua_S,"setKeepMatrix",lua_ax_base_RenderTexture_setKeepMatrix);
        tolua_function(tolua_S,"setVirtualViewport",lua_ax_base_RenderTexture_setVirtualViewport);
        tolua_function(tolua_S,"isSharedRenderTarget",lua_ax_base_RenderTexture_isSharedRenderTarget);
        tolua_function(tolua_S,"initWithWidthAndHeight",lua_ax_base_RenderTexture_initWithWidthAndHeight);
        tolua_function(tolua_S,"create", lua_ax_base_RenderTexture_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RenderTexture).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RenderTexture";
    g_typeCast[typeName] = "ax.RenderTexture";
    return 1;
}

int lua_ax_base_TransitionEaseScene_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionEaseScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionEaseScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionEaseScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionEaseScene_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionEaseScene:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionEaseScene_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionEaseScene:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionEaseScene_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_TransitionEaseScene_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionEaseScene)");
    return 0;
}

int lua_register_ax_base_TransitionEaseScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionEaseScene");
    tolua_cclass(tolua_S,"TransitionEaseScene","ax.TransitionEaseScene","",nullptr);

    tolua_beginmodule(tolua_S,"TransitionEaseScene");
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionEaseScene_easeActionWithAction);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionEaseScene).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionEaseScene";
    g_typeCast[typeName] = "ax.TransitionEaseScene";
    return 1;
}

int lua_ax_base_TransitionScene_finish(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionScene_finish'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_finish'", nullptr);
            return 0;
        }
        cobj->finish();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:finish",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_finish'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionScene_hideOutShowIn(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionScene_hideOutShowIn'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_hideOutShowIn'", nullptr);
            return 0;
        }
        cobj->hideOutShowIn();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:hideOutShowIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_hideOutShowIn'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionScene_getInScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionScene_getInScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_getInScene'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInScene();
        object_to_luaval<ax::Scene>(tolua_S, "ax.Scene",(ax::Scene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:getInScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_getInScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionScene_getDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionScene_getDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_getDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDuration();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:getDuration",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_getDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionScene_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionScene*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionScene_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        double arg0;
        ax::Scene* arg1;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionScene:initWithDuration");

        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionScene:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:initWithDuration",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionScene_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionScene",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionScene:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionScene:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionScene::create(arg0, arg1);
        object_to_luaval<ax::TransitionScene>(tolua_S, "ax.TransitionScene",(ax::TransitionScene*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionScene:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionScene_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionScene* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionScene_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionScene();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionScene");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionScene:TransitionScene",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionScene_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionScene_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionScene)");
    return 0;
}

int lua_register_ax_base_TransitionScene(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionScene");
    tolua_cclass(tolua_S,"TransitionScene","ax.TransitionScene","ax.Scene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionScene");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionScene_constructor);
        tolua_function(tolua_S,"finish",lua_ax_base_TransitionScene_finish);
        tolua_function(tolua_S,"hideOutShowIn",lua_ax_base_TransitionScene_hideOutShowIn);
        tolua_function(tolua_S,"getInScene",lua_ax_base_TransitionScene_getInScene);
        tolua_function(tolua_S,"getDuration",lua_ax_base_TransitionScene_getDuration);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TransitionScene_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionScene_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionScene).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionScene";
    g_typeCast[typeName] = "ax.TransitionScene";
    return 1;
}

int lua_ax_base_TransitionSceneOriented_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSceneOriented* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionSceneOriented",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionSceneOriented*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionSceneOriented_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        ax::Scene* arg1;
        ax::TransitionScene::Orientation arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSceneOriented:initWithDuration");

        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSceneOriented:initWithDuration");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionSceneOriented:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSceneOriented_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSceneOriented:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSceneOriented_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionSceneOriented_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSceneOriented",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        ax::Scene* arg1;
        ax::TransitionScene::Orientation arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSceneOriented:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSceneOriented:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionSceneOriented:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSceneOriented_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSceneOriented::create(arg0, arg1, arg2);
        object_to_luaval<ax::TransitionSceneOriented>(tolua_S, "ax.TransitionSceneOriented",(ax::TransitionSceneOriented*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSceneOriented:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSceneOriented_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSceneOriented_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSceneOriented* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSceneOriented_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSceneOriented();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSceneOriented");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSceneOriented:TransitionSceneOriented",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSceneOriented_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSceneOriented_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSceneOriented)");
    return 0;
}

int lua_register_ax_base_TransitionSceneOriented(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSceneOriented");
    tolua_cclass(tolua_S,"TransitionSceneOriented","ax.TransitionSceneOriented","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSceneOriented");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSceneOriented_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TransitionSceneOriented_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSceneOriented_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSceneOriented).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSceneOriented";
    g_typeCast[typeName] = "ax.TransitionSceneOriented";
    return 1;
}

int lua_ax_base_TransitionRotoZoom_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionRotoZoom",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionRotoZoom:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionRotoZoom:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionRotoZoom_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionRotoZoom::create(arg0, arg1);
        object_to_luaval<ax::TransitionRotoZoom>(tolua_S, "ax.TransitionRotoZoom",(ax::TransitionRotoZoom*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionRotoZoom:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionRotoZoom_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionRotoZoom_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionRotoZoom* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionRotoZoom_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionRotoZoom();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionRotoZoom");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionRotoZoom:TransitionRotoZoom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionRotoZoom_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionRotoZoom_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionRotoZoom)");
    return 0;
}

int lua_register_ax_base_TransitionRotoZoom(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionRotoZoom");
    tolua_cclass(tolua_S,"TransitionRotoZoom","ax.TransitionRotoZoom","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionRotoZoom");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionRotoZoom_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionRotoZoom_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionRotoZoom).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionRotoZoom";
    g_typeCast[typeName] = "ax.TransitionRotoZoom";
    return 1;
}

int lua_ax_base_TransitionJumpZoom_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionJumpZoom",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionJumpZoom:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionJumpZoom:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionJumpZoom_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionJumpZoom::create(arg0, arg1);
        object_to_luaval<ax::TransitionJumpZoom>(tolua_S, "ax.TransitionJumpZoom",(ax::TransitionJumpZoom*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionJumpZoom:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionJumpZoom_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionJumpZoom_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionJumpZoom* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionJumpZoom_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionJumpZoom();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionJumpZoom");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionJumpZoom:TransitionJumpZoom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionJumpZoom_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionJumpZoom_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionJumpZoom)");
    return 0;
}

int lua_register_ax_base_TransitionJumpZoom(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionJumpZoom");
    tolua_cclass(tolua_S,"TransitionJumpZoom","ax.TransitionJumpZoom","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionJumpZoom");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionJumpZoom_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionJumpZoom_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionJumpZoom).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionJumpZoom";
    g_typeCast[typeName] = "ax.TransitionJumpZoom";
    return 1;
}

int lua_ax_base_TransitionMoveInL_action(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionMoveInL",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionMoveInL*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionMoveInL_action'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInL_action'", nullptr);
            return 0;
        }
        auto&& ret = cobj->action();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInL:action",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInL_action'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionMoveInL_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionMoveInL",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionMoveInL*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionMoveInL_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionMoveInL:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInL_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInL:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInL_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionMoveInL_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionMoveInL",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionMoveInL:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionMoveInL:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInL_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionMoveInL::create(arg0, arg1);
        object_to_luaval<ax::TransitionMoveInL>(tolua_S, "ax.TransitionMoveInL",(ax::TransitionMoveInL*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionMoveInL:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInL_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionMoveInL_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInL_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionMoveInL();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionMoveInL");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInL:TransitionMoveInL",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInL_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionMoveInL_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionMoveInL)");
    return 0;
}

int lua_register_ax_base_TransitionMoveInL(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionMoveInL");
    tolua_cclass(tolua_S,"TransitionMoveInL","ax.TransitionMoveInL","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionMoveInL");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionMoveInL_constructor);
        tolua_function(tolua_S,"action",lua_ax_base_TransitionMoveInL_action);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionMoveInL_easeActionWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionMoveInL_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionMoveInL).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionMoveInL";
    g_typeCast[typeName] = "ax.TransitionMoveInL";
    return 1;
}

int lua_ax_base_TransitionMoveInR_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionMoveInR",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionMoveInR:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionMoveInR:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInR_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionMoveInR::create(arg0, arg1);
        object_to_luaval<ax::TransitionMoveInR>(tolua_S, "ax.TransitionMoveInR",(ax::TransitionMoveInR*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionMoveInR:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInR_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionMoveInR_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInR* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInR_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionMoveInR();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionMoveInR");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInR:TransitionMoveInR",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInR_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionMoveInR_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionMoveInR)");
    return 0;
}

int lua_register_ax_base_TransitionMoveInR(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionMoveInR");
    tolua_cclass(tolua_S,"TransitionMoveInR","ax.TransitionMoveInR","ax.TransitionMoveInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionMoveInR");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionMoveInR_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionMoveInR_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionMoveInR).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionMoveInR";
    g_typeCast[typeName] = "ax.TransitionMoveInR";
    return 1;
}

int lua_ax_base_TransitionMoveInT_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionMoveInT",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionMoveInT:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionMoveInT:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInT_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionMoveInT::create(arg0, arg1);
        object_to_luaval<ax::TransitionMoveInT>(tolua_S, "ax.TransitionMoveInT",(ax::TransitionMoveInT*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionMoveInT:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInT_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionMoveInT_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInT* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInT_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionMoveInT();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionMoveInT");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInT:TransitionMoveInT",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInT_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionMoveInT_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionMoveInT)");
    return 0;
}

int lua_register_ax_base_TransitionMoveInT(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionMoveInT");
    tolua_cclass(tolua_S,"TransitionMoveInT","ax.TransitionMoveInT","ax.TransitionMoveInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionMoveInT");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionMoveInT_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionMoveInT_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionMoveInT).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionMoveInT";
    g_typeCast[typeName] = "ax.TransitionMoveInT";
    return 1;
}

int lua_ax_base_TransitionMoveInB_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionMoveInB",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionMoveInB:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionMoveInB:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInB_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionMoveInB::create(arg0, arg1);
        object_to_luaval<ax::TransitionMoveInB>(tolua_S, "ax.TransitionMoveInB",(ax::TransitionMoveInB*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionMoveInB:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInB_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionMoveInB_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionMoveInB* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionMoveInB_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionMoveInB();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionMoveInB");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionMoveInB:TransitionMoveInB",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionMoveInB_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionMoveInB_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionMoveInB)");
    return 0;
}

int lua_register_ax_base_TransitionMoveInB(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionMoveInB");
    tolua_cclass(tolua_S,"TransitionMoveInB","ax.TransitionMoveInB","ax.TransitionMoveInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionMoveInB");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionMoveInB_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionMoveInB_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionMoveInB).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionMoveInB";
    g_typeCast[typeName] = "ax.TransitionMoveInB";
    return 1;
}

int lua_ax_base_TransitionSlideInL_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionSlideInL",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionSlideInL*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionSlideInL_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionSlideInL:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInL_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInL:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInL_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionSlideInL_action(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionSlideInL",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionSlideInL*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionSlideInL_action'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInL_action'", nullptr);
            return 0;
        }
        auto&& ret = cobj->action();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInL:action",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInL_action'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionSlideInL_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSlideInL",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSlideInL:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSlideInL:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInL_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSlideInL::create(arg0, arg1);
        object_to_luaval<ax::TransitionSlideInL>(tolua_S, "ax.TransitionSlideInL",(ax::TransitionSlideInL*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSlideInL:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInL_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSlideInL_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInL_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSlideInL();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSlideInL");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInL:TransitionSlideInL",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInL_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSlideInL_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSlideInL)");
    return 0;
}

int lua_register_ax_base_TransitionSlideInL(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSlideInL");
    tolua_cclass(tolua_S,"TransitionSlideInL","ax.TransitionSlideInL","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSlideInL");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSlideInL_constructor);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionSlideInL_easeActionWithAction);
        tolua_function(tolua_S,"action",lua_ax_base_TransitionSlideInL_action);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSlideInL_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSlideInL).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSlideInL";
    g_typeCast[typeName] = "ax.TransitionSlideInL";
    return 1;
}

int lua_ax_base_TransitionSlideInR_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSlideInR",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSlideInR:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSlideInR:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInR_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSlideInR::create(arg0, arg1);
        object_to_luaval<ax::TransitionSlideInR>(tolua_S, "ax.TransitionSlideInR",(ax::TransitionSlideInR*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSlideInR:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInR_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSlideInR_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInR* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInR_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSlideInR();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSlideInR");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInR:TransitionSlideInR",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInR_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSlideInR_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSlideInR)");
    return 0;
}

int lua_register_ax_base_TransitionSlideInR(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSlideInR");
    tolua_cclass(tolua_S,"TransitionSlideInR","ax.TransitionSlideInR","ax.TransitionSlideInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSlideInR");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSlideInR_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSlideInR_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSlideInR).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSlideInR";
    g_typeCast[typeName] = "ax.TransitionSlideInR";
    return 1;
}

int lua_ax_base_TransitionSlideInB_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSlideInB",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSlideInB:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSlideInB:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInB_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSlideInB::create(arg0, arg1);
        object_to_luaval<ax::TransitionSlideInB>(tolua_S, "ax.TransitionSlideInB",(ax::TransitionSlideInB*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSlideInB:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInB_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSlideInB_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInB* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInB_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSlideInB();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSlideInB");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInB:TransitionSlideInB",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInB_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSlideInB_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSlideInB)");
    return 0;
}

int lua_register_ax_base_TransitionSlideInB(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSlideInB");
    tolua_cclass(tolua_S,"TransitionSlideInB","ax.TransitionSlideInB","ax.TransitionSlideInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSlideInB");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSlideInB_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSlideInB_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSlideInB).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSlideInB";
    g_typeCast[typeName] = "ax.TransitionSlideInB";
    return 1;
}

int lua_ax_base_TransitionSlideInT_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSlideInT",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSlideInT:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSlideInT:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInT_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSlideInT::create(arg0, arg1);
        object_to_luaval<ax::TransitionSlideInT>(tolua_S, "ax.TransitionSlideInT",(ax::TransitionSlideInT*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSlideInT:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInT_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSlideInT_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSlideInT* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSlideInT_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSlideInT();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSlideInT");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSlideInT:TransitionSlideInT",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSlideInT_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSlideInT_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSlideInT)");
    return 0;
}

int lua_register_ax_base_TransitionSlideInT(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSlideInT");
    tolua_cclass(tolua_S,"TransitionSlideInT","ax.TransitionSlideInT","ax.TransitionSlideInL",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSlideInT");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSlideInT_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSlideInT_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSlideInT).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSlideInT";
    g_typeCast[typeName] = "ax.TransitionSlideInT";
    return 1;
}

int lua_ax_base_TransitionShrinkGrow_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionShrinkGrow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionShrinkGrow",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionShrinkGrow*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionShrinkGrow_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionShrinkGrow:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionShrinkGrow_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionShrinkGrow:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionShrinkGrow_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionShrinkGrow_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionShrinkGrow",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionShrinkGrow:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionShrinkGrow:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionShrinkGrow_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionShrinkGrow::create(arg0, arg1);
        object_to_luaval<ax::TransitionShrinkGrow>(tolua_S, "ax.TransitionShrinkGrow",(ax::TransitionShrinkGrow*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionShrinkGrow:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionShrinkGrow_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionShrinkGrow_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionShrinkGrow* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionShrinkGrow_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionShrinkGrow();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionShrinkGrow");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionShrinkGrow:TransitionShrinkGrow",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionShrinkGrow_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionShrinkGrow_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionShrinkGrow)");
    return 0;
}

int lua_register_ax_base_TransitionShrinkGrow(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionShrinkGrow");
    tolua_cclass(tolua_S,"TransitionShrinkGrow","ax.TransitionShrinkGrow","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionShrinkGrow");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionShrinkGrow_constructor);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionShrinkGrow_easeActionWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionShrinkGrow_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionShrinkGrow).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionShrinkGrow";
    g_typeCast[typeName] = "ax.TransitionShrinkGrow";
    return 1;
}

int lua_ax_base_TransitionFlipX_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFlipX",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipX:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipX:create");
            if (!ok) { break; }
            ax::TransitionFlipX* ret = ax::TransitionFlipX::create(arg0, arg1);
            object_to_luaval<ax::TransitionFlipX>(tolua_S, "ax.TransitionFlipX",(ax::TransitionFlipX*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipX:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipX:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionFlipX:create");
            if (!ok) { break; }
            ax::TransitionFlipX* ret = ax::TransitionFlipX::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionFlipX>(tolua_S, "ax.TransitionFlipX",(ax::TransitionFlipX*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionFlipX:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipX_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFlipX_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFlipX* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFlipX_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFlipX();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFlipX");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFlipX:TransitionFlipX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipX_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFlipX_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFlipX)");
    return 0;
}

int lua_register_ax_base_TransitionFlipX(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFlipX");
    tolua_cclass(tolua_S,"TransitionFlipX","ax.TransitionFlipX","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFlipX");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFlipX_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFlipX_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFlipX).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFlipX";
    g_typeCast[typeName] = "ax.TransitionFlipX";
    return 1;
}

int lua_ax_base_TransitionFlipY_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFlipY",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipY:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipY:create");
            if (!ok) { break; }
            ax::TransitionFlipY* ret = ax::TransitionFlipY::create(arg0, arg1);
            object_to_luaval<ax::TransitionFlipY>(tolua_S, "ax.TransitionFlipY",(ax::TransitionFlipY*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipY:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipY:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionFlipY:create");
            if (!ok) { break; }
            ax::TransitionFlipY* ret = ax::TransitionFlipY::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionFlipY>(tolua_S, "ax.TransitionFlipY",(ax::TransitionFlipY*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionFlipY:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipY_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFlipY_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFlipY* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFlipY_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFlipY();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFlipY");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFlipY:TransitionFlipY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipY_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFlipY_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFlipY)");
    return 0;
}

int lua_register_ax_base_TransitionFlipY(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFlipY");
    tolua_cclass(tolua_S,"TransitionFlipY","ax.TransitionFlipY","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFlipY");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFlipY_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFlipY_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFlipY).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFlipY";
    g_typeCast[typeName] = "ax.TransitionFlipY";
    return 1;
}

int lua_ax_base_TransitionFlipAngular_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFlipAngular",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipAngular:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionFlipAngular* ret = ax::TransitionFlipAngular::create(arg0, arg1);
            object_to_luaval<ax::TransitionFlipAngular>(tolua_S, "ax.TransitionFlipAngular",(ax::TransitionFlipAngular*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFlipAngular:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionFlipAngular* ret = ax::TransitionFlipAngular::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionFlipAngular>(tolua_S, "ax.TransitionFlipAngular",(ax::TransitionFlipAngular*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionFlipAngular:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipAngular_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFlipAngular_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFlipAngular* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFlipAngular_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFlipAngular();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFlipAngular");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFlipAngular:TransitionFlipAngular",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFlipAngular_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFlipAngular_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFlipAngular)");
    return 0;
}

int lua_register_ax_base_TransitionFlipAngular(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFlipAngular");
    tolua_cclass(tolua_S,"TransitionFlipAngular","ax.TransitionFlipAngular","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFlipAngular");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFlipAngular_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFlipAngular_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFlipAngular).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFlipAngular";
    g_typeCast[typeName] = "ax.TransitionFlipAngular";
    return 1;
}

int lua_ax_base_TransitionZoomFlipX_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionZoomFlipX",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipX:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipX:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipX* ret = ax::TransitionZoomFlipX::create(arg0, arg1);
            object_to_luaval<ax::TransitionZoomFlipX>(tolua_S, "ax.TransitionZoomFlipX",(ax::TransitionZoomFlipX*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipX:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipX:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionZoomFlipX:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipX* ret = ax::TransitionZoomFlipX::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionZoomFlipX>(tolua_S, "ax.TransitionZoomFlipX",(ax::TransitionZoomFlipX*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionZoomFlipX:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipX_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionZoomFlipX_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionZoomFlipX* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionZoomFlipX_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionZoomFlipX();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionZoomFlipX");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionZoomFlipX:TransitionZoomFlipX",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipX_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionZoomFlipX_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionZoomFlipX)");
    return 0;
}

int lua_register_ax_base_TransitionZoomFlipX(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionZoomFlipX");
    tolua_cclass(tolua_S,"TransitionZoomFlipX","ax.TransitionZoomFlipX","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionZoomFlipX");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionZoomFlipX_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionZoomFlipX_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionZoomFlipX).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionZoomFlipX";
    g_typeCast[typeName] = "ax.TransitionZoomFlipX";
    return 1;
}

int lua_ax_base_TransitionZoomFlipY_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionZoomFlipY",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipY:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipY:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipY* ret = ax::TransitionZoomFlipY::create(arg0, arg1);
            object_to_luaval<ax::TransitionZoomFlipY>(tolua_S, "ax.TransitionZoomFlipY",(ax::TransitionZoomFlipY*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipY:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipY:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionZoomFlipY:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipY* ret = ax::TransitionZoomFlipY::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionZoomFlipY>(tolua_S, "ax.TransitionZoomFlipY",(ax::TransitionZoomFlipY*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionZoomFlipY:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipY_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionZoomFlipY_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionZoomFlipY* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionZoomFlipY_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionZoomFlipY();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionZoomFlipY");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionZoomFlipY:TransitionZoomFlipY",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipY_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionZoomFlipY_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionZoomFlipY)");
    return 0;
}

int lua_register_ax_base_TransitionZoomFlipY(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionZoomFlipY");
    tolua_cclass(tolua_S,"TransitionZoomFlipY","ax.TransitionZoomFlipY","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionZoomFlipY");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionZoomFlipY_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionZoomFlipY_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionZoomFlipY).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionZoomFlipY";
    g_typeCast[typeName] = "ax.TransitionZoomFlipY";
    return 1;
}

int lua_ax_base_TransitionZoomFlipAngular_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionZoomFlipAngular",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipAngular:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipAngular* ret = ax::TransitionZoomFlipAngular::create(arg0, arg1);
            object_to_luaval<ax::TransitionZoomFlipAngular>(tolua_S, "ax.TransitionZoomFlipAngular",(ax::TransitionZoomFlipAngular*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionZoomFlipAngular:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionZoomFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionScene::Orientation arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TransitionZoomFlipAngular:create");
            if (!ok) { break; }
            ax::TransitionZoomFlipAngular* ret = ax::TransitionZoomFlipAngular::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionZoomFlipAngular>(tolua_S, "ax.TransitionZoomFlipAngular",(ax::TransitionZoomFlipAngular*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionZoomFlipAngular:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipAngular_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionZoomFlipAngular_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionZoomFlipAngular* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionZoomFlipAngular_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionZoomFlipAngular();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionZoomFlipAngular");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionZoomFlipAngular:TransitionZoomFlipAngular",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionZoomFlipAngular_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionZoomFlipAngular_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionZoomFlipAngular)");
    return 0;
}

int lua_register_ax_base_TransitionZoomFlipAngular(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionZoomFlipAngular");
    tolua_cclass(tolua_S,"TransitionZoomFlipAngular","ax.TransitionZoomFlipAngular","ax.TransitionSceneOriented",nullptr);

    tolua_beginmodule(tolua_S,"TransitionZoomFlipAngular");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionZoomFlipAngular_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionZoomFlipAngular_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionZoomFlipAngular).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionZoomFlipAngular";
    g_typeCast[typeName] = "ax.TransitionZoomFlipAngular";
    return 1;
}

int lua_ax_base_TransitionFade_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFade* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionFade",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TransitionFade*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionFade_initWithDuration'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFade:initWithDuration");

            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFade:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFade:initWithDuration");

            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFade:initWithDuration");

            if (!ok) { break; }
            ax::Color3B arg2;
            ok &= luaval_to_color3b(tolua_S, 4, &arg2, "ax.TransitionFade:initWithDuration");

            if (!ok) { break; }
            bool ret = cobj->initWithDuration(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TransitionFade:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFade_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionFade_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFade",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFade:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFade:create");
            if (!ok) { break; }
            ax::TransitionFade* ret = ax::TransitionFade::create(arg0, arg1);
            object_to_luaval<ax::TransitionFade>(tolua_S, "ax.TransitionFade",(ax::TransitionFade*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFade:create");
            if (!ok) { break; }
            ax::Scene* arg1;
            ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFade:create");
            if (!ok) { break; }
            ax::Color3B arg2;
            ok &= luaval_to_color3b(tolua_S, 4, &arg2, "ax.TransitionFade:create");
            if (!ok) { break; }
            ax::TransitionFade* ret = ax::TransitionFade::create(arg0, arg1, arg2);
            object_to_luaval<ax::TransitionFade>(tolua_S, "ax.TransitionFade",(ax::TransitionFade*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TransitionFade:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFade_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFade_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFade* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFade_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFade();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFade");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFade:TransitionFade",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFade_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFade_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFade)");
    return 0;
}

int lua_register_ax_base_TransitionFade(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFade");
    tolua_cclass(tolua_S,"TransitionFade","ax.TransitionFade","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFade");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFade_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TransitionFade_initWithDuration);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFade_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFade).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFade";
    g_typeCast[typeName] = "ax.TransitionFade";
    return 1;
}

int lua_ax_base_TransitionCrossFade_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionCrossFade",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionCrossFade:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionCrossFade:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionCrossFade_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionCrossFade::create(arg0, arg1);
        object_to_luaval<ax::TransitionCrossFade>(tolua_S, "ax.TransitionCrossFade",(ax::TransitionCrossFade*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionCrossFade:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionCrossFade_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionCrossFade_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionCrossFade* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionCrossFade_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionCrossFade();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionCrossFade");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionCrossFade:TransitionCrossFade",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionCrossFade_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionCrossFade_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionCrossFade)");
    return 0;
}

int lua_register_ax_base_TransitionCrossFade(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionCrossFade");
    tolua_cclass(tolua_S,"TransitionCrossFade","ax.TransitionCrossFade","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionCrossFade");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionCrossFade_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionCrossFade_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionCrossFade).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionCrossFade";
    g_typeCast[typeName] = "ax.TransitionCrossFade";
    return 1;
}

int lua_ax_base_TransitionTurnOffTiles_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionTurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionTurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionTurnOffTiles*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionTurnOffTiles_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionTurnOffTiles:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionTurnOffTiles_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionTurnOffTiles:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionTurnOffTiles_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionTurnOffTiles_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionTurnOffTiles",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionTurnOffTiles:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionTurnOffTiles:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionTurnOffTiles_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionTurnOffTiles::create(arg0, arg1);
        object_to_luaval<ax::TransitionTurnOffTiles>(tolua_S, "ax.TransitionTurnOffTiles",(ax::TransitionTurnOffTiles*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionTurnOffTiles:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionTurnOffTiles_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionTurnOffTiles_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionTurnOffTiles* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionTurnOffTiles_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionTurnOffTiles();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionTurnOffTiles");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionTurnOffTiles:TransitionTurnOffTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionTurnOffTiles_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionTurnOffTiles_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionTurnOffTiles)");
    return 0;
}

int lua_register_ax_base_TransitionTurnOffTiles(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionTurnOffTiles");
    tolua_cclass(tolua_S,"TransitionTurnOffTiles","ax.TransitionTurnOffTiles","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionTurnOffTiles");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionTurnOffTiles_constructor);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionTurnOffTiles_easeActionWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionTurnOffTiles_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionTurnOffTiles).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionTurnOffTiles";
    g_typeCast[typeName] = "ax.TransitionTurnOffTiles";
    return 1;
}

int lua_ax_base_TransitionSplitCols_action(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSplitCols* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionSplitCols",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionSplitCols*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionSplitCols_action'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitCols_action'", nullptr);
            return 0;
        }
        auto&& ret = cobj->action();
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSplitCols:action",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitCols_action'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionSplitCols_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSplitCols* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionSplitCols",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionSplitCols*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionSplitCols_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionSplitCols:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitCols_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSplitCols:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitCols_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionSplitCols_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSplitCols",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSplitCols:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSplitCols:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitCols_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSplitCols::create(arg0, arg1);
        object_to_luaval<ax::TransitionSplitCols>(tolua_S, "ax.TransitionSplitCols",(ax::TransitionSplitCols*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSplitCols:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitCols_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSplitCols_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSplitCols* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitCols_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSplitCols();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSplitCols");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSplitCols:TransitionSplitCols",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitCols_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSplitCols_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSplitCols)");
    return 0;
}

int lua_register_ax_base_TransitionSplitCols(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSplitCols");
    tolua_cclass(tolua_S,"TransitionSplitCols","ax.TransitionSplitCols","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSplitCols");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSplitCols_constructor);
        tolua_function(tolua_S,"action",lua_ax_base_TransitionSplitCols_action);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionSplitCols_easeActionWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSplitCols_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSplitCols).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSplitCols";
    g_typeCast[typeName] = "ax.TransitionSplitCols";
    return 1;
}

int lua_ax_base_TransitionSplitRows_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionSplitRows",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionSplitRows:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionSplitRows:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitRows_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionSplitRows::create(arg0, arg1);
        object_to_luaval<ax::TransitionSplitRows>(tolua_S, "ax.TransitionSplitRows",(ax::TransitionSplitRows*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionSplitRows:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitRows_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionSplitRows_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionSplitRows* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionSplitRows_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionSplitRows();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionSplitRows");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionSplitRows:TransitionSplitRows",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionSplitRows_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionSplitRows_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionSplitRows)");
    return 0;
}

int lua_register_ax_base_TransitionSplitRows(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionSplitRows");
    tolua_cclass(tolua_S,"TransitionSplitRows","ax.TransitionSplitRows","ax.TransitionSplitCols",nullptr);

    tolua_beginmodule(tolua_S,"TransitionSplitRows");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionSplitRows_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionSplitRows_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionSplitRows).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionSplitRows";
    g_typeCast[typeName] = "ax.TransitionSplitRows";
    return 1;
}

int lua_ax_base_TransitionFadeTR_actionWithSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeTR* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionFadeTR",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionFadeTR*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionFadeTR_actionWithSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TransitionFadeTR:actionWithSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeTR_actionWithSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->actionWithSize(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeTR:actionWithSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeTR_actionWithSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionFadeTR_easeActionWithAction(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeTR* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionFadeTR",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionFadeTR*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionFadeTR_easeActionWithAction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ActionInterval* arg0;

        ok &= luaval_to_object<ax::ActionInterval>(tolua_S, 2, "ax.ActionInterval",&arg0, "ax.TransitionFadeTR:easeActionWithAction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeTR_easeActionWithAction'", nullptr);
            return 0;
        }
        auto&& ret = cobj->easeActionWithAction(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeTR:easeActionWithAction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeTR_easeActionWithAction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionFadeTR_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFadeTR",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFadeTR:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFadeTR:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeTR_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionFadeTR::create(arg0, arg1);
        object_to_luaval<ax::TransitionFadeTR>(tolua_S, "ax.TransitionFadeTR",(ax::TransitionFadeTR*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionFadeTR:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeTR_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFadeTR_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeTR* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeTR_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFadeTR();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFadeTR");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeTR:TransitionFadeTR",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeTR_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFadeTR_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFadeTR)");
    return 0;
}

int lua_register_ax_base_TransitionFadeTR(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFadeTR");
    tolua_cclass(tolua_S,"TransitionFadeTR","ax.TransitionFadeTR","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFadeTR");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFadeTR_constructor);
        tolua_function(tolua_S,"actionWithSize",lua_ax_base_TransitionFadeTR_actionWithSize);
        tolua_function(tolua_S,"easeActionWithAction",lua_ax_base_TransitionFadeTR_easeActionWithAction);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFadeTR_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFadeTR).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFadeTR";
    g_typeCast[typeName] = "ax.TransitionFadeTR";
    return 1;
}

int lua_ax_base_TransitionFadeBL_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFadeBL",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFadeBL:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFadeBL:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeBL_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionFadeBL::create(arg0, arg1);
        object_to_luaval<ax::TransitionFadeBL>(tolua_S, "ax.TransitionFadeBL",(ax::TransitionFadeBL*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionFadeBL:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeBL_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFadeBL_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeBL* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeBL_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFadeBL();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFadeBL");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeBL:TransitionFadeBL",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeBL_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFadeBL_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFadeBL)");
    return 0;
}

int lua_register_ax_base_TransitionFadeBL(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFadeBL");
    tolua_cclass(tolua_S,"TransitionFadeBL","ax.TransitionFadeBL","ax.TransitionFadeTR",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFadeBL");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFadeBL_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFadeBL_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFadeBL).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFadeBL";
    g_typeCast[typeName] = "ax.TransitionFadeBL";
    return 1;
}

int lua_ax_base_TransitionFadeUp_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFadeUp",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFadeUp:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFadeUp:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeUp_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionFadeUp::create(arg0, arg1);
        object_to_luaval<ax::TransitionFadeUp>(tolua_S, "ax.TransitionFadeUp",(ax::TransitionFadeUp*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionFadeUp:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeUp_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFadeUp_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeUp* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeUp_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFadeUp();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFadeUp");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeUp:TransitionFadeUp",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeUp_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFadeUp_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFadeUp)");
    return 0;
}

int lua_register_ax_base_TransitionFadeUp(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFadeUp");
    tolua_cclass(tolua_S,"TransitionFadeUp","ax.TransitionFadeUp","ax.TransitionFadeTR",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFadeUp");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFadeUp_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFadeUp_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFadeUp).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFadeUp";
    g_typeCast[typeName] = "ax.TransitionFadeUp";
    return 1;
}

int lua_ax_base_TransitionFadeDown_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionFadeDown",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionFadeDown:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionFadeDown:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeDown_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionFadeDown::create(arg0, arg1);
        object_to_luaval<ax::TransitionFadeDown>(tolua_S, "ax.TransitionFadeDown",(ax::TransitionFadeDown*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionFadeDown:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeDown_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionFadeDown_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionFadeDown* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionFadeDown_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionFadeDown();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionFadeDown");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionFadeDown:TransitionFadeDown",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionFadeDown_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionFadeDown_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionFadeDown)");
    return 0;
}

int lua_register_ax_base_TransitionFadeDown(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionFadeDown");
    tolua_cclass(tolua_S,"TransitionFadeDown","ax.TransitionFadeDown","ax.TransitionFadeTR",nullptr);

    tolua_beginmodule(tolua_S,"TransitionFadeDown");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionFadeDown_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionFadeDown_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionFadeDown).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionFadeDown";
    g_typeCast[typeName] = "ax.TransitionFadeDown";
    return 1;
}

int lua_ax_base_TransitionPageTurn_initWithDuration(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionPageTurn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionPageTurn",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionPageTurn*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionPageTurn_initWithDuration'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        double arg0;
        ax::Scene* arg1;
        bool arg2;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionPageTurn:initWithDuration");

        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionPageTurn:initWithDuration");

        ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.TransitionPageTurn:initWithDuration");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionPageTurn_initWithDuration'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithDuration(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionPageTurn:initWithDuration",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionPageTurn_initWithDuration'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionPageTurn_actionWithSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionPageTurn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TransitionPageTurn",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TransitionPageTurn*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TransitionPageTurn_actionWithSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TransitionPageTurn:actionWithSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionPageTurn_actionWithSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->actionWithSize(arg0);
        object_to_luaval<ax::ActionInterval>(tolua_S, "ax.ActionInterval",(ax::ActionInterval*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionPageTurn:actionWithSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionPageTurn_actionWithSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TransitionPageTurn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionPageTurn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        double arg0;
        ax::Scene* arg1;
        bool arg2;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionPageTurn:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionPageTurn:create");
        ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.TransitionPageTurn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionPageTurn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionPageTurn::create(arg0, arg1, arg2);
        object_to_luaval<ax::TransitionPageTurn>(tolua_S, "ax.TransitionPageTurn",(ax::TransitionPageTurn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionPageTurn:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionPageTurn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionPageTurn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionPageTurn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionPageTurn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionPageTurn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionPageTurn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionPageTurn:TransitionPageTurn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionPageTurn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionPageTurn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionPageTurn)");
    return 0;
}

int lua_register_ax_base_TransitionPageTurn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionPageTurn");
    tolua_cclass(tolua_S,"TransitionPageTurn","ax.TransitionPageTurn","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionPageTurn");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionPageTurn_constructor);
        tolua_function(tolua_S,"initWithDuration",lua_ax_base_TransitionPageTurn_initWithDuration);
        tolua_function(tolua_S,"actionWithSize",lua_ax_base_TransitionPageTurn_actionWithSize);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionPageTurn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionPageTurn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionPageTurn";
    g_typeCast[typeName] = "ax.TransitionPageTurn";
    return 1;
}

int lua_ax_base_TransitionProgress_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgress",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgress:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgress:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgress_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgress::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgress>(tolua_S, "ax.TransitionProgress",(ax::TransitionProgress*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgress:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgress_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgress_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgress* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgress_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgress();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgress");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgress:TransitionProgress",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgress_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgress_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgress)");
    return 0;
}

int lua_register_ax_base_TransitionProgress(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgress");
    tolua_cclass(tolua_S,"TransitionProgress","ax.TransitionProgress","ax.TransitionScene",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgress");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgress_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgress_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgress).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgress";
    g_typeCast[typeName] = "ax.TransitionProgress";
    return 1;
}

int lua_ax_base_TransitionProgressRadialCCW_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressRadialCCW",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressRadialCCW:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressRadialCCW:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressRadialCCW_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressRadialCCW::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressRadialCCW>(tolua_S, "ax.TransitionProgressRadialCCW",(ax::TransitionProgressRadialCCW*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressRadialCCW:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressRadialCCW_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressRadialCCW_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressRadialCCW* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressRadialCCW_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressRadialCCW();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressRadialCCW");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressRadialCCW:TransitionProgressRadialCCW",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressRadialCCW_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressRadialCCW_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressRadialCCW)");
    return 0;
}

int lua_register_ax_base_TransitionProgressRadialCCW(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressRadialCCW");
    tolua_cclass(tolua_S,"TransitionProgressRadialCCW","ax.TransitionProgressRadialCCW","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressRadialCCW");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressRadialCCW_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressRadialCCW_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressRadialCCW).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressRadialCCW";
    g_typeCast[typeName] = "ax.TransitionProgressRadialCCW";
    return 1;
}

int lua_ax_base_TransitionProgressRadialCW_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressRadialCW",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressRadialCW:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressRadialCW:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressRadialCW_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressRadialCW::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressRadialCW>(tolua_S, "ax.TransitionProgressRadialCW",(ax::TransitionProgressRadialCW*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressRadialCW:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressRadialCW_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressRadialCW_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressRadialCW* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressRadialCW_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressRadialCW();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressRadialCW");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressRadialCW:TransitionProgressRadialCW",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressRadialCW_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressRadialCW_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressRadialCW)");
    return 0;
}

int lua_register_ax_base_TransitionProgressRadialCW(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressRadialCW");
    tolua_cclass(tolua_S,"TransitionProgressRadialCW","ax.TransitionProgressRadialCW","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressRadialCW");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressRadialCW_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressRadialCW_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressRadialCW).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressRadialCW";
    g_typeCast[typeName] = "ax.TransitionProgressRadialCW";
    return 1;
}

int lua_ax_base_TransitionProgressHorizontal_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressHorizontal",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressHorizontal:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressHorizontal:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressHorizontal_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressHorizontal::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressHorizontal>(tolua_S, "ax.TransitionProgressHorizontal",(ax::TransitionProgressHorizontal*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressHorizontal:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressHorizontal_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressHorizontal_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressHorizontal* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressHorizontal_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressHorizontal();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressHorizontal");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressHorizontal:TransitionProgressHorizontal",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressHorizontal_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressHorizontal_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressHorizontal)");
    return 0;
}

int lua_register_ax_base_TransitionProgressHorizontal(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressHorizontal");
    tolua_cclass(tolua_S,"TransitionProgressHorizontal","ax.TransitionProgressHorizontal","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressHorizontal");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressHorizontal_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressHorizontal_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressHorizontal).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressHorizontal";
    g_typeCast[typeName] = "ax.TransitionProgressHorizontal";
    return 1;
}

int lua_ax_base_TransitionProgressVertical_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressVertical",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressVertical:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressVertical:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressVertical_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressVertical::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressVertical>(tolua_S, "ax.TransitionProgressVertical",(ax::TransitionProgressVertical*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressVertical:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressVertical_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressVertical_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressVertical* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressVertical_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressVertical();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressVertical");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressVertical:TransitionProgressVertical",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressVertical_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressVertical_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressVertical)");
    return 0;
}

int lua_register_ax_base_TransitionProgressVertical(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressVertical");
    tolua_cclass(tolua_S,"TransitionProgressVertical","ax.TransitionProgressVertical","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressVertical");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressVertical_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressVertical_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressVertical).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressVertical";
    g_typeCast[typeName] = "ax.TransitionProgressVertical";
    return 1;
}

int lua_ax_base_TransitionProgressInOut_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressInOut",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressInOut:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressInOut:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressInOut_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressInOut::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressInOut>(tolua_S, "ax.TransitionProgressInOut",(ax::TransitionProgressInOut*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressInOut:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressInOut_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressInOut_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressInOut* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressInOut_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressInOut();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressInOut");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressInOut:TransitionProgressInOut",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressInOut_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressInOut_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressInOut)");
    return 0;
}

int lua_register_ax_base_TransitionProgressInOut(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressInOut");
    tolua_cclass(tolua_S,"TransitionProgressInOut","ax.TransitionProgressInOut","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressInOut");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressInOut_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressInOut_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressInOut).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressInOut";
    g_typeCast[typeName] = "ax.TransitionProgressInOut";
    return 1;
}

int lua_ax_base_TransitionProgressOutIn_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TransitionProgressOutIn",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        double arg0;
        ax::Scene* arg1;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.TransitionProgressOutIn:create");
        ok &= luaval_to_object<ax::Scene>(tolua_S, 3, "ax.Scene",&arg1, "ax.TransitionProgressOutIn:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressOutIn_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TransitionProgressOutIn::create(arg0, arg1);
        object_to_luaval<ax::TransitionProgressOutIn>(tolua_S, "ax.TransitionProgressOutIn",(ax::TransitionProgressOutIn*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TransitionProgressOutIn:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressOutIn_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TransitionProgressOutIn_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TransitionProgressOutIn* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TransitionProgressOutIn_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TransitionProgressOutIn();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TransitionProgressOutIn");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TransitionProgressOutIn:TransitionProgressOutIn",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TransitionProgressOutIn_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TransitionProgressOutIn_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TransitionProgressOutIn)");
    return 0;
}

int lua_register_ax_base_TransitionProgressOutIn(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TransitionProgressOutIn");
    tolua_cclass(tolua_S,"TransitionProgressOutIn","ax.TransitionProgressOutIn","ax.TransitionProgress",nullptr);

    tolua_beginmodule(tolua_S,"TransitionProgressOutIn");
        tolua_function(tolua_S,"new",lua_ax_base_TransitionProgressOutIn_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_TransitionProgressOutIn_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TransitionProgressOutIn).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TransitionProgressOutIn";
    g_typeCast[typeName] = "ax.TransitionProgressOutIn";
    return 1;
}

int lua_ax_base_Camera_getCameraFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getCameraFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getCameraFlag'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getCameraFlag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getCameraFlag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getCameraFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setCameraFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setCameraFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::CameraFlag arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Camera:setCameraFlag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setCameraFlag'", nullptr);
            return 0;
        }
        cobj->setCameraFlag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setCameraFlag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setCameraFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_lookAt(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_lookAt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Camera:lookAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_lookAt'", nullptr);
            return 0;
        }
        cobj->lookAt(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Vec3 arg0;
        ax::Vec3 arg1;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Camera:lookAt");

        ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.Camera:lookAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_lookAt'", nullptr);
            return 0;
        }
        cobj->lookAt(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:lookAt",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_lookAt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getProjectionMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getProjectionMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getProjectionMatrix'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProjectionMatrix();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getProjectionMatrix",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getProjectionMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getViewMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getViewMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getViewMatrix'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getViewMatrix();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getViewMatrix",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getViewMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getViewProjectionMatrix(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getViewProjectionMatrix'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getViewProjectionMatrix'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getViewProjectionMatrix();
        mat4_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getViewProjectionMatrix",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getViewProjectionMatrix'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_project(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_project'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Camera:project");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_project'", nullptr);
            return 0;
        }
        auto&& ret = cobj->project(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:project",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_project'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_projectGL(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_projectGL'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.Camera:projectGL");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_projectGL'", nullptr);
            return 0;
        }
        auto&& ret = cobj->projectGL(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:projectGL",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_projectGL'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_isVisibleInFrustum(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_isVisibleInFrustum'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        const ax::AABB* arg0;

        ok &= luaval_to_object<const ax::AABB>(tolua_S, 2, "ax.AABB",&arg0, "ax.Camera:isVisibleInFrustum");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_isVisibleInFrustum'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isVisibleInFrustum(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:isVisibleInFrustum",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_isVisibleInFrustum'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getDepthInView(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getDepthInView'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Mat4 arg0;

        ok &= luaval_to_mat4(tolua_S, 2, &arg0, "ax.Camera:getDepthInView");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getDepthInView'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDepthInView(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getDepthInView",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getDepthInView'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int32_t arg0;

        ok &= luaval_to_int32(tolua_S, 2,&arg0, "ax.Camera:setDepth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setDepth'", nullptr);
            return 0;
        }
        cobj->setDepth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setDepth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getDepth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDepth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getDepth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getRenderOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getRenderOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getRenderOrder'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderOrder();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getRenderOrder",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getRenderOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getFOV(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getFOV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getFOV'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFOV();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getFOV",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getFOV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setFOV(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setFOV'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:setFOV");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setFOV'", nullptr);
            return 0;
        }
        cobj->setFOV(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setFOV",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setFOV'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getFarPlane(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getFarPlane'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getFarPlane'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getFarPlane();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getFarPlane",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getFarPlane'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setFarPlane(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setFarPlane'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:setFarPlane");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setFarPlane'", nullptr);
            return 0;
        }
        cobj->setFarPlane(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setFarPlane",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setFarPlane'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getNearPlane(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getNearPlane'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getNearPlane'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNearPlane();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getNearPlane",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getNearPlane'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setNearPlane(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setNearPlane'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:setNearPlane");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setNearPlane'", nullptr);
            return 0;
        }
        cobj->setNearPlane(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setNearPlane",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setNearPlane'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getZoom(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getZoom'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getZoom'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getZoom();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getZoom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getZoom'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setZoom(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setZoom'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:setZoom");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setZoom'", nullptr);
            return 0;
        }
        cobj->setZoom(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setZoom",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setZoom'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_applyZoom(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_applyZoom'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_applyZoom'", nullptr);
            return 0;
        }
        cobj->applyZoom();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:applyZoom",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_applyZoom'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_clearBackground(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_clearBackground'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_clearBackground'", nullptr);
            return 0;
        }
        cobj->clearBackground();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:clearBackground",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_clearBackground'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_apply(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_apply'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_apply'", nullptr);
            return 0;
        }
        cobj->apply();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:apply",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_apply'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_isViewProjectionUpdated(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_isViewProjectionUpdated'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_isViewProjectionUpdated'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isViewProjectionUpdated();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:isViewProjectionUpdated",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_isViewProjectionUpdated'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setBackgroundBrush(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setBackgroundBrush'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::CameraBackgroundBrush* arg0;

        ok &= luaval_to_object<ax::CameraBackgroundBrush>(tolua_S, 2, "ax.CameraBackgroundBrush",&arg0, "ax.Camera:setBackgroundBrush");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setBackgroundBrush'", nullptr);
            return 0;
        }
        cobj->setBackgroundBrush(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setBackgroundBrush",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setBackgroundBrush'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_getBackgroundBrush(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_getBackgroundBrush'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getBackgroundBrush'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBackgroundBrush();
        object_to_luaval<ax::CameraBackgroundBrush>(tolua_S, "ax.CameraBackgroundBrush",(ax::CameraBackgroundBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:getBackgroundBrush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getBackgroundBrush'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_isBrushValid(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_isBrushValid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_isBrushValid'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isBrushValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:isBrushValid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_isBrushValid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setScene(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setScene'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Scene* arg0;

        ok &= luaval_to_object<ax::Scene>(tolua_S, 2, "ax.Scene",&arg0, "ax.Camera:setScene");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setScene'", nullptr);
            return 0;
        }
        cobj->setScene(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setScene",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setScene'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_setAdditionalProjection(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_setAdditionalProjection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Mat4 arg0;

        ok &= luaval_to_mat4(tolua_S, 2, &arg0, "ax.Camera:setAdditionalProjection");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setAdditionalProjection'", nullptr);
            return 0;
        }
        cobj->setAdditionalProjection(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:setAdditionalProjection",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setAdditionalProjection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_initDefault(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_initDefault'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_initDefault'", nullptr);
            return 0;
        }
        cobj->initDefault();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:initDefault",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_initDefault'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_initPerspective(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_initPerspective'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:initPerspective");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Camera:initPerspective");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Camera:initPerspective");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Camera:initPerspective");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_initPerspective'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initPerspective(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:initPerspective",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_initPerspective'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_initOrthographic(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_initOrthographic'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:initOrthographic");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Camera:initOrthographic");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Camera:initOrthographic");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Camera:initOrthographic");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_initOrthographic'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initOrthographic(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:initOrthographic",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_initOrthographic'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_applyViewport(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Camera*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Camera_applyViewport'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_applyViewport'", nullptr);
            return 0;
        }
        cobj->applyViewport();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:applyViewport",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_applyViewport'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Camera_createPerspective(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:createPerspective");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Camera:createPerspective");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Camera:createPerspective");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Camera:createPerspective");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_createPerspective'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::createPerspective(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:createPerspective",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_createPerspective'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_createOrthographic(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Camera:createOrthographic");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Camera:createOrthographic");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Camera:createOrthographic");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Camera:createOrthographic");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_createOrthographic'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::createOrthographic(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:createOrthographic",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_createOrthographic'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::create();
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_getVisitingCamera(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getVisitingCamera'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::getVisitingCamera();
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:getVisitingCamera",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getVisitingCamera'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_getDefaultViewport(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getDefaultViewport'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::getDefaultViewport();
        #pragma warning NO CONVERSION FROM NATIVE FOR RectI;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:getDefaultViewport",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getDefaultViewport'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_setDefaultViewport(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::RectI arg0;
        #pragma warning NO CONVERSION TO NATIVE FOR RectI
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_setDefaultViewport'", nullptr);
            return 0;
        }
        ax::Camera::setDefaultViewport(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:setDefaultViewport",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_setDefaultViewport'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_getDefaultCamera(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Camera",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_getDefaultCamera'", nullptr);
            return 0;
        }
        auto&& ret = ax::Camera::getDefaultCamera();
        object_to_luaval<ax::Camera>(tolua_S, "ax.Camera",(ax::Camera*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Camera:getDefaultCamera",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_getDefaultCamera'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Camera_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Camera* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Camera_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Camera();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Camera");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Camera:Camera",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Camera_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Camera_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Camera)");
    return 0;
}

int lua_register_ax_base_Camera(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Camera");
    tolua_cclass(tolua_S,"Camera","ax.Camera","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"Camera");
        tolua_function(tolua_S,"new",lua_ax_base_Camera_constructor);
        tolua_function(tolua_S,"getCameraFlag",lua_ax_base_Camera_getCameraFlag);
        tolua_function(tolua_S,"setCameraFlag",lua_ax_base_Camera_setCameraFlag);
        tolua_function(tolua_S,"lookAt",lua_ax_base_Camera_lookAt);
        tolua_function(tolua_S,"getProjectionMatrix",lua_ax_base_Camera_getProjectionMatrix);
        tolua_function(tolua_S,"getViewMatrix",lua_ax_base_Camera_getViewMatrix);
        tolua_function(tolua_S,"getViewProjectionMatrix",lua_ax_base_Camera_getViewProjectionMatrix);
        tolua_function(tolua_S,"project",lua_ax_base_Camera_project);
        tolua_function(tolua_S,"projectGL",lua_ax_base_Camera_projectGL);
        tolua_function(tolua_S,"isVisibleInFrustum",lua_ax_base_Camera_isVisibleInFrustum);
        tolua_function(tolua_S,"getDepthInView",lua_ax_base_Camera_getDepthInView);
        tolua_function(tolua_S,"setDepth",lua_ax_base_Camera_setDepth);
        tolua_function(tolua_S,"getDepth",lua_ax_base_Camera_getDepth);
        tolua_function(tolua_S,"getRenderOrder",lua_ax_base_Camera_getRenderOrder);
        tolua_function(tolua_S,"getFOV",lua_ax_base_Camera_getFOV);
        tolua_function(tolua_S,"setFOV",lua_ax_base_Camera_setFOV);
        tolua_function(tolua_S,"getFarPlane",lua_ax_base_Camera_getFarPlane);
        tolua_function(tolua_S,"setFarPlane",lua_ax_base_Camera_setFarPlane);
        tolua_function(tolua_S,"getNearPlane",lua_ax_base_Camera_getNearPlane);
        tolua_function(tolua_S,"setNearPlane",lua_ax_base_Camera_setNearPlane);
        tolua_function(tolua_S,"getZoom",lua_ax_base_Camera_getZoom);
        tolua_function(tolua_S,"setZoom",lua_ax_base_Camera_setZoom);
        tolua_function(tolua_S,"applyZoom",lua_ax_base_Camera_applyZoom);
        tolua_function(tolua_S,"clearBackground",lua_ax_base_Camera_clearBackground);
        tolua_function(tolua_S,"apply",lua_ax_base_Camera_apply);
        tolua_function(tolua_S,"isViewProjectionUpdated",lua_ax_base_Camera_isViewProjectionUpdated);
        tolua_function(tolua_S,"setBackgroundBrush",lua_ax_base_Camera_setBackgroundBrush);
        tolua_function(tolua_S,"getBackgroundBrush",lua_ax_base_Camera_getBackgroundBrush);
        tolua_function(tolua_S,"isBrushValid",lua_ax_base_Camera_isBrushValid);
        tolua_function(tolua_S,"setScene",lua_ax_base_Camera_setScene);
        tolua_function(tolua_S,"setAdditionalProjection",lua_ax_base_Camera_setAdditionalProjection);
        tolua_function(tolua_S,"initDefault",lua_ax_base_Camera_initDefault);
        tolua_function(tolua_S,"initPerspective",lua_ax_base_Camera_initPerspective);
        tolua_function(tolua_S,"initOrthographic",lua_ax_base_Camera_initOrthographic);
        tolua_function(tolua_S,"applyViewport",lua_ax_base_Camera_applyViewport);
        tolua_function(tolua_S,"createPerspective", lua_ax_base_Camera_createPerspective);
        tolua_function(tolua_S,"createOrthographic", lua_ax_base_Camera_createOrthographic);
        tolua_function(tolua_S,"create", lua_ax_base_Camera_create);
        tolua_function(tolua_S,"getVisitingCamera", lua_ax_base_Camera_getVisitingCamera);
        tolua_function(tolua_S,"getDefaultViewport", lua_ax_base_Camera_getDefaultViewport);
        tolua_function(tolua_S,"setDefaultViewport", lua_ax_base_Camera_setDefaultViewport);
        tolua_function(tolua_S,"getDefaultCamera", lua_ax_base_Camera_getDefaultCamera);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Camera).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Camera";
    g_typeCast[typeName] = "ax.Camera";
    return 1;
}

int lua_ax_base_CameraBackgroundBrush_getBrushType(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundBrush_getBrushType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_getBrushType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getBrushType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundBrush:getBrushType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_getBrushType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundBrush_drawBackground(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundBrush_drawBackground'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Camera* arg0;

        ok &= luaval_to_object<ax::Camera>(tolua_S, 2, "ax.Camera",&arg0, "ax.CameraBackgroundBrush:drawBackground");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_drawBackground'", nullptr);
            return 0;
        }
        cobj->drawBackground(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundBrush:drawBackground",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_drawBackground'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundBrush_isValid(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundBrush_isValid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_isValid'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isValid();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundBrush:isValid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_isValid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundBrush_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundBrush_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundBrush:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundBrush_createNoneBrush(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_createNoneBrush'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundBrush::createNoneBrush();
        object_to_luaval<ax::CameraBackgroundBrush>(tolua_S, "ax.CameraBackgroundBrush",(ax::CameraBackgroundBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundBrush:createNoneBrush",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_createNoneBrush'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundBrush_createDepthBrush(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_createDepthBrush'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundBrush::createDepthBrush();
        object_to_luaval<ax::CameraBackgroundDepthBrush>(tolua_S, "ax.CameraBackgroundDepthBrush",(ax::CameraBackgroundDepthBrush*)ret);
        return 1;
    }
    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CameraBackgroundBrush:createDepthBrush");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_createDepthBrush'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundBrush::createDepthBrush(arg0);
        object_to_luaval<ax::CameraBackgroundDepthBrush>(tolua_S, "ax.CameraBackgroundDepthBrush",(ax::CameraBackgroundDepthBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundBrush:createDepthBrush",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_createDepthBrush'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundBrush_createColorBrush(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Color4F arg0;
        double arg1;
        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.CameraBackgroundBrush:createColorBrush");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.CameraBackgroundBrush:createColorBrush");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_createColorBrush'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundBrush::createColorBrush(arg0, arg1);
        object_to_luaval<ax::CameraBackgroundColorBrush>(tolua_S, "ax.CameraBackgroundColorBrush",(ax::CameraBackgroundColorBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundBrush:createColorBrush",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_createColorBrush'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundBrush_createSkyboxBrush(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 6)
    {
        std::string_view arg0;
        std::string_view arg1;
        std::string_view arg2;
        std::string_view arg3;
        std::string_view arg4;
        std::string_view arg5;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.CameraBackgroundBrush:createSkyboxBrush");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.CameraBackgroundBrush:createSkyboxBrush");
        ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.CameraBackgroundBrush:createSkyboxBrush");
        ok &= luaval_to_std_string_view(tolua_S, 5,&arg3, "ax.CameraBackgroundBrush:createSkyboxBrush");
        ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.CameraBackgroundBrush:createSkyboxBrush");
        ok &= luaval_to_std_string_view(tolua_S, 7,&arg5, "ax.CameraBackgroundBrush:createSkyboxBrush");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_createSkyboxBrush'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundBrush::createSkyboxBrush(arg0, arg1, arg2, arg3, arg4, arg5);
        object_to_luaval<ax::CameraBackgroundSkyBoxBrush>(tolua_S, "ax.CameraBackgroundSkyBoxBrush",(ax::CameraBackgroundSkyBoxBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundBrush:createSkyboxBrush",argc, 6);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_createSkyboxBrush'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundBrush_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundBrush_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CameraBackgroundBrush();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CameraBackgroundBrush");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundBrush:CameraBackgroundBrush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundBrush_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CameraBackgroundBrush_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CameraBackgroundBrush)");
    return 0;
}

int lua_register_ax_base_CameraBackgroundBrush(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CameraBackgroundBrush");
    tolua_cclass(tolua_S,"CameraBackgroundBrush","ax.CameraBackgroundBrush","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"CameraBackgroundBrush");
        tolua_function(tolua_S,"new",lua_ax_base_CameraBackgroundBrush_constructor);
        tolua_function(tolua_S,"getBrushType",lua_ax_base_CameraBackgroundBrush_getBrushType);
        tolua_function(tolua_S,"drawBackground",lua_ax_base_CameraBackgroundBrush_drawBackground);
        tolua_function(tolua_S,"isValid",lua_ax_base_CameraBackgroundBrush_isValid);
        tolua_function(tolua_S,"init",lua_ax_base_CameraBackgroundBrush_init);
        tolua_function(tolua_S,"createNoneBrush", lua_ax_base_CameraBackgroundBrush_createNoneBrush);
        tolua_function(tolua_S,"createDepthBrush", lua_ax_base_CameraBackgroundBrush_createDepthBrush);
        tolua_function(tolua_S,"createColorBrush", lua_ax_base_CameraBackgroundBrush_createColorBrush);
        tolua_function(tolua_S,"createSkyboxBrush", lua_ax_base_CameraBackgroundBrush_createSkyboxBrush);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CameraBackgroundBrush).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CameraBackgroundBrush";
    g_typeCast[typeName] = "ax.CameraBackgroundBrush";
    return 1;
}

int lua_ax_base_CameraBackgroundDepthBrush_setDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundDepthBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundDepthBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundDepthBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundDepthBrush_setDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CameraBackgroundDepthBrush:setDepth");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundDepthBrush_setDepth'", nullptr);
            return 0;
        }
        cobj->setDepth(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundDepthBrush:setDepth",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundDepthBrush_setDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundDepthBrush_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundDepthBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.CameraBackgroundDepthBrush:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundDepthBrush_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundDepthBrush::create(arg0);
        object_to_luaval<ax::CameraBackgroundDepthBrush>(tolua_S, "ax.CameraBackgroundDepthBrush",(ax::CameraBackgroundDepthBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundDepthBrush:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundDepthBrush_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundDepthBrush_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundDepthBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundDepthBrush_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CameraBackgroundDepthBrush();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CameraBackgroundDepthBrush");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundDepthBrush:CameraBackgroundDepthBrush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundDepthBrush_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CameraBackgroundDepthBrush_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CameraBackgroundDepthBrush)");
    return 0;
}

int lua_register_ax_base_CameraBackgroundDepthBrush(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CameraBackgroundDepthBrush");
    tolua_cclass(tolua_S,"CameraBackgroundDepthBrush","ax.CameraBackgroundDepthBrush","ax.CameraBackgroundBrush",nullptr);

    tolua_beginmodule(tolua_S,"CameraBackgroundDepthBrush");
        tolua_function(tolua_S,"new",lua_ax_base_CameraBackgroundDepthBrush_constructor);
        tolua_function(tolua_S,"setDepth",lua_ax_base_CameraBackgroundDepthBrush_setDepth);
        tolua_function(tolua_S,"create", lua_ax_base_CameraBackgroundDepthBrush_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CameraBackgroundDepthBrush).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CameraBackgroundDepthBrush";
    g_typeCast[typeName] = "ax.CameraBackgroundDepthBrush";
    return 1;
}

int lua_ax_base_CameraBackgroundColorBrush_setColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundColorBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundColorBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundColorBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundColorBrush_setColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color4F arg0;

        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.CameraBackgroundColorBrush:setColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundColorBrush_setColor'", nullptr);
            return 0;
        }
        cobj->setColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundColorBrush:setColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundColorBrush_setColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundColorBrush_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundColorBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Color4F arg0;
        double arg1;
        ok &=luaval_to_color4f(tolua_S, 2, &arg0, "ax.CameraBackgroundColorBrush:create");
        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.CameraBackgroundColorBrush:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundColorBrush_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::CameraBackgroundColorBrush::create(arg0, arg1);
        object_to_luaval<ax::CameraBackgroundColorBrush>(tolua_S, "ax.CameraBackgroundColorBrush",(ax::CameraBackgroundColorBrush*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.CameraBackgroundColorBrush:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundColorBrush_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundColorBrush_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundColorBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundColorBrush_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CameraBackgroundColorBrush();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CameraBackgroundColorBrush");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundColorBrush:CameraBackgroundColorBrush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundColorBrush_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CameraBackgroundColorBrush_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CameraBackgroundColorBrush)");
    return 0;
}

int lua_register_ax_base_CameraBackgroundColorBrush(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CameraBackgroundColorBrush");
    tolua_cclass(tolua_S,"CameraBackgroundColorBrush","ax.CameraBackgroundColorBrush","ax.CameraBackgroundDepthBrush",nullptr);

    tolua_beginmodule(tolua_S,"CameraBackgroundColorBrush");
        tolua_function(tolua_S,"new",lua_ax_base_CameraBackgroundColorBrush_constructor);
        tolua_function(tolua_S,"setColor",lua_ax_base_CameraBackgroundColorBrush_setColor);
        tolua_function(tolua_S,"create", lua_ax_base_CameraBackgroundColorBrush_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CameraBackgroundColorBrush).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CameraBackgroundColorBrush";
    g_typeCast[typeName] = "ax.CameraBackgroundColorBrush";
    return 1;
}

int lua_ax_base_CameraBackgroundSkyBoxBrush_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundSkyBoxBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextureCube* arg0;

        ok &= luaval_to_object<ax::TextureCube>(tolua_S, 2, "ax.TextureCube",&arg0, "ax.CameraBackgroundSkyBoxBrush:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundSkyBoxBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::TextureCube>(tolua_S, "ax.TextureCube",(ax::TextureCube*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_isActived(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundSkyBoxBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_isActived'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_isActived'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isActived();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:isActived",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_isActived'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_setActived(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundSkyBoxBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setActived'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.CameraBackgroundSkyBoxBrush:setActived");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setActived'", nullptr);
            return 0;
        }
        cobj->setActived(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:setActived",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setActived'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_setTextureValid(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::CameraBackgroundSkyBoxBrush*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTextureValid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.CameraBackgroundSkyBoxBrush:setTextureValid");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTextureValid'", nullptr);
            return 0;
        }
        cobj->setTextureValid(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:setTextureValid",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_setTextureValid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.CameraBackgroundSkyBoxBrush",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 0)
        {
            ax::CameraBackgroundSkyBoxBrush* ret = ax::CameraBackgroundSkyBoxBrush::create();
            object_to_luaval<ax::CameraBackgroundSkyBoxBrush>(tolua_S, "ax.CameraBackgroundSkyBoxBrush",(ax::CameraBackgroundSkyBoxBrush*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 6)
        {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            std::string_view arg2;
            ok &= luaval_to_std_string_view(tolua_S, 4,&arg2, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            std::string_view arg3;
            ok &= luaval_to_std_string_view(tolua_S, 5,&arg3, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            std::string_view arg5;
            ok &= luaval_to_std_string_view(tolua_S, 7,&arg5, "ax.CameraBackgroundSkyBoxBrush:create");
            if (!ok) { break; }
            ax::CameraBackgroundSkyBoxBrush* ret = ax::CameraBackgroundSkyBoxBrush::create(arg0, arg1, arg2, arg3, arg4, arg5);
            object_to_luaval<ax::CameraBackgroundSkyBoxBrush>(tolua_S, "ax.CameraBackgroundSkyBoxBrush",(ax::CameraBackgroundSkyBoxBrush*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.CameraBackgroundSkyBoxBrush:create",argc, 6);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_CameraBackgroundSkyBoxBrush_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::CameraBackgroundSkyBoxBrush* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::CameraBackgroundSkyBoxBrush();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.CameraBackgroundSkyBoxBrush");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.CameraBackgroundSkyBoxBrush:CameraBackgroundSkyBoxBrush",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_CameraBackgroundSkyBoxBrush_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_CameraBackgroundSkyBoxBrush_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (CameraBackgroundSkyBoxBrush)");
    return 0;
}

int lua_register_ax_base_CameraBackgroundSkyBoxBrush(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.CameraBackgroundSkyBoxBrush");
    tolua_cclass(tolua_S,"CameraBackgroundSkyBoxBrush","ax.CameraBackgroundSkyBoxBrush","ax.CameraBackgroundBrush",nullptr);

    tolua_beginmodule(tolua_S,"CameraBackgroundSkyBoxBrush");
        tolua_function(tolua_S,"new",lua_ax_base_CameraBackgroundSkyBoxBrush_constructor);
        tolua_function(tolua_S,"setTexture",lua_ax_base_CameraBackgroundSkyBoxBrush_setTexture);
        tolua_function(tolua_S,"getTexture",lua_ax_base_CameraBackgroundSkyBoxBrush_getTexture);
        tolua_function(tolua_S,"isActived",lua_ax_base_CameraBackgroundSkyBoxBrush_isActived);
        tolua_function(tolua_S,"setActived",lua_ax_base_CameraBackgroundSkyBoxBrush_setActived);
        tolua_function(tolua_S,"setTextureValid",lua_ax_base_CameraBackgroundSkyBoxBrush_setTextureValid);
        tolua_function(tolua_S,"create", lua_ax_base_CameraBackgroundSkyBoxBrush_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::CameraBackgroundSkyBoxBrush).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.CameraBackgroundSkyBoxBrush";
    g_typeCast[typeName] = "ax.CameraBackgroundSkyBoxBrush";
    return 1;
}

int lua_ax_base_GridBase_beforeBlit(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_beforeBlit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_beforeBlit'", nullptr);
            return 0;
        }
        cobj->beforeBlit();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:beforeBlit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_beforeBlit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_afterBlit(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_afterBlit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_afterBlit'", nullptr);
            return 0;
        }
        cobj->afterBlit();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:afterBlit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_afterBlit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_blit(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_blit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_blit'", nullptr);
            return 0;
        }
        cobj->blit();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:blit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_blit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_reuse(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_reuse'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_reuse'", nullptr);
            return 0;
        }
        cobj->reuse();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:reuse",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_reuse'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_calculateVertexPoints(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_calculateVertexPoints'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_calculateVertexPoints'", nullptr);
            return 0;
        }
        cobj->calculateVertexPoints();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:calculateVertexPoints",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_calculateVertexPoints'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_initWithSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_initWithSize'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool ret = cobj->initWithSize(arg0, arg1);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool ret = cobj->initWithSize(arg0);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool ret = cobj->initWithSize(arg0, arg1, arg2);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 4) {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            ax::Rect arg3;
            ok &= luaval_to_rect(tolua_S, 5, &arg3, "ax.GridBase:initWithSize");

            if (!ok) { break; }
            bool ret = cobj->initWithSize(arg0, arg1, arg2, arg3);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.GridBase:initWithSize",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_initWithSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_isActive(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_isActive'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_isActive'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isActive();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:isActive",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_isActive'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setActive(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setActive'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.GridBase:setActive");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setActive'", nullptr);
            return 0;
        }
        cobj->setActive(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setActive",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setActive'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_getReuseGrid(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_getReuseGrid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_getReuseGrid'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getReuseGrid();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:getReuseGrid",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_getReuseGrid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setReuseGrid(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setReuseGrid'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.GridBase:setReuseGrid");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setReuseGrid'", nullptr);
            return 0;
        }
        cobj->setReuseGrid(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setReuseGrid",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setReuseGrid'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_getGridSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_getGridSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_getGridSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGridSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:getGridSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_getGridSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setGridSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setGridSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:setGridSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setGridSize'", nullptr);
            return 0;
        }
        cobj->setGridSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setGridSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setGridSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_getStep(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_getStep'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_getStep'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStep();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:getStep",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_getStep'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setStep(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setStep'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.GridBase:setStep");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setStep'", nullptr);
            return 0;
        }
        cobj->setStep(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setStep",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setStep'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_isTextureFlipped(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_isTextureFlipped'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_isTextureFlipped'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isTextureFlipped();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:isTextureFlipped",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_isTextureFlipped'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setTextureFlipped(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setTextureFlipped'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.GridBase:setTextureFlipped");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setTextureFlipped'", nullptr);
            return 0;
        }
        cobj->setTextureFlipped(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setTextureFlipped",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setTextureFlipped'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_beforeDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_beforeDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_beforeDraw'", nullptr);
            return 0;
        }
        cobj->beforeDraw();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:beforeDraw",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_beforeDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_afterDraw(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_afterDraw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Node* arg0;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.GridBase:afterDraw");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_afterDraw'", nullptr);
            return 0;
        }
        cobj->afterDraw(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:afterDraw",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_afterDraw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_set2DProjection(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_set2DProjection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_set2DProjection'", nullptr);
            return 0;
        }
        cobj->set2DProjection();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:set2DProjection",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_set2DProjection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_setGridRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_setGridRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Rect arg0;

        ok &= luaval_to_rect(tolua_S, 2, &arg0, "ax.GridBase:setGridRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_setGridRect'", nullptr);
            return 0;
        }
        cobj->setGridRect(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:setGridRect",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_setGridRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_GridBase_getGridRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::GridBase* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.GridBase",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::GridBase*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_GridBase_getGridRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GridBase_getGridRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGridRect();
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.GridBase:getGridRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GridBase_getGridRect'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_GridBase_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (GridBase)");
    return 0;
}

int lua_register_ax_base_GridBase(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.GridBase");
    tolua_cclass(tolua_S,"GridBase","ax.GridBase","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"GridBase");
        tolua_function(tolua_S,"beforeBlit",lua_ax_base_GridBase_beforeBlit);
        tolua_function(tolua_S,"afterBlit",lua_ax_base_GridBase_afterBlit);
        tolua_function(tolua_S,"blit",lua_ax_base_GridBase_blit);
        tolua_function(tolua_S,"reuse",lua_ax_base_GridBase_reuse);
        tolua_function(tolua_S,"calculateVertexPoints",lua_ax_base_GridBase_calculateVertexPoints);
        tolua_function(tolua_S,"initWithSize",lua_ax_base_GridBase_initWithSize);
        tolua_function(tolua_S,"isActive",lua_ax_base_GridBase_isActive);
        tolua_function(tolua_S,"setActive",lua_ax_base_GridBase_setActive);
        tolua_function(tolua_S,"getReuseGrid",lua_ax_base_GridBase_getReuseGrid);
        tolua_function(tolua_S,"setReuseGrid",lua_ax_base_GridBase_setReuseGrid);
        tolua_function(tolua_S,"getGridSize",lua_ax_base_GridBase_getGridSize);
        tolua_function(tolua_S,"setGridSize",lua_ax_base_GridBase_setGridSize);
        tolua_function(tolua_S,"getStep",lua_ax_base_GridBase_getStep);
        tolua_function(tolua_S,"setStep",lua_ax_base_GridBase_setStep);
        tolua_function(tolua_S,"isTextureFlipped",lua_ax_base_GridBase_isTextureFlipped);
        tolua_function(tolua_S,"setTextureFlipped",lua_ax_base_GridBase_setTextureFlipped);
        tolua_function(tolua_S,"beforeDraw",lua_ax_base_GridBase_beforeDraw);
        tolua_function(tolua_S,"afterDraw",lua_ax_base_GridBase_afterDraw);
        tolua_function(tolua_S,"set2DProjection",lua_ax_base_GridBase_set2DProjection);
        tolua_function(tolua_S,"setGridRect",lua_ax_base_GridBase_setGridRect);
        tolua_function(tolua_S,"getGridRect",lua_ax_base_GridBase_getGridRect);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::GridBase).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.GridBase";
    g_typeCast[typeName] = "ax.GridBase";
    return 1;
}

int lua_ax_base_Grid3D_setNeedDepthTestForBlit(lua_State* tolua_S)
{
    int argc = 0;
    ax::Grid3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Grid3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Grid3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Grid3D_setNeedDepthTestForBlit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Grid3D:setNeedDepthTestForBlit");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Grid3D_setNeedDepthTestForBlit'", nullptr);
            return 0;
        }
        cobj->setNeedDepthTestForBlit(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Grid3D:setNeedDepthTestForBlit",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Grid3D_setNeedDepthTestForBlit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Grid3D_getNeedDepthTestForBlit(lua_State* tolua_S)
{
    int argc = 0;
    ax::Grid3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Grid3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Grid3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Grid3D_getNeedDepthTestForBlit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Grid3D_getNeedDepthTestForBlit'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNeedDepthTestForBlit();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Grid3D:getNeedDepthTestForBlit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Grid3D_getNeedDepthTestForBlit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Grid3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Grid3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Grid3D* ret = ax::Grid3D::create(arg0, arg1);
            object_to_luaval<ax::Grid3D>(tolua_S, "ax.Grid3D",(ax::Grid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Grid3D* ret = ax::Grid3D::create(arg0);
            object_to_luaval<ax::Grid3D>(tolua_S, "ax.Grid3D",(ax::Grid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.Grid3D:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Grid3D* ret = ax::Grid3D::create(arg0, arg1, arg2);
            object_to_luaval<ax::Grid3D>(tolua_S, "ax.Grid3D",(ax::Grid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.Grid3D:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Rect arg3;
            ok &= luaval_to_rect(tolua_S, 5, &arg3, "ax.Grid3D:create");
            if (!ok) { break; }
            ax::Grid3D* ret = ax::Grid3D::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::Grid3D>(tolua_S, "ax.Grid3D",(ax::Grid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.Grid3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Grid3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Grid3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Grid3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Grid3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Grid3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.Grid3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Grid3D:Grid3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Grid3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Grid3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Grid3D)");
    return 0;
}

int lua_register_ax_base_Grid3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Grid3D");
    tolua_cclass(tolua_S,"Grid3D","ax.Grid3D","ax.GridBase",nullptr);

    tolua_beginmodule(tolua_S,"Grid3D");
        tolua_function(tolua_S,"new",lua_ax_base_Grid3D_constructor);
        tolua_function(tolua_S,"setNeedDepthTestForBlit",lua_ax_base_Grid3D_setNeedDepthTestForBlit);
        tolua_function(tolua_S,"getNeedDepthTestForBlit",lua_ax_base_Grid3D_getNeedDepthTestForBlit);
        tolua_function(tolua_S,"create", lua_ax_base_Grid3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Grid3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Grid3D";
    g_typeCast[typeName] = "ax.Grid3D";
    return 1;
}

int lua_ax_base_TiledGrid3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TiledGrid3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 2)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::Rect arg1;
            ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::TiledGrid3D* ret = ax::TiledGrid3D::create(arg0, arg1);
            object_to_luaval<ax::TiledGrid3D>(tolua_S, "ax.TiledGrid3D",(ax::TiledGrid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 1)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::TiledGrid3D* ret = ax::TiledGrid3D::create(arg0);
            object_to_luaval<ax::TiledGrid3D>(tolua_S, "ax.TiledGrid3D",(ax::TiledGrid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 3)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::TiledGrid3D* ret = ax::TiledGrid3D::create(arg0, arg1, arg2);
            object_to_luaval<ax::TiledGrid3D>(tolua_S, "ax.TiledGrid3D",(ax::TiledGrid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 4)
        {
            ax::Vec2 arg0;
            ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::Texture2D* arg1;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 3, "ax.Texture2D",&arg1, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            bool arg2;
            ok &= luaval_to_boolean(tolua_S, 4,&arg2, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::Rect arg3;
            ok &= luaval_to_rect(tolua_S, 5, &arg3, "ax.TiledGrid3D:create");
            if (!ok) { break; }
            ax::TiledGrid3D* ret = ax::TiledGrid3D::create(arg0, arg1, arg2, arg3);
            object_to_luaval<ax::TiledGrid3D>(tolua_S, "ax.TiledGrid3D",(ax::TiledGrid3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.TiledGrid3D:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TiledGrid3D_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_TiledGrid3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TiledGrid3D)");
    return 0;
}

int lua_register_ax_base_TiledGrid3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TiledGrid3D");
    tolua_cclass(tolua_S,"TiledGrid3D","ax.TiledGrid3D","ax.GridBase",nullptr);

    tolua_beginmodule(tolua_S,"TiledGrid3D");
        tolua_function(tolua_S,"create", lua_ax_base_TiledGrid3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TiledGrid3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TiledGrid3D";
    g_typeCast[typeName] = "ax.TiledGrid3D";
    return 1;
}

int lua_ax_base_BaseLight_getLightType(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_getLightType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_getLightType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getLightType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:getLightType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_getLightType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_getIntensity(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_getIntensity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_getIntensity'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getIntensity();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:getIntensity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_getIntensity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_setIntensity(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_setIntensity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.BaseLight:setIntensity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_setIntensity'", nullptr);
            return 0;
        }
        cobj->setIntensity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:setIntensity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_setIntensity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_getLightFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_getLightFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_getLightFlag'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getLightFlag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:getLightFlag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_getLightFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_setLightFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_setLightFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::LightFlag arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.BaseLight:setLightFlag");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_setLightFlag'", nullptr);
            return 0;
        }
        cobj->setLightFlag(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:setLightFlag",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_setLightFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_setEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_setEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.BaseLight:setEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_setEnabled'", nullptr);
            return 0;
        }
        cobj->setEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:setEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_setEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_BaseLight_isEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::BaseLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.BaseLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::BaseLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_BaseLight_isEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_BaseLight_isEnabled'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isEnabled();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.BaseLight:isEnabled",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_BaseLight_isEnabled'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_BaseLight_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (BaseLight)");
    return 0;
}

int lua_register_ax_base_BaseLight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.BaseLight");
    tolua_cclass(tolua_S,"BaseLight","ax.BaseLight","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"BaseLight");
        tolua_function(tolua_S,"getLightType",lua_ax_base_BaseLight_getLightType);
        tolua_function(tolua_S,"getIntensity",lua_ax_base_BaseLight_getIntensity);
        tolua_function(tolua_S,"setIntensity",lua_ax_base_BaseLight_setIntensity);
        tolua_function(tolua_S,"getLightFlag",lua_ax_base_BaseLight_getLightFlag);
        tolua_function(tolua_S,"setLightFlag",lua_ax_base_BaseLight_setLightFlag);
        tolua_function(tolua_S,"setEnabled",lua_ax_base_BaseLight_setEnabled);
        tolua_function(tolua_S,"isEnabled",lua_ax_base_BaseLight_isEnabled);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::BaseLight).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.BaseLight";
    g_typeCast[typeName] = "ax.BaseLight";
    return 1;
}

int lua_ax_base_DirectionLight_setDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::DirectionLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DirectionLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DirectionLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DirectionLight_setDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.DirectionLight:setDirection");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DirectionLight_setDirection'", nullptr);
            return 0;
        }
        cobj->setDirection(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DirectionLight:setDirection",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DirectionLight_setDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DirectionLight_getDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::DirectionLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DirectionLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DirectionLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DirectionLight_getDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DirectionLight_getDirection'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDirection();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DirectionLight:getDirection",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DirectionLight_getDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DirectionLight_getDirectionInWorld(lua_State* tolua_S)
{
    int argc = 0;
    ax::DirectionLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.DirectionLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::DirectionLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_DirectionLight_getDirectionInWorld'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DirectionLight_getDirectionInWorld'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDirectionInWorld();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DirectionLight:getDirectionInWorld",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DirectionLight_getDirectionInWorld'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_DirectionLight_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.DirectionLight",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Vec3 arg0;
        ax::Color3B arg1;
        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.DirectionLight:create");
        ok &= luaval_to_color3b(tolua_S, 3, &arg1, "ax.DirectionLight:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DirectionLight_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::DirectionLight::create(arg0, arg1);
        object_to_luaval<ax::DirectionLight>(tolua_S, "ax.DirectionLight",(ax::DirectionLight*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.DirectionLight:create",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DirectionLight_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_DirectionLight_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::DirectionLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_DirectionLight_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::DirectionLight();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.DirectionLight");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.DirectionLight:DirectionLight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_DirectionLight_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_DirectionLight_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (DirectionLight)");
    return 0;
}

int lua_register_ax_base_DirectionLight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.DirectionLight");
    tolua_cclass(tolua_S,"DirectionLight","ax.DirectionLight","ax.BaseLight",nullptr);

    tolua_beginmodule(tolua_S,"DirectionLight");
        tolua_function(tolua_S,"new",lua_ax_base_DirectionLight_constructor);
        tolua_function(tolua_S,"setDirection",lua_ax_base_DirectionLight_setDirection);
        tolua_function(tolua_S,"getDirection",lua_ax_base_DirectionLight_getDirection);
        tolua_function(tolua_S,"getDirectionInWorld",lua_ax_base_DirectionLight_getDirectionInWorld);
        tolua_function(tolua_S,"create", lua_ax_base_DirectionLight_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::DirectionLight).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.DirectionLight";
    g_typeCast[typeName] = "ax.DirectionLight";
    return 1;
}

int lua_ax_base_PointLight_getRange(lua_State* tolua_S)
{
    int argc = 0;
    ax::PointLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PointLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PointLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PointLight_getRange'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PointLight_getRange'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRange();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PointLight:getRange",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PointLight_getRange'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PointLight_setRange(lua_State* tolua_S)
{
    int argc = 0;
    ax::PointLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.PointLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::PointLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_PointLight_setRange'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.PointLight:setRange");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PointLight_setRange'", nullptr);
            return 0;
        }
        cobj->setRange(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PointLight:setRange",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PointLight_setRange'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_PointLight_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.PointLight",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::Vec3 arg0;
        ax::Color3B arg1;
        double arg2;
        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.PointLight:create");
        ok &= luaval_to_color3b(tolua_S, 3, &arg1, "ax.PointLight:create");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.PointLight:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PointLight_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::PointLight::create(arg0, arg1, arg2);
        object_to_luaval<ax::PointLight>(tolua_S, "ax.PointLight",(ax::PointLight*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.PointLight:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PointLight_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_PointLight_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::PointLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_PointLight_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::PointLight();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.PointLight");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.PointLight:PointLight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_PointLight_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_PointLight_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (PointLight)");
    return 0;
}

int lua_register_ax_base_PointLight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.PointLight");
    tolua_cclass(tolua_S,"PointLight","ax.PointLight","ax.BaseLight",nullptr);

    tolua_beginmodule(tolua_S,"PointLight");
        tolua_function(tolua_S,"new",lua_ax_base_PointLight_constructor);
        tolua_function(tolua_S,"getRange",lua_ax_base_PointLight_getRange);
        tolua_function(tolua_S,"setRange",lua_ax_base_PointLight_setRange);
        tolua_function(tolua_S,"create", lua_ax_base_PointLight_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::PointLight).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.PointLight";
    g_typeCast[typeName] = "ax.PointLight";
    return 1;
}

int lua_ax_base_SpotLight_setDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_setDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.SpotLight:setDirection");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_setDirection'", nullptr);
            return 0;
        }
        cobj->setDirection(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:setDirection",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_setDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getDirection(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getDirection'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getDirection'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDirection();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getDirection",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getDirection'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getDirectionInWorld(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getDirectionInWorld'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getDirectionInWorld'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDirectionInWorld();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getDirectionInWorld",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getDirectionInWorld'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_setRange(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_setRange'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SpotLight:setRange");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_setRange'", nullptr);
            return 0;
        }
        cobj->setRange(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:setRange",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_setRange'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getRange(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getRange'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getRange'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRange();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getRange",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getRange'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_setInnerAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_setInnerAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SpotLight:setInnerAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_setInnerAngle'", nullptr);
            return 0;
        }
        cobj->setInnerAngle(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:setInnerAngle",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_setInnerAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getInnerAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getInnerAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getInnerAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getInnerAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getInnerAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getInnerAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getCosInnerAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getCosInnerAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getCosInnerAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCosInnerAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getCosInnerAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getCosInnerAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_setOuterAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_setOuterAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.SpotLight:setOuterAngle");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_setOuterAngle'", nullptr);
            return 0;
        }
        cobj->setOuterAngle(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:setOuterAngle",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_setOuterAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getOuterAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getOuterAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getOuterAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOuterAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getOuterAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getOuterAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_getCosOuterAngle(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpotLight*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpotLight_getCosOuterAngle'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_getCosOuterAngle'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCosOuterAngle();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:getCosOuterAngle",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_getCosOuterAngle'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpotLight_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpotLight",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 6)
    {
        ax::Vec3 arg0;
        ax::Vec3 arg1;
        ax::Color3B arg2;
        double arg3;
        double arg4;
        double arg5;
        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.SpotLight:create");
        ok &= luaval_to_vec3(tolua_S, 3, &arg1, "ax.SpotLight:create");
        ok &= luaval_to_color3b(tolua_S, 4, &arg2, "ax.SpotLight:create");
        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.SpotLight:create");
        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.SpotLight:create");
        ok &= luaval_to_number(tolua_S, 7,&arg5, "ax.SpotLight:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpotLight::create(arg0, arg1, arg2, arg3, arg4, arg5);
        object_to_luaval<ax::SpotLight>(tolua_S, "ax.SpotLight",(ax::SpotLight*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SpotLight:create",argc, 6);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpotLight_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpotLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpotLight_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SpotLight();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SpotLight");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpotLight:SpotLight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpotLight_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SpotLight_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SpotLight)");
    return 0;
}

int lua_register_ax_base_SpotLight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SpotLight");
    tolua_cclass(tolua_S,"SpotLight","ax.SpotLight","ax.BaseLight",nullptr);

    tolua_beginmodule(tolua_S,"SpotLight");
        tolua_function(tolua_S,"new",lua_ax_base_SpotLight_constructor);
        tolua_function(tolua_S,"setDirection",lua_ax_base_SpotLight_setDirection);
        tolua_function(tolua_S,"getDirection",lua_ax_base_SpotLight_getDirection);
        tolua_function(tolua_S,"getDirectionInWorld",lua_ax_base_SpotLight_getDirectionInWorld);
        tolua_function(tolua_S,"setRange",lua_ax_base_SpotLight_setRange);
        tolua_function(tolua_S,"getRange",lua_ax_base_SpotLight_getRange);
        tolua_function(tolua_S,"setInnerAngle",lua_ax_base_SpotLight_setInnerAngle);
        tolua_function(tolua_S,"getInnerAngle",lua_ax_base_SpotLight_getInnerAngle);
        tolua_function(tolua_S,"getCosInnerAngle",lua_ax_base_SpotLight_getCosInnerAngle);
        tolua_function(tolua_S,"setOuterAngle",lua_ax_base_SpotLight_setOuterAngle);
        tolua_function(tolua_S,"getOuterAngle",lua_ax_base_SpotLight_getOuterAngle);
        tolua_function(tolua_S,"getCosOuterAngle",lua_ax_base_SpotLight_getCosOuterAngle);
        tolua_function(tolua_S,"create", lua_ax_base_SpotLight_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SpotLight).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SpotLight";
    g_typeCast[typeName] = "ax.SpotLight";
    return 1;
}

int lua_ax_base_AmbientLight_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AmbientLight",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Color3B arg0;
        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.AmbientLight:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AmbientLight_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::AmbientLight::create(arg0);
        object_to_luaval<ax::AmbientLight>(tolua_S, "ax.AmbientLight",(ax::AmbientLight*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AmbientLight:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AmbientLight_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AmbientLight_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AmbientLight* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AmbientLight_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AmbientLight();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.AmbientLight");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AmbientLight:AmbientLight",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AmbientLight_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AmbientLight_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AmbientLight)");
    return 0;
}

int lua_register_ax_base_AmbientLight(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AmbientLight");
    tolua_cclass(tolua_S,"AmbientLight","ax.AmbientLight","ax.BaseLight",nullptr);

    tolua_beginmodule(tolua_S,"AmbientLight");
        tolua_function(tolua_S,"new",lua_ax_base_AmbientLight_constructor);
        tolua_function(tolua_S,"create", lua_ax_base_AmbientLight_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AmbientLight).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AmbientLight";
    g_typeCast[typeName] = "ax.AmbientLight";
    return 1;
}

int lua_ax_base_RenderState_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderState* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderState",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderState*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderState_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderState_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderState:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderState_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_RenderState_bindPass(lua_State* tolua_S)
{
    int argc = 0;
    ax::RenderState* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.RenderState",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::RenderState*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_RenderState_bindPass'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Pass* arg0;
        ax::MeshCommand* arg1;

        ok &= luaval_to_object<ax::Pass>(tolua_S, 2, "ax.Pass",&arg0, "ax.RenderState:bindPass");

        ok &= luaval_to_object<ax::MeshCommand>(tolua_S, 3, "ax.MeshCommand",&arg1, "ax.RenderState:bindPass");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_RenderState_bindPass'", nullptr);
            return 0;
        }
        cobj->bindPass(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.RenderState:bindPass",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_RenderState_bindPass'.",&tolua_err);
#endif

    return 0;
}
static int lua_ax_base_RenderState_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (RenderState)");
    return 0;
}

int lua_register_ax_base_RenderState(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.RenderState");
    tolua_cclass(tolua_S,"RenderState","ax.RenderState","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"RenderState");
        tolua_function(tolua_S,"getName",lua_ax_base_RenderState_getName);
        tolua_function(tolua_S,"bindPass",lua_ax_base_RenderState_bindPass);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::RenderState).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.RenderState";
    g_typeCast[typeName] = "ax.RenderState";
    return 1;
}

int lua_ax_base_Technique_addPass(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_addPass'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Pass* arg0;

        ok &= luaval_to_object<ax::Pass>(tolua_S, 2, "ax.Pass",&arg0, "ax.Technique:addPass");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_addPass'", nullptr);
            return 0;
        }
        cobj->addPass(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:addPass",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_addPass'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_getPassByIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_getPassByIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.Technique:getPassByIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_getPassByIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPassByIndex(arg0);
        object_to_luaval<ax::Pass>(tolua_S, "ax.Pass",(ax::Pass*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:getPassByIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_getPassByIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_getPassCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_getPassCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_getPassCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPassCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:getPassCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_getPassCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_getPasses(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_getPasses'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_getPasses'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPasses();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:getPasses",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_getPasses'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_setMaterial(lua_State* tolua_S)
{
    int argc = 0;
    ax::Technique* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Technique*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Technique_setMaterial'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Material* arg0;

        ok &= luaval_to_object<ax::Material>(tolua_S, 2, "ax.Material",&arg0, "ax.Technique:setMaterial");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_setMaterial'", nullptr);
            return 0;
        }
        cobj->setMaterial(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Technique:setMaterial",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_setMaterial'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Technique_createWithProgramState(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Material* arg0;
        ax::backend::ProgramState* arg1;
        ok &= luaval_to_object<ax::Material>(tolua_S, 2, "ax.Material",&arg0, "ax.Technique:createWithProgramState");
        ok &= luaval_to_object<ax::backend::ProgramState>(tolua_S, 3, "axb.ProgramState",&arg1, "ax.Technique:createWithProgramState");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_createWithProgramState'", nullptr);
            return 0;
        }
        auto&& ret = ax::Technique::createWithProgramState(arg0, arg1);
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Technique:createWithProgramState",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_createWithProgramState'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Technique_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Technique",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Material* arg0;
        ok &= luaval_to_object<ax::Material>(tolua_S, 2, "ax.Material",&arg0, "ax.Technique:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Technique_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Technique::create(arg0);
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Technique:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Technique_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Technique_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Technique)");
    return 0;
}

int lua_register_ax_base_Technique(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Technique");
    tolua_cclass(tolua_S,"Technique","ax.Technique","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Technique");
        tolua_function(tolua_S,"addPass",lua_ax_base_Technique_addPass);
        tolua_function(tolua_S,"getName",lua_ax_base_Technique_getName);
        tolua_function(tolua_S,"getPassByIndex",lua_ax_base_Technique_getPassByIndex);
        tolua_function(tolua_S,"getPassCount",lua_ax_base_Technique_getPassCount);
        tolua_function(tolua_S,"getPasses",lua_ax_base_Technique_getPasses);
        tolua_function(tolua_S,"clone",lua_ax_base_Technique_clone);
        tolua_function(tolua_S,"setMaterial",lua_ax_base_Technique_setMaterial);
        tolua_function(tolua_S,"createWithProgramState", lua_ax_base_Technique_createWithProgramState);
        tolua_function(tolua_S,"create", lua_ax_base_Technique_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Technique).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Technique";
    g_typeCast[typeName] = "ax.Technique";
    return 1;
}

int lua_ax_base_Material_draw(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_draw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 8) 
    {
        ax::MeshCommand* arg0;
        double arg1;
        ax::backend::Buffer* arg2;
        ax::backend::Buffer* arg3;
        ax::backend::PrimitiveType arg4;
        ax::backend::IndexFormat arg5;
        unsigned int arg6;
        ax::Mat4 arg7;

        ok &= luaval_to_object<ax::MeshCommand>(tolua_S, 2, "ax.MeshCommand",&arg0, "ax.Material:draw");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Material:draw");

        ok &= luaval_to_object<ax::backend::Buffer>(tolua_S, 4, "axb.Buffer",&arg2, "ax.Material:draw");

        ok &= luaval_to_object<ax::backend::Buffer>(tolua_S, 5, "axb.Buffer",&arg3, "ax.Material:draw");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Material:draw");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Material:draw");

        ok &= luaval_to_uint32(tolua_S, 8,&arg6, "ax.Material:draw");

        ok &= luaval_to_mat4(tolua_S, 9, &arg7, "ax.Material:draw");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_draw'", nullptr);
            return 0;
        }
        cobj->draw(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:draw",argc, 8);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_draw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_setName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_setName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Material:setName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_setName'", nullptr);
            return 0;
        }
        cobj->setName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:setName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_setName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getTechniqueByName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getTechniqueByName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Material:getTechniqueByName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getTechniqueByName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTechniqueByName(arg0);
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getTechniqueByName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getTechniqueByName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getTechniqueByIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getTechniqueByIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.Material:getTechniqueByIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getTechniqueByIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTechniqueByIndex(arg0);
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getTechniqueByIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getTechniqueByIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getTechnique(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getTechnique'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getTechnique'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTechnique();
        object_to_luaval<ax::Technique>(tolua_S, "ax.Technique",(ax::Technique*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getTechnique",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getTechnique'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getTechniques(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getTechniques'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getTechniques'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTechniques();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getTechniques",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getTechniques'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getTechniqueCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getTechniqueCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getTechniqueCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTechniqueCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getTechniqueCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getTechniqueCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_addTechnique(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_addTechnique'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Technique* arg0;

        ok &= luaval_to_object<ax::Technique>(tolua_S, 2, "ax.Technique",&arg0, "ax.Material:addTechnique");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_addTechnique'", nullptr);
            return 0;
        }
        cobj->addTechnique(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:addTechnique",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_addTechnique'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_setTechnique(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_setTechnique'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Material:setTechnique");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_setTechnique'", nullptr);
            return 0;
        }
        cobj->setTechnique(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:setTechnique",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_setTechnique'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::Material>(tolua_S, "ax.Material",(ax::Material*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getRenderState(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getRenderState'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getRenderState'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderState();
        object_to_luaval<ax::RenderState>(tolua_S, "ax.RenderState",(ax::RenderState*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getRenderState",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getRenderState'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_setPrimitiveType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_setPrimitiveType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::PrimitiveType arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Material:setPrimitiveType");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_setPrimitiveType'", nullptr);
            return 0;
        }
        cobj->setPrimitiveType(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:setPrimitiveType",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_setPrimitiveType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_getPrimitiveType(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_getPrimitiveType'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_getPrimitiveType'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getPrimitiveType();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:getPrimitiveType",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_getPrimitiveType'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_setTransparent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_setTransparent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Material:setTransparent");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_setTransparent'", nullptr);
            return 0;
        }
        cobj->setTransparent(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:setTransparent",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_setTransparent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_isTransparent(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_isTransparent'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_isTransparent'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isTransparent();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:isTransparent",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_isTransparent'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_setForce2DQueue(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_setForce2DQueue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Material:setForce2DQueue");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_setForce2DQueue'", nullptr);
            return 0;
        }
        cobj->setForce2DQueue(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:setForce2DQueue",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_setForce2DQueue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_isForce2DQueue(lua_State* tolua_S)
{
    int argc = 0;
    ax::Material* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Material*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Material_isForce2DQueue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_isForce2DQueue'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isForce2DQueue();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Material:isForce2DQueue",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_isForce2DQueue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Material_createWithFilename(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Material:createWithFilename");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_createWithFilename'", nullptr);
            return 0;
        }
        auto&& ret = ax::Material::createWithFilename(arg0);
        object_to_luaval<ax::Material>(tolua_S, "ax.Material",(ax::Material*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Material:createWithFilename",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_createWithFilename'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Material_createWithProgramState(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::backend::ProgramState* arg0;
        ok &= luaval_to_object<ax::backend::ProgramState>(tolua_S, 2, "axb.ProgramState",&arg0, "ax.Material:createWithProgramState");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_createWithProgramState'", nullptr);
            return 0;
        }
        auto&& ret = ax::Material::createWithProgramState(arg0);
        object_to_luaval<ax::Material>(tolua_S, "ax.Material",(ax::Material*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Material:createWithProgramState",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_createWithProgramState'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Material_createWithProperties(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Material",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Properties* arg0;
        ok &= luaval_to_object<ax::Properties>(tolua_S, 2, "ax.Properties",&arg0, "ax.Material:createWithProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Material_createWithProperties'", nullptr);
            return 0;
        }
        auto&& ret = ax::Material::createWithProperties(arg0);
        object_to_luaval<ax::Material>(tolua_S, "ax.Material",(ax::Material*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Material:createWithProperties",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Material_createWithProperties'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Material_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Material)");
    return 0;
}

int lua_register_ax_base_Material(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Material");
    tolua_cclass(tolua_S,"Material","ax.Material","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Material");
        tolua_function(tolua_S,"draw",lua_ax_base_Material_draw);
        tolua_function(tolua_S,"getName",lua_ax_base_Material_getName);
        tolua_function(tolua_S,"setName",lua_ax_base_Material_setName);
        tolua_function(tolua_S,"getTechniqueByName",lua_ax_base_Material_getTechniqueByName);
        tolua_function(tolua_S,"getTechniqueByIndex",lua_ax_base_Material_getTechniqueByIndex);
        tolua_function(tolua_S,"getTechnique",lua_ax_base_Material_getTechnique);
        tolua_function(tolua_S,"getTechniques",lua_ax_base_Material_getTechniques);
        tolua_function(tolua_S,"getTechniqueCount",lua_ax_base_Material_getTechniqueCount);
        tolua_function(tolua_S,"addTechnique",lua_ax_base_Material_addTechnique);
        tolua_function(tolua_S,"setTechnique",lua_ax_base_Material_setTechnique);
        tolua_function(tolua_S,"clone",lua_ax_base_Material_clone);
        tolua_function(tolua_S,"getRenderState",lua_ax_base_Material_getRenderState);
        tolua_function(tolua_S,"setPrimitiveType",lua_ax_base_Material_setPrimitiveType);
        tolua_function(tolua_S,"getPrimitiveType",lua_ax_base_Material_getPrimitiveType);
        tolua_function(tolua_S,"setTransparent",lua_ax_base_Material_setTransparent);
        tolua_function(tolua_S,"isTransparent",lua_ax_base_Material_isTransparent);
        tolua_function(tolua_S,"setForce2DQueue",lua_ax_base_Material_setForce2DQueue);
        tolua_function(tolua_S,"isForce2DQueue",lua_ax_base_Material_isForce2DQueue);
        tolua_function(tolua_S,"createWithFilename", lua_ax_base_Material_createWithFilename);
        tolua_function(tolua_S,"createWithProgramState", lua_ax_base_Material_createWithProgramState);
        tolua_function(tolua_S,"createWithProperties", lua_ax_base_Material_createWithProperties);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Material).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Material";
    g_typeCast[typeName] = "ax.Material";
    return 1;
}

int lua_ax_base_Pass_getProgramState(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_getProgramState'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_getProgramState'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProgramState();
        object_to_luaval<ax::backend::ProgramState>(tolua_S, "axb.ProgramState",(ax::backend::ProgramState*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:getProgramState",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_getProgramState'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_draw(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_draw'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 8) 
    {
        ax::MeshCommand* arg0;
        double arg1;
        ax::backend::Buffer* arg2;
        ax::backend::Buffer* arg3;
        ax::backend::PrimitiveType arg4;
        ax::backend::IndexFormat arg5;
        unsigned int arg6;
        ax::Mat4 arg7;

        ok &= luaval_to_object<ax::MeshCommand>(tolua_S, 2, "ax.MeshCommand",&arg0, "ax.Pass:draw");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Pass:draw");

        ok &= luaval_to_object<ax::backend::Buffer>(tolua_S, 4, "axb.Buffer",&arg2, "ax.Pass:draw");

        ok &= luaval_to_object<ax::backend::Buffer>(tolua_S, 5, "axb.Buffer",&arg3, "ax.Pass:draw");

        ok &= luaval_to_int32(tolua_S, 6,(int *)&arg4, "ax.Pass:draw");

        ok &= luaval_to_int32(tolua_S, 7,(int *)&arg5, "ax.Pass:draw");

        ok &= luaval_to_uint32(tolua_S, 8,&arg6, "ax.Pass:draw");

        ok &= luaval_to_mat4(tolua_S, 9, &arg7, "ax.Pass:draw");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_draw'", nullptr);
            return 0;
        }
        cobj->draw(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:draw",argc, 8);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_draw'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setVertexAttribBinding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setVertexAttribBinding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::VertexAttribBinding* arg0;

        ok &= luaval_to_object<ax::VertexAttribBinding>(tolua_S, 2, "ax.VertexAttribBinding",&arg0, "ax.Pass:setVertexAttribBinding");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setVertexAttribBinding'", nullptr);
            return 0;
        }
        cobj->setVertexAttribBinding(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setVertexAttribBinding",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setVertexAttribBinding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_getVertexAttributeBinding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_getVertexAttributeBinding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_getVertexAttributeBinding'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVertexAttributeBinding();
        object_to_luaval<ax::VertexAttribBinding>(tolua_S, "ax.VertexAttribBinding",(ax::VertexAttribBinding*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:getVertexAttributeBinding",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_getVertexAttributeBinding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Pass:setName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setName'", nullptr);
            return 0;
        }
        cobj->setName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_getName(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_getName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_getName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:getName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_getName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_clone(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_clone'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_clone'", nullptr);
            return 0;
        }
        auto&& ret = cobj->clone();
        object_to_luaval<ax::Pass>(tolua_S, "ax.Pass",(ax::Pass*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:clone",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_clone'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setTechnique(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setTechnique'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Technique* arg0;

        ok &= luaval_to_object<ax::Technique>(tolua_S, 2, "ax.Technique",&arg0, "ax.Pass:setTechnique");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setTechnique'", nullptr);
            return 0;
        }
        cobj->setTechnique(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setTechnique",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setTechnique'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_updateMVPUniform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_updateMVPUniform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Mat4 arg0;

        ok &= luaval_to_mat4(tolua_S, 2, &arg0, "ax.Pass:updateMVPUniform");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_updateMVPUniform'", nullptr);
            return 0;
        }
        cobj->updateMVPUniform(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:updateMVPUniform",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_updateMVPUniform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        ax::backend::TextureBackend* arg1;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Pass:setUniformTexture");

        ok &= luaval_to_object<ax::backend::TextureBackend>(tolua_S, 3, "axb.TextureBackend",&arg1, "ax.Pass:setUniformTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformTexture'", nullptr);
            return 0;
        }
        cobj->setUniformTexture(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformTexture",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformNormTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformNormTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        unsigned int arg0;
        ax::backend::TextureBackend* arg1;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Pass:setUniformNormTexture");

        ok &= luaval_to_object<ax::backend::TextureBackend>(tolua_S, 3, "axb.TextureBackend",&arg1, "ax.Pass:setUniformNormTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformNormTexture'", nullptr);
            return 0;
        }
        cobj->setUniformNormTexture(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformNormTexture",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformNormTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformColor'", nullptr);
            return 0;
        }
        cobj->setUniformColor(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformMatrixPalette(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformMatrixPalette'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformMatrixPalette");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformMatrixPalette'", nullptr);
            return 0;
        }
        cobj->setUniformMatrixPalette(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformMatrixPalette",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformMatrixPalette'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformDirLightColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformDirLightColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformDirLightColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformDirLightColor'", nullptr);
            return 0;
        }
        cobj->setUniformDirLightColor(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformDirLightColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformDirLightColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformDirLightDir(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformDirLightDir'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformDirLightDir");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformDirLightDir'", nullptr);
            return 0;
        }
        cobj->setUniformDirLightDir(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformDirLightDir",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformDirLightDir'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformPointLightColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformPointLightColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformPointLightColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformPointLightColor'", nullptr);
            return 0;
        }
        cobj->setUniformPointLightColor(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformPointLightColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformPointLightColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformPointLightPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformPointLightPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformPointLightPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformPointLightPosition'", nullptr);
            return 0;
        }
        cobj->setUniformPointLightPosition(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformPointLightPosition",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformPointLightPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformPointLightRangeInverse(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformPointLightRangeInverse'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformPointLightRangeInverse");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformPointLightRangeInverse'", nullptr);
            return 0;
        }
        cobj->setUniformPointLightRangeInverse(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformPointLightRangeInverse",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformPointLightRangeInverse'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightColor'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightColor(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightPosition(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightPosition'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightPosition");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightPosition'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightPosition(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightPosition",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightPosition'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightDir(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightDir'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightDir");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightDir'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightDir(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightDir",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightDir'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightInnerAngleCos(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightInnerAngleCos'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightInnerAngleCos");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightInnerAngleCos'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightInnerAngleCos(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightInnerAngleCos",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightInnerAngleCos'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightOuterAngleCos(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightOuterAngleCos'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightOuterAngleCos");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightOuterAngleCos'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightOuterAngleCos(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightOuterAngleCos",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightOuterAngleCos'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformSpotLightRangeInverse(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformSpotLightRangeInverse'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformSpotLightRangeInverse");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformSpotLightRangeInverse'", nullptr);
            return 0;
        }
        cobj->setUniformSpotLightRangeInverse(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformSpotLightRangeInverse",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformSpotLightRangeInverse'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_setUniformAmbientLigthColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Pass* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Pass*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Pass_setUniformAmbientLigthColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        const void* arg0;
        unsigned int arg1;

        #pragma warning NO CONVERSION TO NATIVE FOR void*
		ok = false;

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Pass:setUniformAmbientLigthColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_setUniformAmbientLigthColor'", nullptr);
            return 0;
        }
        cobj->setUniformAmbientLigthColor(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Pass:setUniformAmbientLigthColor",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_setUniformAmbientLigthColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Pass_createWithProgramState(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        ax::Technique* arg0;
        ax::backend::ProgramState* arg1;
        ok &= luaval_to_object<ax::Technique>(tolua_S, 2, "ax.Technique",&arg0, "ax.Pass:createWithProgramState");
        ok &= luaval_to_object<ax::backend::ProgramState>(tolua_S, 3, "axb.ProgramState",&arg1, "ax.Pass:createWithProgramState");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_createWithProgramState'", nullptr);
            return 0;
        }
        auto&& ret = ax::Pass::createWithProgramState(arg0, arg1);
        object_to_luaval<ax::Pass>(tolua_S, "ax.Pass",(ax::Pass*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Pass:createWithProgramState",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_createWithProgramState'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Pass_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Pass",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Technique* arg0;
        ok &= luaval_to_object<ax::Technique>(tolua_S, 2, "ax.Technique",&arg0, "ax.Pass:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Pass_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::Pass::create(arg0);
        object_to_luaval<ax::Pass>(tolua_S, "ax.Pass",(ax::Pass*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Pass:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Pass_create'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Pass_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Pass)");
    return 0;
}

int lua_register_ax_base_Pass(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Pass");
    tolua_cclass(tolua_S,"Pass","ax.Pass","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"Pass");
        tolua_function(tolua_S,"getProgramState",lua_ax_base_Pass_getProgramState);
        tolua_function(tolua_S,"draw",lua_ax_base_Pass_draw);
        tolua_function(tolua_S,"setVertexAttribBinding",lua_ax_base_Pass_setVertexAttribBinding);
        tolua_function(tolua_S,"getVertexAttributeBinding",lua_ax_base_Pass_getVertexAttributeBinding);
        tolua_function(tolua_S,"setName",lua_ax_base_Pass_setName);
        tolua_function(tolua_S,"getName",lua_ax_base_Pass_getName);
        tolua_function(tolua_S,"clone",lua_ax_base_Pass_clone);
        tolua_function(tolua_S,"setTechnique",lua_ax_base_Pass_setTechnique);
        tolua_function(tolua_S,"updateMVPUniform",lua_ax_base_Pass_updateMVPUniform);
        tolua_function(tolua_S,"setUniformTexture",lua_ax_base_Pass_setUniformTexture);
        tolua_function(tolua_S,"setUniformNormTexture",lua_ax_base_Pass_setUniformNormTexture);
        tolua_function(tolua_S,"setUniformColor",lua_ax_base_Pass_setUniformColor);
        tolua_function(tolua_S,"setUniformMatrixPalette",lua_ax_base_Pass_setUniformMatrixPalette);
        tolua_function(tolua_S,"setUniformDirLightColor",lua_ax_base_Pass_setUniformDirLightColor);
        tolua_function(tolua_S,"setUniformDirLightDir",lua_ax_base_Pass_setUniformDirLightDir);
        tolua_function(tolua_S,"setUniformPointLightColor",lua_ax_base_Pass_setUniformPointLightColor);
        tolua_function(tolua_S,"setUniformPointLightPosition",lua_ax_base_Pass_setUniformPointLightPosition);
        tolua_function(tolua_S,"setUniformPointLightRangeInverse",lua_ax_base_Pass_setUniformPointLightRangeInverse);
        tolua_function(tolua_S,"setUniformSpotLightColor",lua_ax_base_Pass_setUniformSpotLightColor);
        tolua_function(tolua_S,"setUniformSpotLightPosition",lua_ax_base_Pass_setUniformSpotLightPosition);
        tolua_function(tolua_S,"setUniformSpotLightDir",lua_ax_base_Pass_setUniformSpotLightDir);
        tolua_function(tolua_S,"setUniformSpotLightInnerAngleCos",lua_ax_base_Pass_setUniformSpotLightInnerAngleCos);
        tolua_function(tolua_S,"setUniformSpotLightOuterAngleCos",lua_ax_base_Pass_setUniformSpotLightOuterAngleCos);
        tolua_function(tolua_S,"setUniformSpotLightRangeInverse",lua_ax_base_Pass_setUniformSpotLightRangeInverse);
        tolua_function(tolua_S,"setUniformAmbientLigthColor",lua_ax_base_Pass_setUniformAmbientLigthColor);
        tolua_function(tolua_S,"createWithProgramState", lua_ax_base_Pass_createWithProgramState);
        tolua_function(tolua_S,"create", lua_ax_base_Pass_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Pass).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Pass";
    g_typeCast[typeName] = "ax.Pass";
    return 1;
}

int lua_ax_base_Renderer_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_init'", nullptr);
            return 0;
        }
        cobj->init();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_addCallbackCommand(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_addCallbackCommand'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::function<void ()> arg0;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_addCallbackCommand'", nullptr);
            return 0;
        }
        cobj->addCallbackCommand(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    if (argc == 2) 
    {
        std::function<void ()> arg0;
        double arg1;

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Renderer:addCallbackCommand");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_addCallbackCommand'", nullptr);
            return 0;
        }
        cobj->addCallbackCommand(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:addCallbackCommand",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_addCallbackCommand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_addCommand(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_addCommand'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            ax::RenderCommand* arg0;
            ok &= luaval_to_object<ax::RenderCommand>(tolua_S, 2, "ax.RenderCommand",&arg0, "ax.Renderer:addCommand");

            if (!ok) { break; }
            int arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Renderer:addCommand");

            if (!ok) { break; }
            cobj->addCommand(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            ax::RenderCommand* arg0;
            ok &= luaval_to_object<ax::RenderCommand>(tolua_S, 2, "ax.RenderCommand",&arg0, "ax.Renderer:addCommand");

            if (!ok) { break; }
            cobj->addCommand(arg0);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.Renderer:addCommand",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_addCommand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getNextGroupCommand(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getNextGroupCommand'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getNextGroupCommand'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getNextGroupCommand();
        object_to_luaval<ax::GroupCommand>(tolua_S, "ax.GroupCommand",(ax::GroupCommand*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getNextGroupCommand",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getNextGroupCommand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_pushGroup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_pushGroup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:pushGroup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_pushGroup'", nullptr);
            return 0;
        }
        cobj->pushGroup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:pushGroup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_pushGroup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_popGroup(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_popGroup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_popGroup'", nullptr);
            return 0;
        }
        cobj->popGroup();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:popGroup",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_popGroup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_createRenderQueue(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_createRenderQueue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_createRenderQueue'", nullptr);
            return 0;
        }
        auto&& ret = cobj->createRenderQueue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:createRenderQueue",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_createRenderQueue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_render(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_render'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_render'", nullptr);
            return 0;
        }
        cobj->render();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:render",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_render'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_clean(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_clean'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_clean'", nullptr);
            return 0;
        }
        cobj->clean();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:clean",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_clean'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDrawnBatches(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDrawnBatches'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDrawnBatches'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDrawnBatches();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDrawnBatches",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDrawnBatches'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_addDrawnBatches(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_addDrawnBatches'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.Renderer:addDrawnBatches");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_addDrawnBatches'", nullptr);
            return 0;
        }
        cobj->addDrawnBatches(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:addDrawnBatches",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_addDrawnBatches'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDrawnVertices(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDrawnVertices'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDrawnVertices'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDrawnVertices();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDrawnVertices",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDrawnVertices'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_addDrawnVertices(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_addDrawnVertices'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.Renderer:addDrawnVertices");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_addDrawnVertices'", nullptr);
            return 0;
        }
        cobj->addDrawnVertices(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:addDrawnVertices",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_addDrawnVertices'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_clearDrawStats(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_clearDrawStats'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_clearDrawStats'", nullptr);
            return 0;
        }
        cobj->clearDrawStats();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:clearDrawStats",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_clearDrawStats'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRenderTarget();
        object_to_luaval<ax::backend::RenderTarget>(tolua_S, "axb.RenderTarget",(ax::backend::RenderTarget*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::RenderTarget* arg0;

        ok &= luaval_to_object<ax::backend::RenderTarget>(tolua_S, 2, "axb.RenderTarget",&arg0, "ax.Renderer:setRenderTarget");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setRenderTarget'", nullptr);
            return 0;
        }
        cobj->setRenderTarget(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setRenderTarget",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDefaultRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDefaultRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDefaultRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDefaultRenderTarget();
        object_to_luaval<ax::backend::RenderTarget>(tolua_S, "axb.RenderTarget",(ax::backend::RenderTarget*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDefaultRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDefaultRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getOffscreenRenderTarget(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getOffscreenRenderTarget'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getOffscreenRenderTarget'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOffscreenRenderTarget();
        object_to_luaval<ax::backend::RenderTarget>(tolua_S, "axb.RenderTarget",(ax::backend::RenderTarget*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getOffscreenRenderTarget",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getOffscreenRenderTarget'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_clear(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_clear'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 5) 
    {
        ax::backend::TargetBufferFlags arg0;
        ax::Color4F arg1;
        double arg2;
        unsigned int arg3;
        double arg4;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:clear");

        ok &=luaval_to_color4f(tolua_S, 3, &arg1, "ax.Renderer:clear");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Renderer:clear");

        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.Renderer:clear");

        ok &= luaval_to_number(tolua_S, 6,&arg4, "ax.Renderer:clear");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_clear'", nullptr);
            return 0;
        }
        cobj->clear(arg0, arg1, arg2, arg3, arg4);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:clear",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_clear'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getClearColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getClearColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getClearColor'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearColor();
        color4f_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getClearColor",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getClearColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getClearDepth(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getClearDepth'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getClearDepth'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearDepth();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getClearDepth",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getClearDepth'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getClearStencil(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getClearStencil'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getClearStencil'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getClearStencil();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getClearStencil",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getClearStencil'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getClearFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getClearFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getClearFlag'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getClearFlag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getClearFlag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getClearFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getRenderTargetFlag(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getRenderTargetFlag'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getRenderTargetFlag'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getRenderTargetFlag();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getRenderTargetFlag",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getRenderTargetFlag'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setDepthTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setDepthTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Renderer:setDepthTest");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setDepthTest'", nullptr);
            return 0;
        }
        cobj->setDepthTest(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setDepthTest",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setDepthTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setDepthWrite(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setDepthWrite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Renderer:setDepthWrite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setDepthWrite'", nullptr);
            return 0;
        }
        cobj->setDepthWrite(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setDepthWrite",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setDepthWrite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setDepthCompareFunction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setDepthCompareFunction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::CompareFunction arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setDepthCompareFunction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setDepthCompareFunction'", nullptr);
            return 0;
        }
        cobj->setDepthCompareFunction(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setDepthCompareFunction",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setDepthCompareFunction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDepthTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDepthTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDepthTest'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDepthTest();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDepthTest",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDepthTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDepthWrite(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDepthWrite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDepthWrite'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDepthWrite();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDepthWrite",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDepthWrite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDepthCompareFunction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDepthCompareFunction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDepthCompareFunction'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getDepthCompareFunction();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDepthCompareFunction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDepthCompareFunction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setStencilTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setStencilTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Renderer:setStencilTest");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setStencilTest'", nullptr);
            return 0;
        }
        cobj->setStencilTest(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setStencilTest",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setStencilTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setStencilCompareFunction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setStencilCompareFunction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::backend::CompareFunction arg0;
        unsigned int arg1;
        unsigned int arg2;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setStencilCompareFunction");

        ok &= luaval_to_uint32(tolua_S, 3,&arg1, "ax.Renderer:setStencilCompareFunction");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Renderer:setStencilCompareFunction");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setStencilCompareFunction'", nullptr);
            return 0;
        }
        cobj->setStencilCompareFunction(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setStencilCompareFunction",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setStencilCompareFunction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setStencilOperation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setStencilOperation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::backend::StencilOperation arg0;
        ax::backend::StencilOperation arg1;
        ax::backend::StencilOperation arg2;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setStencilOperation");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Renderer:setStencilOperation");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.Renderer:setStencilOperation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setStencilOperation'", nullptr);
            return 0;
        }
        cobj->setStencilOperation(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setStencilOperation",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setStencilOperation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setStencilWriteMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setStencilWriteMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.Renderer:setStencilWriteMask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setStencilWriteMask'", nullptr);
            return 0;
        }
        cobj->setStencilWriteMask(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setStencilWriteMask",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setStencilWriteMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilTest'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStencilTest();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilTest",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilFailureOperation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilFailureOperation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilFailureOperation'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getStencilFailureOperation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilFailureOperation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilFailureOperation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilPassDepthFailureOperation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilPassDepthFailureOperation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilPassDepthFailureOperation'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getStencilPassDepthFailureOperation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilPassDepthFailureOperation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilPassDepthFailureOperation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilDepthPassOperation(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilDepthPassOperation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilDepthPassOperation'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getStencilDepthPassOperation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilDepthPassOperation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilDepthPassOperation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilCompareFunction(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilCompareFunction'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilCompareFunction'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getStencilCompareFunction();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilCompareFunction",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilCompareFunction'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilReadMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilReadMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilReadMask'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStencilReadMask();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilReadMask",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilReadMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilWriteMask(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilWriteMask'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilWriteMask'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStencilWriteMask();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilWriteMask",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilWriteMask'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getStencilReferenceValue(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getStencilReferenceValue'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getStencilReferenceValue'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStencilReferenceValue();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getStencilReferenceValue",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getStencilReferenceValue'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setDepthStencilDesc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setDepthStencilDesc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::DepthStencilDescriptor arg0;

        #pragma warning NO CONVERSION TO NATIVE FOR DepthStencilDescriptor
		ok = false;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setDepthStencilDesc'", nullptr);
            return 0;
        }
        cobj->setDepthStencilDesc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setDepthStencilDesc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setDepthStencilDesc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getDepthStencilDesc(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getDepthStencilDesc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getDepthStencilDesc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDepthStencilDesc();
        #pragma warning NO CONVERSION FROM NATIVE FOR DepthStencilDescriptor;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getDepthStencilDesc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getDepthStencilDesc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setCullMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setCullMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::CullMode arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setCullMode");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setCullMode'", nullptr);
            return 0;
        }
        cobj->setCullMode(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setCullMode",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setCullMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getCullMode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getCullMode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getCullMode'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getCullMode();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getCullMode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getCullMode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setWinding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setWinding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::backend::Winding arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setWinding");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setWinding'", nullptr);
            return 0;
        }
        cobj->setWinding(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setWinding",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setWinding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getWinding(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getWinding'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getWinding'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getWinding();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getWinding",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getWinding'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setViewPort(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setViewPort'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        int arg0;
        int arg1;
        unsigned int arg2;
        unsigned int arg3;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Renderer:setViewPort");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.Renderer:setViewPort");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.Renderer:setViewPort");

        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.Renderer:setViewPort");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setViewPort'", nullptr);
            return 0;
        }
        cobj->setViewPort(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setViewPort",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setViewPort'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getViewport(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getViewport'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getViewport'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getViewport();
        #pragma warning NO CONVERSION FROM NATIVE FOR RectI;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getViewport",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getViewport'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setScissorTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setScissorTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Renderer:setScissorTest");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setScissorTest'", nullptr);
            return 0;
        }
        cobj->setScissorTest(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setScissorTest",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setScissorTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_setScissorRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_setScissorRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        double arg0;
        double arg1;
        double arg2;
        double arg3;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Renderer:setScissorRect");

        ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.Renderer:setScissorRect");

        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.Renderer:setScissorRect");

        ok &= luaval_to_number(tolua_S, 5,&arg3, "ax.Renderer:setScissorRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_setScissorRect'", nullptr);
            return 0;
        }
        cobj->setScissorRect(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:setScissorRect",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_setScissorRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getScissorTest(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getScissorTest'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getScissorTest'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScissorTest();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getScissorTest",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getScissorTest'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_getScissorRect(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_getScissorRect'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_getScissorRect'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScissorRect();
        #pragma warning NO CONVERSION FROM NATIVE FOR RectI;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:getScissorRect",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_getScissorRect'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_checkVisibility(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_checkVisibility'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Mat4 arg0;
        ax::Vec2 arg1;

        ok &= luaval_to_mat4(tolua_S, 2, &arg0, "ax.Renderer:checkVisibility");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.Renderer:checkVisibility");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_checkVisibility'", nullptr);
            return 0;
        }
        auto&& ret = cobj->checkVisibility(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:checkVisibility",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_checkVisibility'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_readPixels(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_readPixels'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::backend::RenderTarget* arg0;
        std::function<void (const ax::backend::PixelBufferDescriptor &)> arg1;

        ok &= luaval_to_object<ax::backend::RenderTarget>(tolua_S, 2, "axb.RenderTarget",&arg0, "ax.Renderer:readPixels");

        do {
			// Lambda binding for lua is not supported.
			assert(false);
		} while(0)
		;
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_readPixels'", nullptr);
            return 0;
        }
        cobj->readPixels(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:readPixels",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_readPixels'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_beginRenderPass(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_beginRenderPass'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_beginRenderPass'", nullptr);
            return 0;
        }
        cobj->beginRenderPass();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:beginRenderPass",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_beginRenderPass'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_endRenderPass(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_endRenderPass'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_endRenderPass'", nullptr);
            return 0;
        }
        cobj->endRenderPass();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:endRenderPass",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_endRenderPass'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_nextCallbackCommand(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Renderer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Renderer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Renderer_nextCallbackCommand'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_nextCallbackCommand'", nullptr);
            return 0;
        }
        auto&& ret = cobj->nextCallbackCommand();
        object_to_luaval<ax::CallbackCommand>(tolua_S, "ax.CallbackCommand",(ax::CallbackCommand*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:nextCallbackCommand",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_nextCallbackCommand'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Renderer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::Renderer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Renderer_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::Renderer();
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.Renderer");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Renderer:Renderer",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Renderer_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_Renderer_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Renderer)");
    return 0;
}

int lua_register_ax_base_Renderer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Renderer");
    tolua_cclass(tolua_S,"Renderer","ax.Renderer","",nullptr);

    tolua_beginmodule(tolua_S,"Renderer");
        tolua_function(tolua_S,"new",lua_ax_base_Renderer_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_Renderer_init);
        tolua_function(tolua_S,"addCallbackCommand",lua_ax_base_Renderer_addCallbackCommand);
        tolua_function(tolua_S,"addCommand",lua_ax_base_Renderer_addCommand);
        tolua_function(tolua_S,"getNextGroupCommand",lua_ax_base_Renderer_getNextGroupCommand);
        tolua_function(tolua_S,"pushGroup",lua_ax_base_Renderer_pushGroup);
        tolua_function(tolua_S,"popGroup",lua_ax_base_Renderer_popGroup);
        tolua_function(tolua_S,"createRenderQueue",lua_ax_base_Renderer_createRenderQueue);
        tolua_function(tolua_S,"render",lua_ax_base_Renderer_render);
        tolua_function(tolua_S,"clean",lua_ax_base_Renderer_clean);
        tolua_function(tolua_S,"getDrawnBatches",lua_ax_base_Renderer_getDrawnBatches);
        tolua_function(tolua_S,"addDrawnBatches",lua_ax_base_Renderer_addDrawnBatches);
        tolua_function(tolua_S,"getDrawnVertices",lua_ax_base_Renderer_getDrawnVertices);
        tolua_function(tolua_S,"addDrawnVertices",lua_ax_base_Renderer_addDrawnVertices);
        tolua_function(tolua_S,"clearDrawStats",lua_ax_base_Renderer_clearDrawStats);
        tolua_function(tolua_S,"getRenderTarget",lua_ax_base_Renderer_getRenderTarget);
        tolua_function(tolua_S,"setRenderTarget",lua_ax_base_Renderer_setRenderTarget);
        tolua_function(tolua_S,"getDefaultRenderTarget",lua_ax_base_Renderer_getDefaultRenderTarget);
        tolua_function(tolua_S,"getOffscreenRenderTarget",lua_ax_base_Renderer_getOffscreenRenderTarget);
        tolua_function(tolua_S,"clear",lua_ax_base_Renderer_clear);
        tolua_function(tolua_S,"getClearColor",lua_ax_base_Renderer_getClearColor);
        tolua_function(tolua_S,"getClearDepth",lua_ax_base_Renderer_getClearDepth);
        tolua_function(tolua_S,"getClearStencil",lua_ax_base_Renderer_getClearStencil);
        tolua_function(tolua_S,"getClearFlag",lua_ax_base_Renderer_getClearFlag);
        tolua_function(tolua_S,"getRenderTargetFlag",lua_ax_base_Renderer_getRenderTargetFlag);
        tolua_function(tolua_S,"setDepthTest",lua_ax_base_Renderer_setDepthTest);
        tolua_function(tolua_S,"setDepthWrite",lua_ax_base_Renderer_setDepthWrite);
        tolua_function(tolua_S,"setDepthCompareFunction",lua_ax_base_Renderer_setDepthCompareFunction);
        tolua_function(tolua_S,"getDepthTest",lua_ax_base_Renderer_getDepthTest);
        tolua_function(tolua_S,"getDepthWrite",lua_ax_base_Renderer_getDepthWrite);
        tolua_function(tolua_S,"getDepthCompareFunction",lua_ax_base_Renderer_getDepthCompareFunction);
        tolua_function(tolua_S,"setStencilTest",lua_ax_base_Renderer_setStencilTest);
        tolua_function(tolua_S,"setStencilCompareFunction",lua_ax_base_Renderer_setStencilCompareFunction);
        tolua_function(tolua_S,"setStencilOperation",lua_ax_base_Renderer_setStencilOperation);
        tolua_function(tolua_S,"setStencilWriteMask",lua_ax_base_Renderer_setStencilWriteMask);
        tolua_function(tolua_S,"getStencilTest",lua_ax_base_Renderer_getStencilTest);
        tolua_function(tolua_S,"getStencilFailureOperation",lua_ax_base_Renderer_getStencilFailureOperation);
        tolua_function(tolua_S,"getStencilPassDepthFailureOperation",lua_ax_base_Renderer_getStencilPassDepthFailureOperation);
        tolua_function(tolua_S,"getStencilDepthPassOperation",lua_ax_base_Renderer_getStencilDepthPassOperation);
        tolua_function(tolua_S,"getStencilCompareFunction",lua_ax_base_Renderer_getStencilCompareFunction);
        tolua_function(tolua_S,"getStencilReadMask",lua_ax_base_Renderer_getStencilReadMask);
        tolua_function(tolua_S,"getStencilWriteMask",lua_ax_base_Renderer_getStencilWriteMask);
        tolua_function(tolua_S,"getStencilReferenceValue",lua_ax_base_Renderer_getStencilReferenceValue);
        tolua_function(tolua_S,"setDepthStencilDesc",lua_ax_base_Renderer_setDepthStencilDesc);
        tolua_function(tolua_S,"getDepthStencilDesc",lua_ax_base_Renderer_getDepthStencilDesc);
        tolua_function(tolua_S,"setCullMode",lua_ax_base_Renderer_setCullMode);
        tolua_function(tolua_S,"getCullMode",lua_ax_base_Renderer_getCullMode);
        tolua_function(tolua_S,"setWinding",lua_ax_base_Renderer_setWinding);
        tolua_function(tolua_S,"getWinding",lua_ax_base_Renderer_getWinding);
        tolua_function(tolua_S,"setViewPort",lua_ax_base_Renderer_setViewPort);
        tolua_function(tolua_S,"getViewport",lua_ax_base_Renderer_getViewport);
        tolua_function(tolua_S,"setScissorTest",lua_ax_base_Renderer_setScissorTest);
        tolua_function(tolua_S,"setScissorRect",lua_ax_base_Renderer_setScissorRect);
        tolua_function(tolua_S,"getScissorTest",lua_ax_base_Renderer_getScissorTest);
        tolua_function(tolua_S,"getScissorRect",lua_ax_base_Renderer_getScissorRect);
        tolua_function(tolua_S,"checkVisibility",lua_ax_base_Renderer_checkVisibility);
        tolua_function(tolua_S,"readPixels",lua_ax_base_Renderer_readPixels);
        tolua_function(tolua_S,"beginRenderPass",lua_ax_base_Renderer_beginRenderPass);
        tolua_function(tolua_S,"endRenderPass",lua_ax_base_Renderer_endRenderPass);
        tolua_function(tolua_S,"nextCallbackCommand",lua_ax_base_Renderer_nextCallbackCommand);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Renderer).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Renderer";
    g_typeCast[typeName] = "ax.Renderer";
    return 1;
}

int lua_ax_base_TextureCache_getDescription(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getDescription'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getDescription'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDescription();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:getDescription",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getDescription'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_getWhiteTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getWhiteTexture'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:getWhiteTexture");

            if (!ok) { break; }
            uint16_t arg1;
            ok &= luaval_to_uint16(tolua_S, 3,&arg1, "ax.TextureCache:getWhiteTexture");

            if (!ok) { break; }
            ax::Texture2D* ret = cobj->getWhiteTexture(arg0, arg1);
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            ax::Texture2D* ret = cobj->getWhiteTexture();
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TextureCache:getWhiteTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getWhiteTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_getDummyTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getDummyTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getDummyTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getDummyTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:getDummyTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getDummyTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_addImage(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_addImage'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 2) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::backend::PixelFormat arg1;
            ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::Texture2D* ret = cobj->addImage(arg0, arg1);
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 1) {
            std::string_view arg0;
            ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::Texture2D* ret = cobj->addImage(arg0);
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            ax::Image* arg0;
            ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.TextureCache:addImage");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::Texture2D* ret = cobj->addImage(arg0, arg1);
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 3) {
            ax::Image* arg0;
            ok &= luaval_to_object<ax::Image>(tolua_S, 2, "ax.Image",&arg0, "ax.TextureCache:addImage");

            if (!ok) { break; }
            std::string_view arg1;
            ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::backend::PixelFormat arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TextureCache:addImage");

            if (!ok) { break; }
            ax::Texture2D* ret = cobj->addImage(arg0, arg1, arg2);
            object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TextureCache:addImage",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_addImage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_unbindImageAsync(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_unbindImageAsync'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:unbindImageAsync");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_unbindImageAsync'", nullptr);
            return 0;
        }
        cobj->unbindImageAsync(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:unbindImageAsync",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_unbindImageAsync'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_unbindAllImageAsync(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_unbindAllImageAsync'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_unbindAllImageAsync'", nullptr);
            return 0;
        }
        cobj->unbindAllImageAsync();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:unbindAllImageAsync",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_unbindAllImageAsync'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_getTextureForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getTextureForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:getTextureForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getTextureForKey'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureForKey(arg0);
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:getTextureForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getTextureForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_reloadTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_reloadTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:reloadTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_reloadTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->reloadTexture(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:reloadTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_reloadTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_removeAllTextures(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_removeAllTextures'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_removeAllTextures'", nullptr);
            return 0;
        }
        cobj->removeAllTextures();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:removeAllTextures",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_removeAllTextures'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_removeUnusedTextures(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_removeUnusedTextures'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_removeUnusedTextures'", nullptr);
            return 0;
        }
        cobj->removeUnusedTextures();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:removeUnusedTextures",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_removeUnusedTextures'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_removeTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_removeTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.TextureCache:removeTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_removeTexture'", nullptr);
            return 0;
        }
        cobj->removeTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:removeTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_removeTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_removeTextureForKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_removeTextureForKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:removeTextureForKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_removeTextureForKey'", nullptr);
            return 0;
        }
        cobj->removeTextureForKey(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:removeTextureForKey",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_removeTextureForKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_getCachedTextureInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getCachedTextureInfo'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getCachedTextureInfo'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCachedTextureInfo();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:getCachedTextureInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getCachedTextureInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_waitForQuit(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_waitForQuit'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_waitForQuit'", nullptr);
            return 0;
        }
        cobj->waitForQuit();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:waitForQuit",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_waitForQuit'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_getTextureFilePath(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_getTextureFilePath'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.TextureCache:getTextureFilePath");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getTextureFilePath'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureFilePath(arg0);
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:getTextureFilePath",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getTextureFilePath'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_renameTextureWithKey(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TextureCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TextureCache_renameTextureWithKey'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::string_view arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:renameTextureWithKey");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TextureCache:renameTextureWithKey");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_renameTextureWithKey'", nullptr);
            return 0;
        }
        cobj->renameTextureWithKey(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:renameTextureWithKey",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_renameTextureWithKey'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TextureCache_setETC1AlphaFileSuffix(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TextureCache:setETC1AlphaFileSuffix");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_setETC1AlphaFileSuffix'", nullptr);
            return 0;
        }
        ax::TextureCache::setETC1AlphaFileSuffix(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TextureCache:setETC1AlphaFileSuffix",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_setETC1AlphaFileSuffix'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TextureCache_getETC1AlphaFileSuffix(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TextureCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_getETC1AlphaFileSuffix'", nullptr);
            return 0;
        }
        auto&& ret = ax::TextureCache::getETC1AlphaFileSuffix();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TextureCache:getETC1AlphaFileSuffix",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_getETC1AlphaFileSuffix'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TextureCache_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TextureCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TextureCache_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TextureCache();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TextureCache");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TextureCache:TextureCache",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TextureCache_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TextureCache_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TextureCache)");
    return 0;
}

int lua_register_ax_base_TextureCache(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TextureCache");
    tolua_cclass(tolua_S,"TextureCache","ax.TextureCache","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TextureCache");
        tolua_function(tolua_S,"new",lua_ax_base_TextureCache_constructor);
        tolua_function(tolua_S,"getDescription",lua_ax_base_TextureCache_getDescription);
        tolua_function(tolua_S,"getWhiteTexture",lua_ax_base_TextureCache_getWhiteTexture);
        tolua_function(tolua_S,"getDummyTexture",lua_ax_base_TextureCache_getDummyTexture);
        tolua_function(tolua_S,"addImage",lua_ax_base_TextureCache_addImage);
        tolua_function(tolua_S,"unbindImageAsync",lua_ax_base_TextureCache_unbindImageAsync);
        tolua_function(tolua_S,"unbindAllImageAsync",lua_ax_base_TextureCache_unbindAllImageAsync);
        tolua_function(tolua_S,"getTextureForKey",lua_ax_base_TextureCache_getTextureForKey);
        tolua_function(tolua_S,"reloadTexture",lua_ax_base_TextureCache_reloadTexture);
        tolua_function(tolua_S,"removeAllTextures",lua_ax_base_TextureCache_removeAllTextures);
        tolua_function(tolua_S,"removeUnusedTextures",lua_ax_base_TextureCache_removeUnusedTextures);
        tolua_function(tolua_S,"removeTexture",lua_ax_base_TextureCache_removeTexture);
        tolua_function(tolua_S,"removeTextureForKey",lua_ax_base_TextureCache_removeTextureForKey);
        tolua_function(tolua_S,"getCachedTextureInfo",lua_ax_base_TextureCache_getCachedTextureInfo);
        tolua_function(tolua_S,"waitForQuit",lua_ax_base_TextureCache_waitForQuit);
        tolua_function(tolua_S,"getTextureFilePath",lua_ax_base_TextureCache_getTextureFilePath);
        tolua_function(tolua_S,"renameTextureWithKey",lua_ax_base_TextureCache_renameTextureWithKey);
        tolua_function(tolua_S,"setETC1AlphaFileSuffix", lua_ax_base_TextureCache_setETC1AlphaFileSuffix);
        tolua_function(tolua_S,"getETC1AlphaFileSuffix", lua_ax_base_TextureCache_getETC1AlphaFileSuffix);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TextureCache).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TextureCache";
    g_typeCast[typeName] = "ax.TextureCache";
    return 1;
}

int lua_ax_base_Device_getDPI(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_getDPI'", nullptr);
            return 0;
        }
        auto&& ret = ax::Device::getDPI();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:getDPI",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_getDPI'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_getPixelRatio(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_getPixelRatio'", nullptr);
            return 0;
        }
        auto&& ret = ax::Device::getPixelRatio();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:getPixelRatio",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_getPixelRatio'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_setAccelerometerEnabled(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Device:setAccelerometerEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_setAccelerometerEnabled'", nullptr);
            return 0;
        }
        ax::Device::setAccelerometerEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:setAccelerometerEnabled",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_setAccelerometerEnabled'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_setAccelerometerInterval(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Device:setAccelerometerInterval");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_setAccelerometerInterval'", nullptr);
            return 0;
        }
        ax::Device::setAccelerometerInterval(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:setAccelerometerInterval",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_setAccelerometerInterval'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_setKeepScreenOn(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        bool arg0;
        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.Device:setKeepScreenOn");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_setKeepScreenOn'", nullptr);
            return 0;
        }
        ax::Device::setKeepScreenOn(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:setKeepScreenOn",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_setKeepScreenOn'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_vibrate(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        double arg0;
        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Device:vibrate");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_vibrate'", nullptr);
            return 0;
        }
        ax::Device::vibrate(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:vibrate",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_vibrate'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_prepareImpactFeedbackGenerator(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Device::ImpactFeedbackStyle arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Device:prepareImpactFeedbackGenerator");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_prepareImpactFeedbackGenerator'", nullptr);
            return 0;
        }
        ax::Device::prepareImpactFeedbackGenerator(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:prepareImpactFeedbackGenerator",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_prepareImpactFeedbackGenerator'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_impactOccurred(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Device::ImpactFeedbackStyle arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Device:impactOccurred");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_impactOccurred'", nullptr);
            return 0;
        }
        ax::Device::impactOccurred(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:impactOccurred",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_impactOccurred'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_prepareNotificationFeedbackGenerator(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_prepareNotificationFeedbackGenerator'", nullptr);
            return 0;
        }
        ax::Device::prepareNotificationFeedbackGenerator();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:prepareNotificationFeedbackGenerator",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_prepareNotificationFeedbackGenerator'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_notificationOccurred(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Device::NotificationFeedbackType arg0;
        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.Device:notificationOccurred");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_notificationOccurred'", nullptr);
            return 0;
        }
        ax::Device::notificationOccurred(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:notificationOccurred",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_notificationOccurred'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_prepareSelectionFeedbackGenerator(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_prepareSelectionFeedbackGenerator'", nullptr);
            return 0;
        }
        ax::Device::prepareSelectionFeedbackGenerator();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:prepareSelectionFeedbackGenerator",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_prepareSelectionFeedbackGenerator'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_Device_selectionChanged(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Device",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Device_selectionChanged'", nullptr);
            return 0;
        }
        ax::Device::selectionChanged();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Device:selectionChanged",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Device_selectionChanged'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Device_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Device)");
    return 0;
}

int lua_register_ax_base_Device(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Device");
    tolua_cclass(tolua_S,"Device","ax.Device","",nullptr);

    tolua_beginmodule(tolua_S,"Device");
        tolua_function(tolua_S,"getDPI", lua_ax_base_Device_getDPI);
        tolua_function(tolua_S,"getPixelRatio", lua_ax_base_Device_getPixelRatio);
        tolua_function(tolua_S,"setAccelerometerEnabled", lua_ax_base_Device_setAccelerometerEnabled);
        tolua_function(tolua_S,"setAccelerometerInterval", lua_ax_base_Device_setAccelerometerInterval);
        tolua_function(tolua_S,"setKeepScreenOn", lua_ax_base_Device_setKeepScreenOn);
        tolua_function(tolua_S,"vibrate", lua_ax_base_Device_vibrate);
        tolua_function(tolua_S,"prepareImpactFeedbackGenerator", lua_ax_base_Device_prepareImpactFeedbackGenerator);
        tolua_function(tolua_S,"impactOccurred", lua_ax_base_Device_impactOccurred);
        tolua_function(tolua_S,"prepareNotificationFeedbackGenerator", lua_ax_base_Device_prepareNotificationFeedbackGenerator);
        tolua_function(tolua_S,"notificationOccurred", lua_ax_base_Device_notificationOccurred);
        tolua_function(tolua_S,"prepareSelectionFeedbackGenerator", lua_ax_base_Device_prepareSelectionFeedbackGenerator);
        tolua_function(tolua_S,"selectionChanged", lua_ax_base_Device_selectionChanged);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Device).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Device";
    g_typeCast[typeName] = "ax.Device";
    return 1;
}

int lua_ax_base_Application_setAnimationInterval(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_setAnimationInterval'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.Application:setAnimationInterval");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_setAnimationInterval'", nullptr);
            return 0;
        }
        cobj->setAnimationInterval(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:setAnimationInterval",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_setAnimationInterval'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_getCurrentLanguage(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_getCurrentLanguage'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_getCurrentLanguage'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getCurrentLanguage();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:getCurrentLanguage",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_getCurrentLanguage'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_getCurrentLanguageCode(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_getCurrentLanguageCode'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_getCurrentLanguageCode'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCurrentLanguageCode();
        tolua_pushstring(tolua_S,(const char*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:getCurrentLanguageCode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_getCurrentLanguageCode'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_getTargetPlatform(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_getTargetPlatform'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_getTargetPlatform'", nullptr);
            return 0;
        }
        int ret = (int)cobj->getTargetPlatform();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:getTargetPlatform",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_getTargetPlatform'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_getVersion(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_getVersion'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_getVersion'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getVersion();
        lua_pushlstring(tolua_S,ret.c_str(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:getVersion",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_getVersion'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_openURL(lua_State* tolua_S)
{
    int argc = 0;
    ax::Application* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::Application*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_Application_openURL'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.Application:openURL");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_openURL'", nullptr);
            return 0;
        }
        auto&& ret = cobj->openURL(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.Application:openURL",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_openURL'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_Application_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.Application",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_Application_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::Application::getInstance();
        object_to_luaval<ax::Application>(tolua_S, "ax.Application",(ax::Application*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.Application:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_Application_getInstance'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_Application_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (Application)");
    return 0;
}

int lua_register_ax_base_Application(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.Application");
    tolua_cclass(tolua_S,"Application","ax.Application","",nullptr);

    tolua_beginmodule(tolua_S,"Application");
        tolua_function(tolua_S,"setAnimationInterval",lua_ax_base_Application_setAnimationInterval);
        tolua_function(tolua_S,"getCurrentLanguage",lua_ax_base_Application_getCurrentLanguage);
        tolua_function(tolua_S,"getCurrentLanguageCode",lua_ax_base_Application_getCurrentLanguageCode);
        tolua_function(tolua_S,"getTargetPlatform",lua_ax_base_Application_getTargetPlatform);
        tolua_function(tolua_S,"getVersion",lua_ax_base_Application_getVersion);
        tolua_function(tolua_S,"openURL",lua_ax_base_Application_openURL);
        tolua_function(tolua_S,"getInstance", lua_ax_base_Application_getInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::Application).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.Application";
    g_typeCast[typeName] = "ax.Application";
    return 1;
}

int lua_ax_base_GLViewImpl_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.GLViewImpl",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLViewImpl:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLViewImpl_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLViewImpl::create(arg0);
        object_to_luaval<ax::GLViewImpl>(tolua_S, "ax.GLViewImpl",(ax::GLViewImpl*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.GLViewImpl:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLViewImpl_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_GLViewImpl_createWithRect(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.GLViewImpl",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        std::string_view arg0;
        ax::Rect arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.GLViewImpl:createWithRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLViewImpl_createWithRect'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLViewImpl::createWithRect(arg0, arg1);
        object_to_luaval<ax::GLViewImpl>(tolua_S, "ax.GLViewImpl",(ax::GLViewImpl*)ret);
        return 1;
    }
    if (argc == 3)
    {
        std::string_view arg0;
        ax::Rect arg1;
        double arg2;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.GLViewImpl:createWithRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLViewImpl_createWithRect'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLViewImpl::createWithRect(arg0, arg1, arg2);
        object_to_luaval<ax::GLViewImpl>(tolua_S, "ax.GLViewImpl",(ax::GLViewImpl*)ret);
        return 1;
    }
    if (argc == 4)
    {
        std::string_view arg0;
        ax::Rect arg1;
        double arg2;
        bool arg3;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_rect(tolua_S, 3, &arg1, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.GLViewImpl:createWithRect");
        ok &= luaval_to_boolean(tolua_S, 5,&arg3, "ax.GLViewImpl:createWithRect");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLViewImpl_createWithRect'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLViewImpl::createWithRect(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::GLViewImpl>(tolua_S, "ax.GLViewImpl",(ax::GLViewImpl*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.GLViewImpl:createWithRect",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLViewImpl_createWithRect'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_GLViewImpl_createWithFullScreen(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.GLViewImpl",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.GLViewImpl:createWithFullScreen");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_GLViewImpl_createWithFullScreen'", nullptr);
            return 0;
        }
        auto&& ret = ax::GLViewImpl::createWithFullScreen(arg0);
        object_to_luaval<ax::GLViewImpl>(tolua_S, "ax.GLViewImpl",(ax::GLViewImpl*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.GLViewImpl:createWithFullScreen",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_GLViewImpl_createWithFullScreen'.",&tolua_err);
#endif
    return 0;
}
static int lua_ax_base_GLViewImpl_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (GLViewImpl)");
    return 0;
}

int lua_register_ax_base_GLViewImpl(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.GLViewImpl");
    tolua_cclass(tolua_S,"GLViewImpl","ax.GLViewImpl","ax.GLView",nullptr);

    tolua_beginmodule(tolua_S,"GLViewImpl");
        tolua_function(tolua_S,"create", lua_ax_base_GLViewImpl_create);
        tolua_function(tolua_S,"createWithRect", lua_ax_base_GLViewImpl_createWithRect);
        tolua_function(tolua_S,"createWithFullScreen", lua_ax_base_GLViewImpl_createWithFullScreen);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::GLViewImpl).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.GLViewImpl";
    g_typeCast[typeName] = "ax.GLViewImpl";
    return 1;
}

int lua_ax_base_AnimationCache_init(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_init'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_init'", nullptr);
            return 0;
        }
        auto&& ret = cobj->init();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:init",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_init'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_addAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_addAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Animation* arg0;
        std::string_view arg1;

        ok &= luaval_to_object<ax::Animation>(tolua_S, 2, "ax.Animation",&arg0, "ax.AnimationCache:addAnimation");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.AnimationCache:addAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_addAnimation'", nullptr);
            return 0;
        }
        cobj->addAnimation(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:addAnimation",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_addAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_removeAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_removeAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AnimationCache:removeAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_removeAnimation'", nullptr);
            return 0;
        }
        cobj->removeAnimation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:removeAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_removeAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_getAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_getAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AnimationCache:getAnimation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_getAnimation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnimation(arg0);
        object_to_luaval<ax::Animation>(tolua_S, "ax.Animation",(ax::Animation*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:getAnimation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_getAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_addAnimationsWithDictionary(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_addAnimationsWithDictionary'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::ValueMap arg0;
        std::string_view arg1;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.AnimationCache:addAnimationsWithDictionary");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.AnimationCache:addAnimationsWithDictionary");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_addAnimationsWithDictionary'", nullptr);
            return 0;
        }
        cobj->addAnimationsWithDictionary(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:addAnimationsWithDictionary",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_addAnimationsWithDictionary'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_addAnimationsWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::AnimationCache*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_AnimationCache_addAnimationsWithFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.AnimationCache:addAnimationsWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_addAnimationsWithFile'", nullptr);
            return 0;
        }
        cobj->addAnimationsWithFile(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:addAnimationsWithFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_addAnimationsWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_AnimationCache_getInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_getInstance'", nullptr);
            return 0;
        }
        auto&& ret = ax::AnimationCache::getInstance();
        object_to_luaval<ax::AnimationCache>(tolua_S, "ax.AnimationCache",(ax::AnimationCache*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AnimationCache:getInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_getInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AnimationCache_destroyInstance(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.AnimationCache",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_destroyInstance'", nullptr);
            return 0;
        }
        ax::AnimationCache::destroyInstance();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.AnimationCache:destroyInstance",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_destroyInstance'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_AnimationCache_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::AnimationCache* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_AnimationCache_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::AnimationCache();
        tolua_pushusertype(tolua_S,(void*)cobj,"ax.AnimationCache");
        tolua_register_gc(tolua_S,lua_gettop(tolua_S));
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.AnimationCache:AnimationCache",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_AnimationCache_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_AnimationCache_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (AnimationCache)");
    return 0;
}

int lua_register_ax_base_AnimationCache(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.AnimationCache");
    tolua_cclass(tolua_S,"AnimationCache","ax.AnimationCache","",nullptr);

    tolua_beginmodule(tolua_S,"AnimationCache");
        tolua_function(tolua_S,"new",lua_ax_base_AnimationCache_constructor);
        tolua_function(tolua_S,"init",lua_ax_base_AnimationCache_init);
        tolua_function(tolua_S,"addAnimation",lua_ax_base_AnimationCache_addAnimation);
        tolua_function(tolua_S,"removeAnimation",lua_ax_base_AnimationCache_removeAnimation);
        tolua_function(tolua_S,"getAnimation",lua_ax_base_AnimationCache_getAnimation);
        tolua_function(tolua_S,"addAnimationsWithDictionary",lua_ax_base_AnimationCache_addAnimationsWithDictionary);
        tolua_function(tolua_S,"addAnimations",lua_ax_base_AnimationCache_addAnimationsWithFile);
        tolua_function(tolua_S,"getInstance", lua_ax_base_AnimationCache_getInstance);
        tolua_function(tolua_S,"destroyInstance", lua_ax_base_AnimationCache_destroyInstance);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::AnimationCache).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.AnimationCache";
    g_typeCast[typeName] = "ax.AnimationCache";
    return 1;
}

int lua_ax_base_SpriteBatchNode_getTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_getTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_getTextureAtlas'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTextureAtlas();
        object_to_luaval<ax::TextureAtlas>(tolua_S, "ax.TextureAtlas",(ax::TextureAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:getTextureAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_getTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_setTextureAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_setTextureAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TextureAtlas* arg0;

        ok &= luaval_to_object<ax::TextureAtlas>(tolua_S, 2, "ax.TextureAtlas",&arg0, "ax.SpriteBatchNode:setTextureAtlas");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_setTextureAtlas'", nullptr);
            return 0;
        }
        cobj->setTextureAtlas(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:setTextureAtlas",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_setTextureAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_increaseAtlasCapacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_increaseAtlasCapacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_increaseAtlasCapacity'", nullptr);
            return 0;
        }
        cobj->increaseAtlasCapacity();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:increaseAtlasCapacity",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_increaseAtlasCapacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_removeChildAtIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_removeChildAtIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ssize_t arg0;
        bool arg1;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.SpriteBatchNode:removeChildAtIndex");

        ok &= luaval_to_boolean(tolua_S, 3,&arg1, "ax.SpriteBatchNode:removeChildAtIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_removeChildAtIndex'", nullptr);
            return 0;
        }
        cobj->removeChildAtIndex(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:removeChildAtIndex",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_removeChildAtIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_appendChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_appendChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:appendChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_appendChild'", nullptr);
            return 0;
        }
        cobj->appendChild(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:appendChild",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_appendChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_removeSpriteFromAtlas(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_removeSpriteFromAtlas'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:removeSpriteFromAtlas");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_removeSpriteFromAtlas'", nullptr);
            return 0;
        }
        cobj->removeSpriteFromAtlas(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:removeSpriteFromAtlas",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_removeSpriteFromAtlas'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_rebuildIndexInOrder(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_rebuildIndexInOrder'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Sprite* arg0;
        ssize_t arg1;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:rebuildIndexInOrder");

        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:rebuildIndexInOrder");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_rebuildIndexInOrder'", nullptr);
            return 0;
        }
        auto&& ret = cobj->rebuildIndexInOrder(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:rebuildIndexInOrder",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_rebuildIndexInOrder'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_highestAtlasIndexInChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_highestAtlasIndexInChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:highestAtlasIndexInChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_highestAtlasIndexInChild'", nullptr);
            return 0;
        }
        auto&& ret = cobj->highestAtlasIndexInChild(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:highestAtlasIndexInChild",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_highestAtlasIndexInChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_lowestAtlasIndexInChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_lowestAtlasIndexInChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Sprite* arg0;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:lowestAtlasIndexInChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_lowestAtlasIndexInChild'", nullptr);
            return 0;
        }
        auto&& ret = cobj->lowestAtlasIndexInChild(arg0);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:lowestAtlasIndexInChild",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_lowestAtlasIndexInChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_atlasIndexForChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_atlasIndexForChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Sprite* arg0;
        int arg1;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:atlasIndexForChild");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.SpriteBatchNode:atlasIndexForChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_atlasIndexForChild'", nullptr);
            return 0;
        }
        auto&& ret = cobj->atlasIndexForChild(arg0, arg1);
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:atlasIndexForChild",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_atlasIndexForChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_reorderBatch(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_reorderBatch'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.SpriteBatchNode:reorderBatch");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_reorderBatch'", nullptr);
            return 0;
        }
        cobj->reorderBatch(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:reorderBatch",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_reorderBatch'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteBatchNode:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.SpriteBatchNode:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.SpriteBatchNode:removeAllChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_removeAllChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:removeAllChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_insertQuadFromSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_insertQuadFromSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Sprite* arg0;
        ssize_t arg1;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:insertQuadFromSprite");

        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:insertQuadFromSprite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_insertQuadFromSprite'", nullptr);
            return 0;
        }
        cobj->insertQuadFromSprite(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:insertQuadFromSprite",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_insertQuadFromSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_addSpriteWithoutQuad(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_addSpriteWithoutQuad'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Sprite* arg0;
        int arg1;
        int arg2;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.SpriteBatchNode:addSpriteWithoutQuad");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.SpriteBatchNode:addSpriteWithoutQuad");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.SpriteBatchNode:addSpriteWithoutQuad");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_addSpriteWithoutQuad'", nullptr);
            return 0;
        }
        auto&& ret = cobj->addSpriteWithoutQuad(arg0, arg1, arg2);
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:addSpriteWithoutQuad",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_addSpriteWithoutQuad'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_reserveCapacity(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_reserveCapacity'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ssize_t arg0;

        ok &= luaval_to_ssize_t(tolua_S, 2, &arg0, "ax.SpriteBatchNode:reserveCapacity");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_reserveCapacity'", nullptr);
            return 0;
        }
        cobj->reserveCapacity(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:reserveCapacity",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_reserveCapacity'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_initWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_initWithTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteBatchNode:initWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_initWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTexture(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        ax::Texture2D* arg0;
        ssize_t arg1;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteBatchNode:initWithTexture");

        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:initWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_initWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTexture(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:initWithTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_initWithTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_initWithFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::SpriteBatchNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_SpriteBatchNode_initWithFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteBatchNode:initWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_initWithFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    if (argc == 2) 
    {
        std::string_view arg0;
        ssize_t arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteBatchNode:initWithFile");

        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:initWithFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_initWithFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithFile(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:initWithFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_initWithFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_SpriteBatchNode_createWithTexture(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::Texture2D* arg0;
        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteBatchNode:createWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_createWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpriteBatchNode::createWithTexture(arg0);
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    if (argc == 2)
    {
        ax::Texture2D* arg0;
        ssize_t arg1;
        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.SpriteBatchNode:createWithTexture");
        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:createWithTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_createWithTexture'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpriteBatchNode::createWithTexture(arg0, arg1);
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SpriteBatchNode:createWithTexture",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_createWithTexture'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpriteBatchNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.SpriteBatchNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteBatchNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpriteBatchNode::create(arg0);
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    if (argc == 2)
    {
        std::string_view arg0;
        ssize_t arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.SpriteBatchNode:create");
        ok &= luaval_to_ssize_t(tolua_S, 3, &arg1, "ax.SpriteBatchNode:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::SpriteBatchNode::create(arg0, arg1);
        object_to_luaval<ax::SpriteBatchNode>(tolua_S, "ax.SpriteBatchNode",(ax::SpriteBatchNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.SpriteBatchNode:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_SpriteBatchNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::SpriteBatchNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_SpriteBatchNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::SpriteBatchNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.SpriteBatchNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.SpriteBatchNode:SpriteBatchNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_SpriteBatchNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_SpriteBatchNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (SpriteBatchNode)");
    return 0;
}

int lua_register_ax_base_SpriteBatchNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.SpriteBatchNode");
    tolua_cclass(tolua_S,"SpriteBatchNode","ax.SpriteBatchNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"SpriteBatchNode");
        tolua_function(tolua_S,"new",lua_ax_base_SpriteBatchNode_constructor);
        tolua_function(tolua_S,"getTextureAtlas",lua_ax_base_SpriteBatchNode_getTextureAtlas);
        tolua_function(tolua_S,"setTextureAtlas",lua_ax_base_SpriteBatchNode_setTextureAtlas);
        tolua_function(tolua_S,"increaseAtlasCapacity",lua_ax_base_SpriteBatchNode_increaseAtlasCapacity);
        tolua_function(tolua_S,"removeChildAtIndex",lua_ax_base_SpriteBatchNode_removeChildAtIndex);
        tolua_function(tolua_S,"appendChild",lua_ax_base_SpriteBatchNode_appendChild);
        tolua_function(tolua_S,"removeSpriteFromAtlas",lua_ax_base_SpriteBatchNode_removeSpriteFromAtlas);
        tolua_function(tolua_S,"rebuildIndexInOrder",lua_ax_base_SpriteBatchNode_rebuildIndexInOrder);
        tolua_function(tolua_S,"highestAtlasIndexInChild",lua_ax_base_SpriteBatchNode_highestAtlasIndexInChild);
        tolua_function(tolua_S,"lowestAtlasIndexInChild",lua_ax_base_SpriteBatchNode_lowestAtlasIndexInChild);
        tolua_function(tolua_S,"atlasIndexForChild",lua_ax_base_SpriteBatchNode_atlasIndexForChild);
        tolua_function(tolua_S,"reorderBatch",lua_ax_base_SpriteBatchNode_reorderBatch);
        tolua_function(tolua_S,"getTexture",lua_ax_base_SpriteBatchNode_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_SpriteBatchNode_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_SpriteBatchNode_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_SpriteBatchNode_getBlendFunc);
        tolua_function(tolua_S,"removeAllChildrenWithCleanup",lua_ax_base_SpriteBatchNode_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"insertQuadFromSprite",lua_ax_base_SpriteBatchNode_insertQuadFromSprite);
        tolua_function(tolua_S,"addSpriteWithoutQuad",lua_ax_base_SpriteBatchNode_addSpriteWithoutQuad);
        tolua_function(tolua_S,"reserveCapacity",lua_ax_base_SpriteBatchNode_reserveCapacity);
        tolua_function(tolua_S,"initWithTexture",lua_ax_base_SpriteBatchNode_initWithTexture);
        tolua_function(tolua_S,"initWithFile",lua_ax_base_SpriteBatchNode_initWithFile);
        tolua_function(tolua_S,"createWithTexture", lua_ax_base_SpriteBatchNode_createWithTexture);
        tolua_function(tolua_S,"create", lua_ax_base_SpriteBatchNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::SpriteBatchNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.SpriteBatchNode";
    g_typeCast[typeName] = "ax.SpriteBatchNode";
    return 1;
}

int lua_ax_base_ParallaxNode_addChild(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParallaxNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParallaxNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParallaxNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParallaxNode_addChild'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        ax::Node* arg0;
        int arg1;
        ax::Vec2 arg2;
        ax::Vec2 arg3;

        ok &= luaval_to_object<ax::Node>(tolua_S, 2, "ax.Node",&arg0, "ax.ParallaxNode:addChild");

        ok &= luaval_to_int32(tolua_S, 3,(int *)&arg1, "ax.ParallaxNode:addChild");

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.ParallaxNode:addChild");

        ok &= luaval_to_vec2(tolua_S, 5, &arg3, "ax.ParallaxNode:addChild");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParallaxNode_addChild'", nullptr);
            return 0;
        }
        cobj->addChild(arg0, arg1, arg2, arg3);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParallaxNode:addChild",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParallaxNode_addChild'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParallaxNode_removeAllChildrenWithCleanup(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParallaxNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ParallaxNode",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ParallaxNode*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ParallaxNode_removeAllChildrenWithCleanup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.ParallaxNode:removeAllChildrenWithCleanup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParallaxNode_removeAllChildrenWithCleanup'", nullptr);
            return 0;
        }
        cobj->removeAllChildrenWithCleanup(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParallaxNode:removeAllChildrenWithCleanup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParallaxNode_removeAllChildrenWithCleanup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ParallaxNode_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ParallaxNode",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 0)
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParallaxNode_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ParallaxNode::create();
        object_to_luaval<ax::ParallaxNode>(tolua_S, "ax.ParallaxNode",(ax::ParallaxNode*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ParallaxNode:create",argc, 0);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParallaxNode_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ParallaxNode_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ParallaxNode* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ParallaxNode_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ParallaxNode();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ParallaxNode");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ParallaxNode:ParallaxNode",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ParallaxNode_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ParallaxNode_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ParallaxNode)");
    return 0;
}

int lua_register_ax_base_ParallaxNode(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ParallaxNode");
    tolua_cclass(tolua_S,"ParallaxNode","ax.ParallaxNode","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"ParallaxNode");
        tolua_function(tolua_S,"new",lua_ax_base_ParallaxNode_constructor);
        tolua_function(tolua_S,"addChild",lua_ax_base_ParallaxNode_addChild);
        tolua_function(tolua_S,"removeAllChildrenWithCleanup",lua_ax_base_ParallaxNode_removeAllChildrenWithCleanup);
        tolua_function(tolua_S,"create", lua_ax_base_ParallaxNode_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ParallaxNode).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ParallaxNode";
    g_typeCast[typeName] = "ax.ParallaxNode";
    return 1;
}

int lua_ax_base_TMXObjectGroup_getGroupName(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getGroupName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_getGroupName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getGroupName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:getGroupName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getGroupName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_setGroupName(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_setGroupName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXObjectGroup:setGroupName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_setGroupName'", nullptr);
            return 0;
        }
        cobj->setGroupName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:setGroupName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_setGroupName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_getProperty(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getProperty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXObjectGroup:getProperty");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_getProperty'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProperty(arg0);
        ccvalue_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:getProperty",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getProperty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_getObject(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getObject'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXObjectGroup:getObject");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_getObject'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getObject(arg0);
        ccvaluemap_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:getObject",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getObject'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_getPositionOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getPositionOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_getPositionOffset'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionOffset();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:getPositionOffset",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getPositionOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_setPositionOffset(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_setPositionOffset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TMXObjectGroup:setPositionOffset");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_setPositionOffset'", nullptr);
            return 0;
        }
        cobj->setPositionOffset(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:setPositionOffset",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_setPositionOffset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_getProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getProperties'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXObjectGroup:getProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_setProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_setProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.TMXObjectGroup:setProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_setProperties'", nullptr);
            return 0;
        }
        cobj->setProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:setProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_setProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_getObjects(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_getObjects'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::ValueVector& ret = cobj->getObjects();
            ccvaluevector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::ValueVector& ret = cobj->getObjects();
            ccvaluevector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXObjectGroup:getObjects",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_getObjects'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_setObjects(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXObjectGroup",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXObjectGroup*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXObjectGroup_setObjects'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueVector arg0;

        ok &= luaval_to_ccvaluevector(tolua_S, 2, &arg0, "ax.TMXObjectGroup:setObjects");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_setObjects'", nullptr);
            return 0;
        }
        cobj->setObjects(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:setObjects",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_setObjects'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXObjectGroup_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXObjectGroup* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXObjectGroup_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXObjectGroup();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXObjectGroup");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXObjectGroup:TMXObjectGroup",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXObjectGroup_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXObjectGroup_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXObjectGroup)");
    return 0;
}

int lua_register_ax_base_TMXObjectGroup(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXObjectGroup");
    tolua_cclass(tolua_S,"TMXObjectGroup","ax.TMXObjectGroup","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TMXObjectGroup");
        tolua_function(tolua_S,"new",lua_ax_base_TMXObjectGroup_constructor);
        tolua_function(tolua_S,"getGroupName",lua_ax_base_TMXObjectGroup_getGroupName);
        tolua_function(tolua_S,"setGroupName",lua_ax_base_TMXObjectGroup_setGroupName);
        tolua_function(tolua_S,"getProperty",lua_ax_base_TMXObjectGroup_getProperty);
        tolua_function(tolua_S,"getObject",lua_ax_base_TMXObjectGroup_getObject);
        tolua_function(tolua_S,"getPositionOffset",lua_ax_base_TMXObjectGroup_getPositionOffset);
        tolua_function(tolua_S,"setPositionOffset",lua_ax_base_TMXObjectGroup_setPositionOffset);
        tolua_function(tolua_S,"getProperties",lua_ax_base_TMXObjectGroup_getProperties);
        tolua_function(tolua_S,"setProperties",lua_ax_base_TMXObjectGroup_setProperties);
        tolua_function(tolua_S,"getObjects",lua_ax_base_TMXObjectGroup_getObjects);
        tolua_function(tolua_S,"setObjects",lua_ax_base_TMXObjectGroup_setObjects);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXObjectGroup).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXObjectGroup";
    g_typeCast[typeName] = "ax.TMXObjectGroup";
    return 1;
}

int lua_ax_base_TMXLayerInfo_setProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXLayerInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXLayerInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXLayerInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXLayerInfo_setProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.TMXLayerInfo:setProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXLayerInfo_setProperties'", nullptr);
            return 0;
        }
        cobj->setProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXLayerInfo:setProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXLayerInfo_setProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXLayerInfo_getProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXLayerInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXLayerInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXLayerInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXLayerInfo_getProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXLayerInfo_getProperties'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProperties();
        ccvaluemap_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXLayerInfo:getProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXLayerInfo_getProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXLayerInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXLayerInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXLayerInfo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXLayerInfo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXLayerInfo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXLayerInfo:TMXLayerInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXLayerInfo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXLayerInfo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXLayerInfo)");
    return 0;
}

int lua_register_ax_base_TMXLayerInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXLayerInfo");
    tolua_cclass(tolua_S,"TMXLayerInfo","ax.TMXLayerInfo","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TMXLayerInfo");
        tolua_function(tolua_S,"new",lua_ax_base_TMXLayerInfo_constructor);
        tolua_function(tolua_S,"setProperties",lua_ax_base_TMXLayerInfo_setProperties);
        tolua_function(tolua_S,"getProperties",lua_ax_base_TMXLayerInfo_getProperties);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXLayerInfo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXLayerInfo";
    g_typeCast[typeName] = "ax.TMXLayerInfo";
    return 1;
}

int lua_ax_base_TMXTilesetInfo_getRectForGID(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTilesetInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTilesetInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTilesetInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTilesetInfo_getRectForGID'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        unsigned int arg0;

        ok &= luaval_to_uint32(tolua_S, 2,&arg0, "ax.TMXTilesetInfo:getRectForGID");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTilesetInfo_getRectForGID'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getRectForGID(arg0);
        rect_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTilesetInfo:getRectForGID",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTilesetInfo_getRectForGID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTilesetInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTilesetInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTilesetInfo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXTilesetInfo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXTilesetInfo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTilesetInfo:TMXTilesetInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTilesetInfo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXTilesetInfo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXTilesetInfo)");
    return 0;
}

int lua_register_ax_base_TMXTilesetInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXTilesetInfo");
    tolua_cclass(tolua_S,"TMXTilesetInfo","ax.TMXTilesetInfo","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TMXTilesetInfo");
        tolua_function(tolua_S,"new",lua_ax_base_TMXTilesetInfo_constructor);
        tolua_function(tolua_S,"getRectForGID",lua_ax_base_TMXTilesetInfo_getRectForGID);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXTilesetInfo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXTilesetInfo";
    g_typeCast[typeName] = "ax.TMXTilesetInfo";
    return 1;
}

int lua_ax_base_TMXMapInfo_initWithTMXFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_initWithTMXFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:initWithTMXFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_initWithTMXFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTMXFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:initWithTMXFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_initWithTMXFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_initWithXML(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_initWithXML'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::string_view arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:initWithXML");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TMXMapInfo:initWithXML");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_initWithXML'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithXML(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:initWithXML",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_initWithXML'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_parseXMLFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_parseXMLFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:parseXMLFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_parseXMLFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->parseXMLFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:parseXMLFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_parseXMLFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_parseXMLString(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_parseXMLString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:parseXMLString");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_parseXMLString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->parseXMLString(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:parseXMLString",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_parseXMLString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getTileProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getTileProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getTileProperties'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileProperties();
        ccvaluemapintkey_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getTileProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getTileProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setTileProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setTileProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMapIntKey arg0;

        ok &= luaval_to_ccvaluemapintkey(tolua_S, 2, &arg0, "ax.TMXMapInfo:setTileProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setTileProperties'", nullptr);
            return 0;
        }
        cobj->setTileProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setTileProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setTileProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getOrientation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getOrientation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getOrientation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setOrientation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setOrientation'", nullptr);
            return 0;
        }
        cobj->setOrientation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setOrientation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getStaggerAxis(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getStaggerAxis'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getStaggerAxis'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStaggerAxis();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getStaggerAxis",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getStaggerAxis'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setStaggerAxis(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setStaggerAxis'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setStaggerAxis");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setStaggerAxis'", nullptr);
            return 0;
        }
        cobj->setStaggerAxis(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setStaggerAxis",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setStaggerAxis'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getStaggerIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getStaggerIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getStaggerIndex'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStaggerIndex();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getStaggerIndex",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getStaggerIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setStaggerIndex(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setStaggerIndex'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setStaggerIndex");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setStaggerIndex'", nullptr);
            return 0;
        }
        cobj->setStaggerIndex(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setStaggerIndex",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setStaggerIndex'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getHexSideLength(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getHexSideLength'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getHexSideLength'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getHexSideLength();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getHexSideLength",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getHexSideLength'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setHexSideLength(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setHexSideLength'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setHexSideLength");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setHexSideLength'", nullptr);
            return 0;
        }
        cobj->setHexSideLength(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setHexSideLength",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setHexSideLength'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getMapSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getMapSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getMapSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMapSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getMapSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getMapSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setMapSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setMapSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TMXMapInfo:setMapSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setMapSize'", nullptr);
            return 0;
        }
        cobj->setMapSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setMapSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setMapSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getTileSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getTileSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TMXMapInfo:setTileSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setTileSize'", nullptr);
            return 0;
        }
        cobj->setTileSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setTileSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getLayers(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getLayers'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::Vector<ax::TMXLayerInfo *>& ret = cobj->getLayers();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::Vector<ax::TMXLayerInfo *>& ret = cobj->getLayers();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXMapInfo:getLayers",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getLayers'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setLayers(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setLayers'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::TMXLayerInfo *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.TMXMapInfo:setLayers");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setLayers'", nullptr);
            return 0;
        }
        cobj->setLayers(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setLayers",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setLayers'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getTilesets(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getTilesets'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::Vector<ax::TMXTilesetInfo *>& ret = cobj->getTilesets();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::Vector<ax::TMXTilesetInfo *>& ret = cobj->getTilesets();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXMapInfo:getTilesets",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getTilesets'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setTilesets(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setTilesets'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::TMXTilesetInfo *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.TMXMapInfo:setTilesets");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setTilesets'", nullptr);
            return 0;
        }
        cobj->setTilesets(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setTilesets",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setTilesets'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getObjectGroups(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getObjectGroups'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::Vector<ax::TMXObjectGroup *>& ret = cobj->getObjectGroups();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::Vector<ax::TMXObjectGroup *>& ret = cobj->getObjectGroups();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXMapInfo:getObjectGroups",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getObjectGroups'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setObjectGroups(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setObjectGroups'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::TMXObjectGroup *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.TMXMapInfo:setObjectGroups");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setObjectGroups'", nullptr);
            return 0;
        }
        cobj->setObjectGroups(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setObjectGroups",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setObjectGroups'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getParentElement(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getParentElement'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getParentElement'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getParentElement();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getParentElement",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getParentElement'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setParentElement(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setParentElement'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setParentElement");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setParentElement'", nullptr);
            return 0;
        }
        cobj->setParentElement(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setParentElement",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setParentElement'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getParentGID(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getParentGID'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getParentGID'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getParentGID();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getParentGID",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getParentGID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setParentGID(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setParentGID'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setParentGID");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setParentGID'", nullptr);
            return 0;
        }
        cobj->setParentGID(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setParentGID",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setParentGID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getLayerAttribs(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getLayerAttribs'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getLayerAttribs'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayerAttribs();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getLayerAttribs",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getLayerAttribs'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setLayerAttribs(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setLayerAttribs'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.TMXMapInfo:setLayerAttribs");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setLayerAttribs'", nullptr);
            return 0;
        }
        cobj->setLayerAttribs(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setLayerAttribs",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setLayerAttribs'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_isStoringCharacters(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_isStoringCharacters'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_isStoringCharacters'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStoringCharacters();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:isStoringCharacters",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_isStoringCharacters'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setStoringCharacters(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setStoringCharacters'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.TMXMapInfo:setStoringCharacters");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setStoringCharacters'", nullptr);
            return 0;
        }
        cobj->setStoringCharacters(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setStoringCharacters",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setStoringCharacters'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getProperties'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.TMXMapInfo:getProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.TMXMapInfo:setProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setProperties'", nullptr);
            return 0;
        }
        cobj->setProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getCurrentString(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getCurrentString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getCurrentString'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getCurrentString();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getCurrentString",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getCurrentString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setCurrentString(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setCurrentString'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:setCurrentString");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setCurrentString'", nullptr);
            return 0;
        }
        cobj->setCurrentString(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setCurrentString",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setCurrentString'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getTMXFileName(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getTMXFileName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getTMXFileName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTMXFileName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getTMXFileName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getTMXFileName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_setTMXFileName(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_setTMXFileName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:setTMXFileName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_setTMXFileName'", nullptr);
            return 0;
        }
        cobj->setTMXFileName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:setTMXFileName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_setTMXFileName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_getExternalTilesetFileName(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXMapInfo*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXMapInfo_getExternalTilesetFileName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_getExternalTilesetFileName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getExternalTilesetFileName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:getExternalTilesetFileName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_getExternalTilesetFileName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXMapInfo_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TMXMapInfo::create(arg0);
        object_to_luaval<ax::TMXMapInfo>(tolua_S, "ax.TMXMapInfo",(ax::TMXMapInfo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TMXMapInfo:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TMXMapInfo_createWithXML(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TMXMapInfo",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        std::string_view arg0;
        std::string_view arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TMXMapInfo:createWithXML");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TMXMapInfo:createWithXML");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_createWithXML'", nullptr);
            return 0;
        }
        auto&& ret = ax::TMXMapInfo::createWithXML(arg0, arg1);
        object_to_luaval<ax::TMXMapInfo>(tolua_S, "ax.TMXMapInfo",(ax::TMXMapInfo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TMXMapInfo:createWithXML",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_createWithXML'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TMXMapInfo_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXMapInfo* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXMapInfo_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXMapInfo();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXMapInfo");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXMapInfo:TMXMapInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXMapInfo_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXMapInfo_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXMapInfo)");
    return 0;
}

int lua_register_ax_base_TMXMapInfo(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXMapInfo");
    tolua_cclass(tolua_S,"TMXMapInfo","ax.TMXMapInfo","",nullptr);

    tolua_beginmodule(tolua_S,"TMXMapInfo");
        tolua_function(tolua_S,"new",lua_ax_base_TMXMapInfo_constructor);
        tolua_function(tolua_S,"initWithTMXFile",lua_ax_base_TMXMapInfo_initWithTMXFile);
        tolua_function(tolua_S,"initWithXML",lua_ax_base_TMXMapInfo_initWithXML);
        tolua_function(tolua_S,"parseXMLFile",lua_ax_base_TMXMapInfo_parseXMLFile);
        tolua_function(tolua_S,"parseXMLString",lua_ax_base_TMXMapInfo_parseXMLString);
        tolua_function(tolua_S,"getTileProperties",lua_ax_base_TMXMapInfo_getTileProperties);
        tolua_function(tolua_S,"setTileProperties",lua_ax_base_TMXMapInfo_setTileProperties);
        tolua_function(tolua_S,"getOrientation",lua_ax_base_TMXMapInfo_getOrientation);
        tolua_function(tolua_S,"setOrientation",lua_ax_base_TMXMapInfo_setOrientation);
        tolua_function(tolua_S,"getStaggerAxis",lua_ax_base_TMXMapInfo_getStaggerAxis);
        tolua_function(tolua_S,"setStaggerAxis",lua_ax_base_TMXMapInfo_setStaggerAxis);
        tolua_function(tolua_S,"getStaggerIndex",lua_ax_base_TMXMapInfo_getStaggerIndex);
        tolua_function(tolua_S,"setStaggerIndex",lua_ax_base_TMXMapInfo_setStaggerIndex);
        tolua_function(tolua_S,"getHexSideLength",lua_ax_base_TMXMapInfo_getHexSideLength);
        tolua_function(tolua_S,"setHexSideLength",lua_ax_base_TMXMapInfo_setHexSideLength);
        tolua_function(tolua_S,"getMapSize",lua_ax_base_TMXMapInfo_getMapSize);
        tolua_function(tolua_S,"setMapSize",lua_ax_base_TMXMapInfo_setMapSize);
        tolua_function(tolua_S,"getTileSize",lua_ax_base_TMXMapInfo_getTileSize);
        tolua_function(tolua_S,"setTileSize",lua_ax_base_TMXMapInfo_setTileSize);
        tolua_function(tolua_S,"getLayers",lua_ax_base_TMXMapInfo_getLayers);
        tolua_function(tolua_S,"setLayers",lua_ax_base_TMXMapInfo_setLayers);
        tolua_function(tolua_S,"getTilesets",lua_ax_base_TMXMapInfo_getTilesets);
        tolua_function(tolua_S,"setTilesets",lua_ax_base_TMXMapInfo_setTilesets);
        tolua_function(tolua_S,"getObjectGroups",lua_ax_base_TMXMapInfo_getObjectGroups);
        tolua_function(tolua_S,"setObjectGroups",lua_ax_base_TMXMapInfo_setObjectGroups);
        tolua_function(tolua_S,"getParentElement",lua_ax_base_TMXMapInfo_getParentElement);
        tolua_function(tolua_S,"setParentElement",lua_ax_base_TMXMapInfo_setParentElement);
        tolua_function(tolua_S,"getParentGID",lua_ax_base_TMXMapInfo_getParentGID);
        tolua_function(tolua_S,"setParentGID",lua_ax_base_TMXMapInfo_setParentGID);
        tolua_function(tolua_S,"getLayerAttribs",lua_ax_base_TMXMapInfo_getLayerAttribs);
        tolua_function(tolua_S,"setLayerAttribs",lua_ax_base_TMXMapInfo_setLayerAttribs);
        tolua_function(tolua_S,"isStoringCharacters",lua_ax_base_TMXMapInfo_isStoringCharacters);
        tolua_function(tolua_S,"setStoringCharacters",lua_ax_base_TMXMapInfo_setStoringCharacters);
        tolua_function(tolua_S,"getProperties",lua_ax_base_TMXMapInfo_getProperties);
        tolua_function(tolua_S,"setProperties",lua_ax_base_TMXMapInfo_setProperties);
        tolua_function(tolua_S,"getCurrentString",lua_ax_base_TMXMapInfo_getCurrentString);
        tolua_function(tolua_S,"setCurrentString",lua_ax_base_TMXMapInfo_setCurrentString);
        tolua_function(tolua_S,"getTMXFileName",lua_ax_base_TMXMapInfo_getTMXFileName);
        tolua_function(tolua_S,"setTMXFileName",lua_ax_base_TMXMapInfo_setTMXFileName);
        tolua_function(tolua_S,"getExternalTilesetFileName",lua_ax_base_TMXMapInfo_getExternalTilesetFileName);
        tolua_function(tolua_S,"create", lua_ax_base_TMXMapInfo_create);
        tolua_function(tolua_S,"createWithXML", lua_ax_base_TMXMapInfo_createWithXML);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXMapInfo).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXMapInfo";
    g_typeCast[typeName] = "ax.TMXMapInfo";
    return 1;
}

int lua_ax_base_TileMapAtlas_initWithTileFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TileMapAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TileMapAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TileMapAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TileMapAtlas_initWithTileFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 4) 
    {
        std::string_view arg0;
        std::string_view arg1;
        int arg2;
        int arg3;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TileMapAtlas:initWithTileFile");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TileMapAtlas:initWithTileFile");

        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TileMapAtlas:initWithTileFile");

        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.TileMapAtlas:initWithTileFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_initWithTileFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TileMapAtlas:initWithTileFile",argc, 4);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_initWithTileFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TileMapAtlas_getTileAt(lua_State* tolua_S)
{
    int argc = 0;
    ax::TileMapAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TileMapAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TileMapAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TileMapAtlas_getTileAt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.TileMapAtlas:getTileAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_getTileAt'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileAt(arg0);
        color3b_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TileMapAtlas:getTileAt",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_getTileAt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TileMapAtlas_setTile(lua_State* tolua_S)
{
    int argc = 0;
    ax::TileMapAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TileMapAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TileMapAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TileMapAtlas_setTile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        ax::Color3B arg0;
        ax::Vec2 arg1;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.TileMapAtlas:setTile");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.TileMapAtlas:setTile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_setTile'", nullptr);
            return 0;
        }
        cobj->setTile(arg0, arg1);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TileMapAtlas:setTile",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_setTile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TileMapAtlas_releaseMap(lua_State* tolua_S)
{
    int argc = 0;
    ax::TileMapAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TileMapAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TileMapAtlas*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TileMapAtlas_releaseMap'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_releaseMap'", nullptr);
            return 0;
        }
        cobj->releaseMap();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TileMapAtlas:releaseMap",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_releaseMap'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TileMapAtlas_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TileMapAtlas",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 4)
    {
        std::string_view arg0;
        std::string_view arg1;
        int arg2;
        int arg3;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.TileMapAtlas:create");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.TileMapAtlas:create");
        ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.TileMapAtlas:create");
        ok &= luaval_to_int32(tolua_S, 5,(int *)&arg3, "ax.TileMapAtlas:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TileMapAtlas::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::TileMapAtlas>(tolua_S, "ax.TileMapAtlas",(ax::TileMapAtlas*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TileMapAtlas:create",argc, 4);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TileMapAtlas_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TileMapAtlas* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TileMapAtlas_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TileMapAtlas();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TileMapAtlas");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TileMapAtlas:TileMapAtlas",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TileMapAtlas_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TileMapAtlas_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TileMapAtlas)");
    return 0;
}

int lua_register_ax_base_TileMapAtlas(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TileMapAtlas");
    tolua_cclass(tolua_S,"TileMapAtlas","ax.TileMapAtlas","ax.AtlasNode",nullptr);

    tolua_beginmodule(tolua_S,"TileMapAtlas");
        tolua_function(tolua_S,"new",lua_ax_base_TileMapAtlas_constructor);
        tolua_function(tolua_S,"initWithTileFile",lua_ax_base_TileMapAtlas_initWithTileFile);
        tolua_function(tolua_S,"getTileAt",lua_ax_base_TileMapAtlas_getTileAt);
        tolua_function(tolua_S,"setTile",lua_ax_base_TileMapAtlas_setTile);
        tolua_function(tolua_S,"releaseMap",lua_ax_base_TileMapAtlas_releaseMap);
        tolua_function(tolua_S,"create", lua_ax_base_TileMapAtlas_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TileMapAtlas).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TileMapAtlas";
    g_typeCast[typeName] = "ax.TileMapAtlas";
    return 1;
}

int lua_ax_base_FastTMXLayer_setTileGID(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setTileGID'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 3) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.FastTMXLayer:setTileGID");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FastTMXLayer:setTileGID");

            if (!ok) { break; }
            ax::TMXTileFlags_ arg2;
            ok &= luaval_to_int32(tolua_S, 4,(int *)&arg2, "ax.FastTMXLayer:setTileGID");

            if (!ok) { break; }
            cobj->setTileGID(arg0, arg1, arg2);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 2) {
            int arg0;
            ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.FastTMXLayer:setTileGID");

            if (!ok) { break; }
            ax::Vec2 arg1;
            ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FastTMXLayer:setTileGID");

            if (!ok) { break; }
            cobj->setTileGID(arg0, arg1);
            lua_settop(tolua_S, 1);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FastTMXLayer:setTileGID",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setTileGID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_removeTileAt(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_removeTileAt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXLayer:removeTileAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_removeTileAt'", nullptr);
            return 0;
        }
        cobj->removeTileAt(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:removeTileAt",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_removeTileAt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getPositionAt(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getPositionAt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXLayer:getPositionAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getPositionAt'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPositionAt(arg0);
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getPositionAt",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getPositionAt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getProperty(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getProperty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXLayer:getProperty");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getProperty'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProperty(arg0);
        ccvalue_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getProperty",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getProperty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setupTiles(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setupTiles'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setupTiles'", nullptr);
            return 0;
        }
        cobj->setupTiles();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setupTiles",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setupTiles'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getLayerName(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getLayerName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getLayerName'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayerName();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getLayerName",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getLayerName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setLayerName(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setLayerName'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXLayer:setLayerName");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setLayerName'", nullptr);
            return 0;
        }
        cobj->setLayerName(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setLayerName",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setLayerName'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getLayerSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getLayerSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getLayerSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayerSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getLayerSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getLayerSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setLayerSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setLayerSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXLayer:setLayerSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setLayerSize'", nullptr);
            return 0;
        }
        cobj->setLayerSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setLayerSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setLayerSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getMapTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getMapTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getMapTileSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMapTileSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getMapTileSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getMapTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setMapTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setMapTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXLayer:setMapTileSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setMapTileSize'", nullptr);
            return 0;
        }
        cobj->setMapTileSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setMapTileSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setMapTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getTileSet(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getTileSet'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getTileSet'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileSet();
        object_to_luaval<ax::TMXTilesetInfo>(tolua_S, "ax.TMXTilesetInfo",(ax::TMXTilesetInfo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getTileSet",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getTileSet'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setTileSet(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setTileSet'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::TMXTilesetInfo* arg0;

        ok &= luaval_to_object<ax::TMXTilesetInfo>(tolua_S, 2, "ax.TMXTilesetInfo",&arg0, "ax.FastTMXLayer:setTileSet");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setTileSet'", nullptr);
            return 0;
        }
        cobj->setTileSet(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setTileSet",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setTileSet'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getLayerOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getLayerOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getLayerOrientation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayerOrientation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getLayerOrientation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getLayerOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setLayerOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setLayerOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.FastTMXLayer:setLayerOrientation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setLayerOrientation'", nullptr);
            return 0;
        }
        cobj->setLayerOrientation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setLayerOrientation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setLayerOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getProperties'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::ValueMap& ret = cobj->getProperties();
            ccvaluemap_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FastTMXLayer:getProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.FastTMXLayer:setProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setProperties'", nullptr);
            return 0;
        }
        cobj->setProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getTileAt(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getTileAt'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXLayer:getTileAt");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getTileAt'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileAt(arg0);
        object_to_luaval<ax::Sprite>(tolua_S, "ax.Sprite",(ax::Sprite*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getTileAt",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getTileAt'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_setupTileSprite(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_setupTileSprite'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::Sprite* arg0;
        ax::Vec2 arg1;
        unsigned int arg2;

        ok &= luaval_to_object<ax::Sprite>(tolua_S, 2, "ax.Sprite",&arg0, "ax.FastTMXLayer:setupTileSprite");

        ok &= luaval_to_vec2(tolua_S, 3, &arg1, "ax.FastTMXLayer:setupTileSprite");

        ok &= luaval_to_uint32(tolua_S, 4,&arg2, "ax.FastTMXLayer:setupTileSprite");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_setupTileSprite'", nullptr);
            return 0;
        }
        cobj->setupTileSprite(arg0, arg1, arg2);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:setupTileSprite",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_setupTileSprite'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getAnimTileCoord(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getAnimTileCoord'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getAnimTileCoord'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getAnimTileCoord();
        object_to_luaval<std::unordered_map<unsigned int, std::vector<ax::TMXTileAnimFlag>>>(tolua_S, "std::unordered_map<unsigned int, std::vector<ax::TMXTileAnimFlag>>*",(std::unordered_map<unsigned int, std::vector<ax::TMXTileAnimFlag>>*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getAnimTileCoord",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getAnimTileCoord'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_hasTileAnimation(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_hasTileAnimation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_hasTileAnimation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->hasTileAnimation();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:hasTileAnimation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_hasTileAnimation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_getTileAnimManager(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_getTileAnimManager'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_getTileAnimManager'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileAnimManager();
        object_to_luaval<ax::TMXTileAnimManager>(tolua_S, "ax.TMXTileAnimManager",(ax::TMXTileAnimManager*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:getTileAnimManager",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_getTileAnimManager'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_initWithTilesetInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXLayer*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXLayer_initWithTilesetInfo'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::TMXTilesetInfo* arg0;
        ax::TMXLayerInfo* arg1;
        ax::TMXMapInfo* arg2;

        ok &= luaval_to_object<ax::TMXTilesetInfo>(tolua_S, 2, "ax.TMXTilesetInfo",&arg0, "ax.FastTMXLayer:initWithTilesetInfo");

        ok &= luaval_to_object<ax::TMXLayerInfo>(tolua_S, 3, "ax.TMXLayerInfo",&arg1, "ax.FastTMXLayer:initWithTilesetInfo");

        ok &= luaval_to_object<ax::TMXMapInfo>(tolua_S, 4, "ax.TMXMapInfo",&arg2, "ax.FastTMXLayer:initWithTilesetInfo");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_initWithTilesetInfo'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTilesetInfo(arg0, arg1, arg2);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:initWithTilesetInfo",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_initWithTilesetInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXLayer_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FastTMXLayer",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::TMXTilesetInfo* arg0;
        ax::TMXLayerInfo* arg1;
        ax::TMXMapInfo* arg2;
        ok &= luaval_to_object<ax::TMXTilesetInfo>(tolua_S, 2, "ax.TMXTilesetInfo",&arg0, "ax.FastTMXLayer:create");
        ok &= luaval_to_object<ax::TMXLayerInfo>(tolua_S, 3, "ax.TMXLayerInfo",&arg1, "ax.FastTMXLayer:create");
        ok &= luaval_to_object<ax::TMXMapInfo>(tolua_S, 4, "ax.TMXMapInfo",&arg2, "ax.FastTMXLayer:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FastTMXLayer::create(arg0, arg1, arg2);
        object_to_luaval<ax::FastTMXLayer>(tolua_S, "ax.FastTMXLayer",(ax::FastTMXLayer*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FastTMXLayer:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FastTMXLayer_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXLayer* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXLayer_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FastTMXLayer();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FastTMXLayer");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXLayer:FastTMXLayer",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXLayer_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FastTMXLayer_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FastTMXLayer)");
    return 0;
}

int lua_register_ax_base_FastTMXLayer(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FastTMXLayer");
    tolua_cclass(tolua_S,"FastTMXLayer","ax.FastTMXLayer","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"FastTMXLayer");
        tolua_function(tolua_S,"new",lua_ax_base_FastTMXLayer_constructor);
        tolua_function(tolua_S,"setTileGID",lua_ax_base_FastTMXLayer_setTileGID);
        tolua_function(tolua_S,"removeTileAt",lua_ax_base_FastTMXLayer_removeTileAt);
        tolua_function(tolua_S,"getPositionAt",lua_ax_base_FastTMXLayer_getPositionAt);
        tolua_function(tolua_S,"getProperty",lua_ax_base_FastTMXLayer_getProperty);
        tolua_function(tolua_S,"setupTiles",lua_ax_base_FastTMXLayer_setupTiles);
        tolua_function(tolua_S,"getLayerName",lua_ax_base_FastTMXLayer_getLayerName);
        tolua_function(tolua_S,"setLayerName",lua_ax_base_FastTMXLayer_setLayerName);
        tolua_function(tolua_S,"getLayerSize",lua_ax_base_FastTMXLayer_getLayerSize);
        tolua_function(tolua_S,"setLayerSize",lua_ax_base_FastTMXLayer_setLayerSize);
        tolua_function(tolua_S,"getMapTileSize",lua_ax_base_FastTMXLayer_getMapTileSize);
        tolua_function(tolua_S,"setMapTileSize",lua_ax_base_FastTMXLayer_setMapTileSize);
        tolua_function(tolua_S,"getTileSet",lua_ax_base_FastTMXLayer_getTileSet);
        tolua_function(tolua_S,"setTileSet",lua_ax_base_FastTMXLayer_setTileSet);
        tolua_function(tolua_S,"getLayerOrientation",lua_ax_base_FastTMXLayer_getLayerOrientation);
        tolua_function(tolua_S,"setLayerOrientation",lua_ax_base_FastTMXLayer_setLayerOrientation);
        tolua_function(tolua_S,"getProperties",lua_ax_base_FastTMXLayer_getProperties);
        tolua_function(tolua_S,"setProperties",lua_ax_base_FastTMXLayer_setProperties);
        tolua_function(tolua_S,"getTileAt",lua_ax_base_FastTMXLayer_getTileAt);
        tolua_function(tolua_S,"setupTileSprite",lua_ax_base_FastTMXLayer_setupTileSprite);
        tolua_function(tolua_S,"getAnimTileCoord",lua_ax_base_FastTMXLayer_getAnimTileCoord);
        tolua_function(tolua_S,"hasTileAnimation",lua_ax_base_FastTMXLayer_hasTileAnimation);
        tolua_function(tolua_S,"getTileAnimManager",lua_ax_base_FastTMXLayer_getTileAnimManager);
        tolua_function(tolua_S,"initWithTilesetInfo",lua_ax_base_FastTMXLayer_initWithTilesetInfo);
        tolua_function(tolua_S,"create", lua_ax_base_FastTMXLayer_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FastTMXLayer).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FastTMXLayer";
    g_typeCast[typeName] = "ax.FastTMXLayer";
    return 1;
}

int lua_ax_base_TMXTileAnimTask_start(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimTask* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimTask",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimTask*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimTask_start'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_start'", nullptr);
            return 0;
        }
        cobj->start();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimTask:start",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimTask_start'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimTask_stop(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimTask* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimTask",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimTask*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimTask_stop'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_stop'", nullptr);
            return 0;
        }
        cobj->stop();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimTask:stop",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimTask_stop'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimTask_isRunning(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimTask* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimTask",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimTask*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimTask_isRunning'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_isRunning'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isRunning();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimTask:isRunning",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimTask_isRunning'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimTask_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TMXTileAnimTask",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 3)
    {
        ax::FastTMXLayer* arg0;
        ax::TMXTileAnimInfo* arg1;
        ax::Vec2 arg2;
        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimTask:create");
        #pragma warning NO CONVERSION TO NATIVE FOR TMXTileAnimInfo*
		ok = false;
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.TMXTileAnimTask:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TMXTileAnimTask::create(arg0, arg1, arg2);
        object_to_luaval<ax::TMXTileAnimTask>(tolua_S, "ax.TMXTileAnimTask",(ax::TMXTileAnimTask*)ret);
        return 1;
    }
    if (argc == 4)
    {
        ax::FastTMXLayer* arg0;
        ax::TMXTileAnimInfo* arg1;
        ax::Vec2 arg2;
        unsigned int arg3;
        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimTask:create");
        #pragma warning NO CONVERSION TO NATIVE FOR TMXTileAnimInfo*
		ok = false;
        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.TMXTileAnimTask:create");
        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.TMXTileAnimTask:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TMXTileAnimTask::create(arg0, arg1, arg2, arg3);
        object_to_luaval<ax::TMXTileAnimTask>(tolua_S, "ax.TMXTileAnimTask",(ax::TMXTileAnimTask*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TMXTileAnimTask:create",argc, 3);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimTask_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TMXTileAnimTask_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimTask* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 3) 
    {
        ax::FastTMXLayer* arg0;
        ax::TMXTileAnimInfo* arg1;
        ax::Vec2 arg2;

        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimTask:TMXTileAnimTask");

        #pragma warning NO CONVERSION TO NATIVE FOR TMXTileAnimInfo*
		ok = false;

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.TMXTileAnimTask:TMXTileAnimTask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXTileAnimTask(arg0, arg1, arg2);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXTileAnimTask");
        return 1;
    }
    if (argc == 4) 
    {
        ax::FastTMXLayer* arg0;
        ax::TMXTileAnimInfo* arg1;
        ax::Vec2 arg2;
        unsigned int arg3;

        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimTask:TMXTileAnimTask");

        #pragma warning NO CONVERSION TO NATIVE FOR TMXTileAnimInfo*
		ok = false;

        ok &= luaval_to_vec2(tolua_S, 4, &arg2, "ax.TMXTileAnimTask:TMXTileAnimTask");

        ok &= luaval_to_uint32(tolua_S, 5,&arg3, "ax.TMXTileAnimTask:TMXTileAnimTask");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimTask_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXTileAnimTask(arg0, arg1, arg2, arg3);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXTileAnimTask");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimTask:TMXTileAnimTask",argc, 3);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimTask_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXTileAnimTask_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXTileAnimTask)");
    return 0;
}

int lua_register_ax_base_TMXTileAnimTask(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXTileAnimTask");
    tolua_cclass(tolua_S,"TMXTileAnimTask","ax.TMXTileAnimTask","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TMXTileAnimTask");
        tolua_function(tolua_S,"new",lua_ax_base_TMXTileAnimTask_constructor);
        tolua_function(tolua_S,"start",lua_ax_base_TMXTileAnimTask_start);
        tolua_function(tolua_S,"stop",lua_ax_base_TMXTileAnimTask_stop);
        tolua_function(tolua_S,"isRunning",lua_ax_base_TMXTileAnimTask_isRunning);
        tolua_function(tolua_S,"create", lua_ax_base_TMXTileAnimTask_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXTileAnimTask).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXTileAnimTask";
    g_typeCast[typeName] = "ax.TMXTileAnimTask";
    return 1;
}

int lua_ax_base_TMXTileAnimManager_startAll(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimManager_startAll'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimManager_startAll'", nullptr);
            return 0;
        }
        cobj->startAll();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimManager:startAll",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimManager_startAll'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimManager_stopAll(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimManager_stopAll'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimManager_stopAll'", nullptr);
            return 0;
        }
        cobj->stopAll();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimManager:stopAll",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimManager_stopAll'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimManager_getTasks(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.TMXTileAnimManager",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::TMXTileAnimManager*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_TMXTileAnimManager_getTasks'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimManager_getTasks'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTasks();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimManager:getTasks",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimManager_getTasks'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_TMXTileAnimManager_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.TMXTileAnimManager",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        ax::FastTMXLayer* arg0;
        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimManager:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimManager_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::TMXTileAnimManager::create(arg0);
        object_to_luaval<ax::TMXTileAnimManager>(tolua_S, "ax.TMXTileAnimManager",(ax::TMXTileAnimManager*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.TMXTileAnimManager:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimManager_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_TMXTileAnimManager_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::TMXTileAnimManager* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::FastTMXLayer* arg0;

        ok &= luaval_to_object<ax::FastTMXLayer>(tolua_S, 2, "ax.FastTMXLayer",&arg0, "ax.TMXTileAnimManager:TMXTileAnimManager");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_TMXTileAnimManager_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::TMXTileAnimManager(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.TMXTileAnimManager");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.TMXTileAnimManager:TMXTileAnimManager",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_TMXTileAnimManager_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_TMXTileAnimManager_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (TMXTileAnimManager)");
    return 0;
}

int lua_register_ax_base_TMXTileAnimManager(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.TMXTileAnimManager");
    tolua_cclass(tolua_S,"TMXTileAnimManager","ax.TMXTileAnimManager","ax.Object",nullptr);

    tolua_beginmodule(tolua_S,"TMXTileAnimManager");
        tolua_function(tolua_S,"new",lua_ax_base_TMXTileAnimManager_constructor);
        tolua_function(tolua_S,"startAll",lua_ax_base_TMXTileAnimManager_startAll);
        tolua_function(tolua_S,"stopAll",lua_ax_base_TMXTileAnimManager_stopAll);
        tolua_function(tolua_S,"getTasks",lua_ax_base_TMXTileAnimManager_getTasks);
        tolua_function(tolua_S,"create", lua_ax_base_TMXTileAnimManager_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::TMXTileAnimManager).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.TMXTileAnimManager";
    g_typeCast[typeName] = "ax.TMXTileAnimManager";
    return 1;
}

int lua_ax_base_FastTMXTiledMap_getLayer(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getLayer'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:getLayer");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getLayer'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayer(arg0);
        object_to_luaval<ax::FastTMXLayer>(tolua_S, "ax.FastTMXLayer",(ax::FastTMXLayer*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getLayer",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getLayer'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getObjectGroup(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getObjectGroup'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:getObjectGroup");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getObjectGroup'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getObjectGroup(arg0);
        object_to_luaval<ax::TMXObjectGroup>(tolua_S, "ax.TMXObjectGroup",(ax::TMXObjectGroup*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getObjectGroup",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getObjectGroup'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getProperty(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getProperty'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:getProperty");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getProperty'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProperty(arg0);
        ccvalue_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getProperty",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getProperty'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getPropertiesForGID(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getPropertiesForGID'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.FastTMXTiledMap:getPropertiesForGID");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getPropertiesForGID'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getPropertiesForGID(arg0);
        ccvalue_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getPropertiesForGID",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getPropertiesForGID'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getMapSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getMapSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getMapSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMapSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getMapSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getMapSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setMapSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setMapSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXTiledMap:setMapSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setMapSize'", nullptr);
            return 0;
        }
        cobj->setMapSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setMapSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setMapSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getTileSize'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTileSize();
        vec2_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getTileSize",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setTileSize(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setTileSize'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec2 arg0;

        ok &= luaval_to_vec2(tolua_S, 2, &arg0, "ax.FastTMXTiledMap:setTileSize");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setTileSize'", nullptr);
            return 0;
        }
        cobj->setTileSize(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setTileSize",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setTileSize'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getMapOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getMapOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getMapOrientation'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMapOrientation();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getMapOrientation",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getMapOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setMapOrientation(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setMapOrientation'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        int arg0;

        ok &= luaval_to_int32(tolua_S, 2,(int *)&arg0, "ax.FastTMXTiledMap:setMapOrientation");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setMapOrientation'", nullptr);
            return 0;
        }
        cobj->setMapOrientation(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setMapOrientation",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setMapOrientation'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getObjectGroups(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getObjectGroups'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 0) {
            ax::Vector<ax::TMXObjectGroup *>& ret = cobj->getObjectGroups();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 0) {
            const ax::Vector<ax::TMXObjectGroup *>& ret = cobj->getObjectGroups();
            ccvector_to_luaval(tolua_S, ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.FastTMXTiledMap:getObjectGroups",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getObjectGroups'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setObjectGroups(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setObjectGroups'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vector<ax::TMXObjectGroup *> arg0;

        ok &= luaval_to_ccvector(tolua_S, 2, &arg0, "ax.FastTMXTiledMap:setObjectGroups");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setObjectGroups'", nullptr);
            return 0;
        }
        cobj->setObjectGroups(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setObjectGroups",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setObjectGroups'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getProperties'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getProperties();
        ccvaluemap_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getProperties",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setProperties(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setProperties'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::ValueMap arg0;

        ok &= luaval_to_ccvaluemap(tolua_S, 2, &arg0, "ax.FastTMXTiledMap:setProperties");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setProperties'", nullptr);
            return 0;
        }
        cobj->setProperties(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setProperties",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setProperties'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_setTileAnimEnabled(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_setTileAnimEnabled'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:setTileAnimEnabled");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_setTileAnimEnabled'", nullptr);
            return 0;
        }
        cobj->setTileAnimEnabled(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:setTileAnimEnabled",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_setTileAnimEnabled'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getLayerCount(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getLayerCount'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getLayerCount'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayerCount();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getLayerCount",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getLayerCount'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getResourceFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getResourceFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getResourceFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getResourceFile();
        lua_pushlstring(tolua_S,ret.data(),ret.length());
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getResourceFile",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getResourceFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getMapInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getMapInfo'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getMapInfo'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getMapInfo();
        object_to_luaval<ax::TMXMapInfo>(tolua_S, "ax.TMXMapInfo",(ax::TMXMapInfo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getMapInfo",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getMapInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getTilesetInfo(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getTilesetInfo'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:getTilesetInfo");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getTilesetInfo'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTilesetInfo(arg0);
        object_to_luaval<ax::TMXTilesetInfo>(tolua_S, "ax.TMXTilesetInfo",(ax::TMXTilesetInfo*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getTilesetInfo",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getTilesetInfo'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_getLayers(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_getLayers'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_getLayers'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getLayers();
        ccvector_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:getLayers",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_getLayers'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_initWithTMXFile(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_initWithTMXFile'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:initWithTMXFile");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_initWithTMXFile'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithTMXFile(arg0);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:initWithTMXFile",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_initWithTMXFile'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_initWithXML(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::FastTMXTiledMap*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_FastTMXTiledMap_initWithXML'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 2) 
    {
        std::string_view arg0;
        std::string_view arg1;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:initWithXML");

        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FastTMXTiledMap:initWithXML");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_initWithXML'", nullptr);
            return 0;
        }
        auto&& ret = cobj->initWithXML(arg0, arg1);
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:initWithXML",argc, 2);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_initWithXML'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_FastTMXTiledMap_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::FastTMXTiledMap::create(arg0);
        object_to_luaval<ax::FastTMXTiledMap>(tolua_S, "ax.FastTMXTiledMap",(ax::FastTMXTiledMap*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FastTMXTiledMap:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FastTMXTiledMap_createWithXML(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.FastTMXTiledMap",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 2)
    {
        std::string_view arg0;
        std::string_view arg1;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.FastTMXTiledMap:createWithXML");
        ok &= luaval_to_std_string_view(tolua_S, 3,&arg1, "ax.FastTMXTiledMap:createWithXML");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_createWithXML'", nullptr);
            return 0;
        }
        auto&& ret = ax::FastTMXTiledMap::createWithXML(arg0, arg1);
        object_to_luaval<ax::FastTMXTiledMap>(tolua_S, "ax.FastTMXTiledMap",(ax::FastTMXTiledMap*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.FastTMXTiledMap:createWithXML",argc, 2);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_createWithXML'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_FastTMXTiledMap_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::FastTMXTiledMap* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_FastTMXTiledMap_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::FastTMXTiledMap();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.FastTMXTiledMap");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.FastTMXTiledMap:FastTMXTiledMap",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_FastTMXTiledMap_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_FastTMXTiledMap_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (FastTMXTiledMap)");
    return 0;
}

int lua_register_ax_base_FastTMXTiledMap(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.FastTMXTiledMap");
    tolua_cclass(tolua_S,"FastTMXTiledMap","ax.FastTMXTiledMap","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"FastTMXTiledMap");
        tolua_function(tolua_S,"new",lua_ax_base_FastTMXTiledMap_constructor);
        tolua_function(tolua_S,"getLayer",lua_ax_base_FastTMXTiledMap_getLayer);
        tolua_function(tolua_S,"getObjectGroup",lua_ax_base_FastTMXTiledMap_getObjectGroup);
        tolua_function(tolua_S,"getProperty",lua_ax_base_FastTMXTiledMap_getProperty);
        tolua_function(tolua_S,"getPropertiesForGID",lua_ax_base_FastTMXTiledMap_getPropertiesForGID);
        tolua_function(tolua_S,"getMapSize",lua_ax_base_FastTMXTiledMap_getMapSize);
        tolua_function(tolua_S,"setMapSize",lua_ax_base_FastTMXTiledMap_setMapSize);
        tolua_function(tolua_S,"getTileSize",lua_ax_base_FastTMXTiledMap_getTileSize);
        tolua_function(tolua_S,"setTileSize",lua_ax_base_FastTMXTiledMap_setTileSize);
        tolua_function(tolua_S,"getMapOrientation",lua_ax_base_FastTMXTiledMap_getMapOrientation);
        tolua_function(tolua_S,"setMapOrientation",lua_ax_base_FastTMXTiledMap_setMapOrientation);
        tolua_function(tolua_S,"getObjectGroups",lua_ax_base_FastTMXTiledMap_getObjectGroups);
        tolua_function(tolua_S,"setObjectGroups",lua_ax_base_FastTMXTiledMap_setObjectGroups);
        tolua_function(tolua_S,"getProperties",lua_ax_base_FastTMXTiledMap_getProperties);
        tolua_function(tolua_S,"setProperties",lua_ax_base_FastTMXTiledMap_setProperties);
        tolua_function(tolua_S,"setTileAnimEnabled",lua_ax_base_FastTMXTiledMap_setTileAnimEnabled);
        tolua_function(tolua_S,"getLayerCount",lua_ax_base_FastTMXTiledMap_getLayerCount);
        tolua_function(tolua_S,"getResourceFile",lua_ax_base_FastTMXTiledMap_getResourceFile);
        tolua_function(tolua_S,"getMapInfo",lua_ax_base_FastTMXTiledMap_getMapInfo);
        tolua_function(tolua_S,"getTilesetInfo",lua_ax_base_FastTMXTiledMap_getTilesetInfo);
        tolua_function(tolua_S,"getLayers",lua_ax_base_FastTMXTiledMap_getLayers);
        tolua_function(tolua_S,"initWithTMXFile",lua_ax_base_FastTMXTiledMap_initWithTMXFile);
        tolua_function(tolua_S,"initWithXML",lua_ax_base_FastTMXTiledMap_initWithXML);
        tolua_function(tolua_S,"create", lua_ax_base_FastTMXTiledMap_create);
        tolua_function(tolua_S,"createWithXML", lua_ax_base_FastTMXTiledMap_createWithXML);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::FastTMXTiledMap).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.FastTMXTiledMap";
    g_typeCast[typeName] = "ax.FastTMXTiledMap";
    return 1;
}

int lua_ax_base_MotionStreak3D_tintWithColor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_tintWithColor'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Color3B arg0;

        ok &= luaval_to_color3b(tolua_S, 2, &arg0, "ax.MotionStreak3D:tintWithColor");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_tintWithColor'", nullptr);
            return 0;
        }
        cobj->tintWithColor(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:tintWithColor",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_tintWithColor'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_reset(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_reset'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_reset'", nullptr);
            return 0;
        }
        cobj->reset();
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:reset",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_reset'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_getStroke(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_getStroke'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_getStroke'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getStroke();
        tolua_pushnumber(tolua_S,(lua_Number)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:getStroke",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_getStroke'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_setStroke(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_setStroke'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak3D:setStroke");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_setStroke'", nullptr);
            return 0;
        }
        cobj->setStroke(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:setStroke",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_setStroke'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_isStartingPositionInitialized(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_isStartingPositionInitialized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_isStartingPositionInitialized'", nullptr);
            return 0;
        }
        auto&& ret = cobj->isStartingPositionInitialized();
        tolua_pushboolean(tolua_S,(bool)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:isStartingPositionInitialized",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_isStartingPositionInitialized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_setStartingPositionInitialized(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_setStartingPositionInitialized'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        bool arg0;

        ok &= luaval_to_boolean(tolua_S, 2,&arg0, "ax.MotionStreak3D:setStartingPositionInitialized");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_setStartingPositionInitialized'", nullptr);
            return 0;
        }
        cobj->setStartingPositionInitialized(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:setStartingPositionInitialized",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_setStartingPositionInitialized'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_getTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_getTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_getTexture'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getTexture();
        object_to_luaval<ax::Texture2D>(tolua_S, "ax.Texture2D",(ax::Texture2D*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:getTexture",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_getTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_setTexture(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_setTexture'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Texture2D* arg0;

        ok &= luaval_to_object<ax::Texture2D>(tolua_S, 2, "ax.Texture2D",&arg0, "ax.MotionStreak3D:setTexture");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_setTexture'", nullptr);
            return 0;
        }
        cobj->setTexture(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:setTexture",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_setTexture'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_setBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_setBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::BlendFunc arg0;

        ok &= luaval_to_blendfunc(tolua_S, 2, &arg0, "ax.MotionStreak3D:setBlendFunc");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_setBlendFunc'", nullptr);
            return 0;
        }
        cobj->setBlendFunc(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:setBlendFunc",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_setBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_getBlendFunc(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_getBlendFunc'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_getBlendFunc'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getBlendFunc();
        blendfunc_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:getBlendFunc",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_getBlendFunc'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_setSweepAxis(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_setSweepAxis'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        ax::Vec3 arg0;

        ok &= luaval_to_vec3(tolua_S, 2, &arg0, "ax.MotionStreak3D:setSweepAxis");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_setSweepAxis'", nullptr);
            return 0;
        }
        cobj->setSweepAxis(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:setSweepAxis",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_setSweepAxis'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_getSweepAxis(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_getSweepAxis'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_getSweepAxis'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getSweepAxis();
        vec3_to_luaval(tolua_S, ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:getSweepAxis",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_getSweepAxis'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_initWithFade(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif
    cobj = (ax::MotionStreak3D*)tolua_tousertype(tolua_S,1,0);
#if _AX_DEBUG >= 1
    if (!cobj)
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_MotionStreak3D_initWithFade'", nullptr);
        return 0;
    }
#endif
    argc = lua_gettop(tolua_S)-1;
    do{
        if (argc == 5) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            ax::Texture2D* arg4;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 6, "ax.Texture2D",&arg4, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            bool ret = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    do{
        if (argc == 5) {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.MotionStreak3D:initWithFade");

            if (!ok) { break; }
            bool ret = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            tolua_pushboolean(tolua_S,(bool)ret);
            return 1;
        }
    }while(0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n",  "ax.MotionStreak3D:initWithFade",argc, 5);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_initWithFade'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_MotionStreak3D_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;
#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.MotionStreak3D",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S)-1;

    do 
    {
        if (argc == 5)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            ax::Texture2D* arg4;
            ok &= luaval_to_object<ax::Texture2D>(tolua_S, 6, "ax.Texture2D",&arg4, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            ax::MotionStreak3D* ret = ax::MotionStreak3D::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::MotionStreak3D>(tolua_S, "ax.MotionStreak3D",(ax::MotionStreak3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    do 
    {
        if (argc == 5)
        {
            double arg0;
            ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            double arg1;
            ok &= luaval_to_number(tolua_S, 3,&arg1, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            double arg2;
            ok &= luaval_to_number(tolua_S, 4,&arg2, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            ax::Color3B arg3;
            ok &= luaval_to_color3b(tolua_S, 5, &arg3, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            std::string_view arg4;
            ok &= luaval_to_std_string_view(tolua_S, 6,&arg4, "ax.MotionStreak3D:create");
            if (!ok) { break; }
            ax::MotionStreak3D* ret = ax::MotionStreak3D::create(arg0, arg1, arg2, arg3, arg4);
            object_to_luaval<ax::MotionStreak3D>(tolua_S, "ax.MotionStreak3D",(ax::MotionStreak3D*)ret);
            return 1;
        }
    } while (0);
    ok  = true;
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d", "ax.MotionStreak3D:create",argc, 5);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_MotionStreak3D_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::MotionStreak3D* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_MotionStreak3D_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::MotionStreak3D();
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.MotionStreak3D");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.MotionStreak3D:MotionStreak3D",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_MotionStreak3D_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_MotionStreak3D_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (MotionStreak3D)");
    return 0;
}

int lua_register_ax_base_MotionStreak3D(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.MotionStreak3D");
    tolua_cclass(tolua_S,"MotionStreak3D","ax.MotionStreak3D","ax.Node",nullptr);

    tolua_beginmodule(tolua_S,"MotionStreak3D");
        tolua_function(tolua_S,"new",lua_ax_base_MotionStreak3D_constructor);
        tolua_function(tolua_S,"tintWithColor",lua_ax_base_MotionStreak3D_tintWithColor);
        tolua_function(tolua_S,"reset",lua_ax_base_MotionStreak3D_reset);
        tolua_function(tolua_S,"getStroke",lua_ax_base_MotionStreak3D_getStroke);
        tolua_function(tolua_S,"setStroke",lua_ax_base_MotionStreak3D_setStroke);
        tolua_function(tolua_S,"isStartingPositionInitialized",lua_ax_base_MotionStreak3D_isStartingPositionInitialized);
        tolua_function(tolua_S,"setStartingPositionInitialized",lua_ax_base_MotionStreak3D_setStartingPositionInitialized);
        tolua_function(tolua_S,"getTexture",lua_ax_base_MotionStreak3D_getTexture);
        tolua_function(tolua_S,"setTexture",lua_ax_base_MotionStreak3D_setTexture);
        tolua_function(tolua_S,"setBlendFunc",lua_ax_base_MotionStreak3D_setBlendFunc);
        tolua_function(tolua_S,"getBlendFunc",lua_ax_base_MotionStreak3D_getBlendFunc);
        tolua_function(tolua_S,"setSweepAxis",lua_ax_base_MotionStreak3D_setSweepAxis);
        tolua_function(tolua_S,"getSweepAxis",lua_ax_base_MotionStreak3D_getSweepAxis);
        tolua_function(tolua_S,"initWithFade",lua_ax_base_MotionStreak3D_initWithFade);
        tolua_function(tolua_S,"create", lua_ax_base_MotionStreak3D_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::MotionStreak3D).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.MotionStreak3D";
    g_typeCast[typeName] = "ax.MotionStreak3D";
    return 1;
}

int lua_ax_base_ComponentLua_getScriptObject(lua_State* tolua_S)
{
    int argc = 0;
    ax::ComponentLua* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ComponentLua",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ComponentLua*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ComponentLua_getScriptObject'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 0) 
    {
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ComponentLua_getScriptObject'", nullptr);
            return 0;
        }
        auto&& ret = cobj->getScriptObject();
        #pragma warning NO CONVERSION FROM NATIVE FOR void*;
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ComponentLua:getScriptObject",argc, 0);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ComponentLua_getScriptObject'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ComponentLua_update(lua_State* tolua_S)
{
    int argc = 0;
    ax::ComponentLua* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif


#if _AX_DEBUG >= 1
    if (!tolua_isusertype(tolua_S,1,"ax.ComponentLua",0,&tolua_err)) goto tolua_lerror;
#endif

    cobj = (ax::ComponentLua*)tolua_tousertype(tolua_S,1,0);

#if _AX_DEBUG >= 1
    if (!cobj) 
    {
        tolua_error(tolua_S,"invalid 'cobj' in function 'lua_ax_base_ComponentLua_update'", nullptr);
        return 0;
    }
#endif

    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        double arg0;

        ok &= luaval_to_number(tolua_S, 2,&arg0, "ax.ComponentLua:update");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ComponentLua_update'", nullptr);
            return 0;
        }
        cobj->update(arg0);
        lua_settop(tolua_S, 1);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ComponentLua:update",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ComponentLua_update'.",&tolua_err);
#endif

    return 0;
}
int lua_ax_base_ComponentLua_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif

#if _AX_DEBUG >= 1
    if (!tolua_isusertable(tolua_S,1,"ax.ComponentLua",0,&tolua_err)) goto tolua_lerror;
#endif

    argc = lua_gettop(tolua_S) - 1;

    if (argc == 1)
    {
        std::string_view arg0;
        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ComponentLua:create");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ComponentLua_create'", nullptr);
            return 0;
        }
        auto&& ret = ax::ComponentLua::create(arg0);
        object_to_luaval<ax::ComponentLua>(tolua_S, "ax.ComponentLua",(ax::ComponentLua*)ret);
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d\n ", "ax.ComponentLua:create",argc, 1);
    return 0;
#if _AX_DEBUG >= 1
    tolua_lerror:
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ComponentLua_create'.",&tolua_err);
#endif
    return 0;
}
int lua_ax_base_ComponentLua_constructor(lua_State* tolua_S)
{
    int argc = 0;
    ax::ComponentLua* cobj = nullptr;
    bool ok  = true;

#if _AX_DEBUG >= 1
    tolua_Error tolua_err;
#endif



    argc = lua_gettop(tolua_S)-1;
    if (argc == 1) 
    {
        std::string_view arg0;

        ok &= luaval_to_std_string_view(tolua_S, 2,&arg0, "ax.ComponentLua:ComponentLua");
        if(!ok)
        {
            tolua_error(tolua_S,"invalid arguments in function 'lua_ax_base_ComponentLua_constructor'", nullptr);
            return 0;
        }
        cobj = new ax::ComponentLua(arg0);
        cobj->autorelease();
        int ID =  (int)cobj->_ID ;
        int* luaID =  &cobj->_luaID ;
        toluafix_pushusertype_object(tolua_S, ID, luaID, (void*)cobj,"ax.ComponentLua");
        return 1;
    }
    luaL_error(tolua_S, "%s has wrong number of arguments: %d, was expecting %d \n", "ax.ComponentLua:ComponentLua",argc, 1);
    return 0;

#if _AX_DEBUG >= 1
    tolua_error(tolua_S,"#ferror in function 'lua_ax_base_ComponentLua_constructor'.",&tolua_err);
#endif

    return 0;
}

static int lua_ax_base_ComponentLua_finalize(lua_State* tolua_S)
{
    printf("luabindings: finalizing LUA object (ComponentLua)");
    return 0;
}

int lua_register_ax_base_ComponentLua(lua_State* tolua_S)
{
    tolua_usertype(tolua_S,"ax.ComponentLua");
    tolua_cclass(tolua_S,"ComponentLua","ax.ComponentLua","ax.Component",nullptr);

    tolua_beginmodule(tolua_S,"ComponentLua");
        tolua_function(tolua_S,"new",lua_ax_base_ComponentLua_constructor);
        tolua_function(tolua_S,"getScriptObject",lua_ax_base_ComponentLua_getScriptObject);
        tolua_function(tolua_S,"update",lua_ax_base_ComponentLua_update);
        tolua_function(tolua_S,"create", lua_ax_base_ComponentLua_create);
    tolua_endmodule(tolua_S);
    auto typeName = typeid(ax::ComponentLua).name(); // rtti is literal storage
    g_luaType[reinterpret_cast<uintptr_t>(typeName)] = "ax.ComponentLua";
    g_typeCast[typeName] = "ax.ComponentLua";
    return 1;
}
TOLUA_API int register_all_ax_base(lua_State* tolua_S)
{
	tolua_open(tolua_S);
	
	tolua_module(tolua_S,"ax",0);
	tolua_beginmodule(tolua_S,"ax");

	lua_register_ax_base_Object(tolua_S);
	lua_register_ax_base_EventListener(tolua_S);
	lua_register_ax_base_EventListenerCustom(tolua_S);
	lua_register_ax_base_ShaderCache(tolua_S);
	lua_register_ax_base_Texture2D(tolua_S);
	lua_register_ax_base_Touch(tolua_S);
	lua_register_ax_base_Event(tolua_S);
	lua_register_ax_base_EventTouch(tolua_S);
	lua_register_ax_base_EventKeyboard(tolua_S);
	lua_register_ax_base_Component(tolua_S);
	lua_register_ax_base_Node(tolua_S);
	lua_register_ax_base_Scene(tolua_S);
	lua_register_ax_base_GLView(tolua_S);
	lua_register_ax_base_Director(tolua_S);
	lua_register_ax_base_Timer(tolua_S);
	lua_register_ax_base_Scheduler(tolua_S);
	lua_register_ax_base_AsyncTaskPool(tolua_S);
	lua_register_ax_base_Action(tolua_S);
	lua_register_ax_base_FiniteTimeAction(tolua_S);
	lua_register_ax_base_Speed(tolua_S);
	lua_register_ax_base_Follow(tolua_S);
	lua_register_ax_base_Image(tolua_S);
	lua_register_ax_base_PolygonInfo(tolua_S);
	lua_register_ax_base_AutoPolygon(tolua_S);
	lua_register_ax_base_SpriteFrame(tolua_S);
	lua_register_ax_base_AnimationFrame(tolua_S);
	lua_register_ax_base_Animation(tolua_S);
	lua_register_ax_base_ActionInterval(tolua_S);
	lua_register_ax_base_Sequence(tolua_S);
	lua_register_ax_base_Repeat(tolua_S);
	lua_register_ax_base_RepeatForever(tolua_S);
	lua_register_ax_base_Spawn(tolua_S);
	lua_register_ax_base_RotateTo(tolua_S);
	lua_register_ax_base_RotateBy(tolua_S);
	lua_register_ax_base_MoveBy(tolua_S);
	lua_register_ax_base_MoveTo(tolua_S);
	lua_register_ax_base_SkewTo(tolua_S);
	lua_register_ax_base_SkewBy(tolua_S);
	lua_register_ax_base_JumpBy(tolua_S);
	lua_register_ax_base_JumpTo(tolua_S);
	lua_register_ax_base_BezierBy(tolua_S);
	lua_register_ax_base_BezierTo(tolua_S);
	lua_register_ax_base_ScaleTo(tolua_S);
	lua_register_ax_base_ScaleBy(tolua_S);
	lua_register_ax_base_Blink(tolua_S);
	lua_register_ax_base_FadeTo(tolua_S);
	lua_register_ax_base_FadeIn(tolua_S);
	lua_register_ax_base_FadeOut(tolua_S);
	lua_register_ax_base_TintTo(tolua_S);
	lua_register_ax_base_TintBy(tolua_S);
	lua_register_ax_base_DelayTime(tolua_S);
	lua_register_ax_base_Animate(tolua_S);
	lua_register_ax_base_TargetedAction(tolua_S);
	lua_register_ax_base_ActionFloat(tolua_S);
	lua_register_ax_base_Properties(tolua_S);
	lua_register_ax_base_UserDefault(tolua_S);
	lua_register_ax_base_FileUtils(tolua_S);
	lua_register_ax_base_EventAcceleration(tolua_S);
	lua_register_ax_base_EventCustom(tolua_S);
	lua_register_ax_base_EventDispatcher(tolua_S);
	lua_register_ax_base_EventFocus(tolua_S);
	lua_register_ax_base_EventListenerAcceleration(tolua_S);
	lua_register_ax_base_EventListenerFocus(tolua_S);
	lua_register_ax_base_EventListenerKeyboard(tolua_S);
	lua_register_ax_base_EventMouse(tolua_S);
	lua_register_ax_base_EventListenerMouse(tolua_S);
	lua_register_ax_base_EventListenerController(tolua_S);
	lua_register_ax_base_EventListenerTouchOneByOne(tolua_S);
	lua_register_ax_base_EventListenerTouchAllAtOnce(tolua_S);
	lua_register_ax_base_EventController(tolua_S);
	lua_register_ax_base_ActionCamera(tolua_S);
	lua_register_ax_base_OrbitCamera(tolua_S);
	lua_register_ax_base_CardinalSplineTo(tolua_S);
	lua_register_ax_base_CardinalSplineBy(tolua_S);
	lua_register_ax_base_CatmullRomTo(tolua_S);
	lua_register_ax_base_CatmullRomBy(tolua_S);
	lua_register_ax_base_ActionEase(tolua_S);
	lua_register_ax_base_EaseRateAction(tolua_S);
	lua_register_ax_base_EaseExponentialIn(tolua_S);
	lua_register_ax_base_EaseExponentialOut(tolua_S);
	lua_register_ax_base_EaseExponentialInOut(tolua_S);
	lua_register_ax_base_EaseSineIn(tolua_S);
	lua_register_ax_base_EaseSineOut(tolua_S);
	lua_register_ax_base_EaseSineInOut(tolua_S);
	lua_register_ax_base_EaseBounce(tolua_S);
	lua_register_ax_base_EaseBounceIn(tolua_S);
	lua_register_ax_base_EaseBounceOut(tolua_S);
	lua_register_ax_base_EaseBounceInOut(tolua_S);
	lua_register_ax_base_EaseBackIn(tolua_S);
	lua_register_ax_base_EaseBackOut(tolua_S);
	lua_register_ax_base_EaseBackInOut(tolua_S);
	lua_register_ax_base_EaseQuadraticActionIn(tolua_S);
	lua_register_ax_base_EaseQuadraticActionOut(tolua_S);
	lua_register_ax_base_EaseQuadraticActionInOut(tolua_S);
	lua_register_ax_base_EaseQuarticActionIn(tolua_S);
	lua_register_ax_base_EaseQuarticActionOut(tolua_S);
	lua_register_ax_base_EaseQuarticActionInOut(tolua_S);
	lua_register_ax_base_EaseQuinticActionIn(tolua_S);
	lua_register_ax_base_EaseQuinticActionOut(tolua_S);
	lua_register_ax_base_EaseQuinticActionInOut(tolua_S);
	lua_register_ax_base_EaseCircleActionIn(tolua_S);
	lua_register_ax_base_EaseCircleActionOut(tolua_S);
	lua_register_ax_base_EaseCircleActionInOut(tolua_S);
	lua_register_ax_base_EaseCubicActionIn(tolua_S);
	lua_register_ax_base_EaseCubicActionOut(tolua_S);
	lua_register_ax_base_EaseCubicActionInOut(tolua_S);
	lua_register_ax_base_EaseIn(tolua_S);
	lua_register_ax_base_EaseOut(tolua_S);
	lua_register_ax_base_EaseInOut(tolua_S);
	lua_register_ax_base_EaseElastic(tolua_S);
	lua_register_ax_base_EaseElasticIn(tolua_S);
	lua_register_ax_base_EaseElasticOut(tolua_S);
	lua_register_ax_base_EaseElasticInOut(tolua_S);
	lua_register_ax_base_EaseBezierAction(tolua_S);
	lua_register_ax_base_ActionInstant(tolua_S);
	lua_register_ax_base_Show(tolua_S);
	lua_register_ax_base_Hide(tolua_S);
	lua_register_ax_base_ToggleVisibility(tolua_S);
	lua_register_ax_base_RemoveSelf(tolua_S);
	lua_register_ax_base_FlipX(tolua_S);
	lua_register_ax_base_FlipY(tolua_S);
	lua_register_ax_base_Place(tolua_S);
	lua_register_ax_base_CallFunc(tolua_S);
	lua_register_ax_base_GridAction(tolua_S);
	lua_register_ax_base_Grid3DAction(tolua_S);
	lua_register_ax_base_TiledGrid3DAction(tolua_S);
	lua_register_ax_base_StopGrid(tolua_S);
	lua_register_ax_base_ReuseGrid(tolua_S);
	lua_register_ax_base_Waves3D(tolua_S);
	lua_register_ax_base_FlipX3D(tolua_S);
	lua_register_ax_base_FlipY3D(tolua_S);
	lua_register_ax_base_Lens3D(tolua_S);
	lua_register_ax_base_Ripple3D(tolua_S);
	lua_register_ax_base_Shaky3D(tolua_S);
	lua_register_ax_base_Liquid(tolua_S);
	lua_register_ax_base_Waves(tolua_S);
	lua_register_ax_base_Twirl(tolua_S);
	lua_register_ax_base_ActionManager(tolua_S);
	lua_register_ax_base_PageTurn3D(tolua_S);
	lua_register_ax_base_ProgressTo(tolua_S);
	lua_register_ax_base_ProgressFromTo(tolua_S);
	lua_register_ax_base_ShakyTiles3D(tolua_S);
	lua_register_ax_base_ShatteredTiles3D(tolua_S);
	lua_register_ax_base_ShuffleTiles(tolua_S);
	lua_register_ax_base_FadeOutTRTiles(tolua_S);
	lua_register_ax_base_FadeOutBLTiles(tolua_S);
	lua_register_ax_base_FadeOutUpTiles(tolua_S);
	lua_register_ax_base_FadeOutDownTiles(tolua_S);
	lua_register_ax_base_TurnOffTiles(tolua_S);
	lua_register_ax_base_WavesTiles3D(tolua_S);
	lua_register_ax_base_JumpTiles3D(tolua_S);
	lua_register_ax_base_SplitRows(tolua_S);
	lua_register_ax_base_SplitCols(tolua_S);
	lua_register_ax_base_ActionTween(tolua_S);
	lua_register_ax_base_ActionCoroutine(tolua_S);
	lua_register_ax_base_AtlasNode(tolua_S);
	lua_register_ax_base_ClippingNode(tolua_S);
	lua_register_ax_base_ClippingRectangleNode(tolua_S);
	lua_register_ax_base_DrawNode(tolua_S);
	lua_register_ax_base_Label(tolua_S);
	lua_register_ax_base_LabelAtlas(tolua_S);
	lua_register_ax_base_Sprite(tolua_S);
	lua_register_ax_base_Layer(tolua_S);
	lua_register_ax_base_LayerColor(tolua_S);
	lua_register_ax_base_LayerGradient(tolua_S);
	lua_register_ax_base_LayerRadialGradient(tolua_S);
	lua_register_ax_base_LayerMultiplex(tolua_S);
	lua_register_ax_base_MenuItem(tolua_S);
	lua_register_ax_base_MenuItemLabel(tolua_S);
	lua_register_ax_base_MenuItemAtlasFont(tolua_S);
	lua_register_ax_base_MenuItemFont(tolua_S);
	lua_register_ax_base_MenuItemSprite(tolua_S);
	lua_register_ax_base_MenuItemImage(tolua_S);
	lua_register_ax_base_MenuItemToggle(tolua_S);
	lua_register_ax_base_Menu(tolua_S);
	lua_register_ax_base_MotionStreak(tolua_S);
	lua_register_ax_base_NodeGrid(tolua_S);
	lua_register_ax_base_ParticleBatchNode(tolua_S);
	lua_register_ax_base_SpriteSheet(tolua_S);
	lua_register_ax_base_SpriteFrameCache(tolua_S);
	lua_register_ax_base_ParticleData(tolua_S);
	lua_register_ax_base_ParticleEmissionMaskCache(tolua_S);
	lua_register_ax_base_ParticleSystem(tolua_S);
	lua_register_ax_base_ParticleSystemQuad(tolua_S);
	lua_register_ax_base_ParticleFire(tolua_S);
	lua_register_ax_base_ParticleFireworks(tolua_S);
	lua_register_ax_base_ParticleSun(tolua_S);
	lua_register_ax_base_ParticleGalaxy(tolua_S);
	lua_register_ax_base_ParticleFlower(tolua_S);
	lua_register_ax_base_ParticleMeteor(tolua_S);
	lua_register_ax_base_ParticleSpiral(tolua_S);
	lua_register_ax_base_ParticleExplosion(tolua_S);
	lua_register_ax_base_ParticleSmoke(tolua_S);
	lua_register_ax_base_ParticleSnow(tolua_S);
	lua_register_ax_base_ParticleRain(tolua_S);
	lua_register_ax_base_ProgressTimer(tolua_S);
	lua_register_ax_base_ProtectedNode(tolua_S);
	lua_register_ax_base_RenderTexture(tolua_S);
	lua_register_ax_base_TransitionEaseScene(tolua_S);
	lua_register_ax_base_TransitionScene(tolua_S);
	lua_register_ax_base_TransitionSceneOriented(tolua_S);
	lua_register_ax_base_TransitionRotoZoom(tolua_S);
	lua_register_ax_base_TransitionJumpZoom(tolua_S);
	lua_register_ax_base_TransitionMoveInL(tolua_S);
	lua_register_ax_base_TransitionMoveInR(tolua_S);
	lua_register_ax_base_TransitionMoveInT(tolua_S);
	lua_register_ax_base_TransitionMoveInB(tolua_S);
	lua_register_ax_base_TransitionSlideInL(tolua_S);
	lua_register_ax_base_TransitionSlideInR(tolua_S);
	lua_register_ax_base_TransitionSlideInB(tolua_S);
	lua_register_ax_base_TransitionSlideInT(tolua_S);
	lua_register_ax_base_TransitionShrinkGrow(tolua_S);
	lua_register_ax_base_TransitionFlipX(tolua_S);
	lua_register_ax_base_TransitionFlipY(tolua_S);
	lua_register_ax_base_TransitionFlipAngular(tolua_S);
	lua_register_ax_base_TransitionZoomFlipX(tolua_S);
	lua_register_ax_base_TransitionZoomFlipY(tolua_S);
	lua_register_ax_base_TransitionZoomFlipAngular(tolua_S);
	lua_register_ax_base_TransitionFade(tolua_S);
	lua_register_ax_base_TransitionCrossFade(tolua_S);
	lua_register_ax_base_TransitionTurnOffTiles(tolua_S);
	lua_register_ax_base_TransitionSplitCols(tolua_S);
	lua_register_ax_base_TransitionSplitRows(tolua_S);
	lua_register_ax_base_TransitionFadeTR(tolua_S);
	lua_register_ax_base_TransitionFadeBL(tolua_S);
	lua_register_ax_base_TransitionFadeUp(tolua_S);
	lua_register_ax_base_TransitionFadeDown(tolua_S);
	lua_register_ax_base_TransitionPageTurn(tolua_S);
	lua_register_ax_base_TransitionProgress(tolua_S);
	lua_register_ax_base_TransitionProgressRadialCCW(tolua_S);
	lua_register_ax_base_TransitionProgressRadialCW(tolua_S);
	lua_register_ax_base_TransitionProgressHorizontal(tolua_S);
	lua_register_ax_base_TransitionProgressVertical(tolua_S);
	lua_register_ax_base_TransitionProgressInOut(tolua_S);
	lua_register_ax_base_TransitionProgressOutIn(tolua_S);
	lua_register_ax_base_Camera(tolua_S);
	lua_register_ax_base_CameraBackgroundBrush(tolua_S);
	lua_register_ax_base_CameraBackgroundDepthBrush(tolua_S);
	lua_register_ax_base_CameraBackgroundColorBrush(tolua_S);
	lua_register_ax_base_CameraBackgroundSkyBoxBrush(tolua_S);
	lua_register_ax_base_GridBase(tolua_S);
	lua_register_ax_base_Grid3D(tolua_S);
	lua_register_ax_base_TiledGrid3D(tolua_S);
	lua_register_ax_base_BaseLight(tolua_S);
	lua_register_ax_base_DirectionLight(tolua_S);
	lua_register_ax_base_PointLight(tolua_S);
	lua_register_ax_base_SpotLight(tolua_S);
	lua_register_ax_base_AmbientLight(tolua_S);
	lua_register_ax_base_RenderState(tolua_S);
	lua_register_ax_base_Technique(tolua_S);
	lua_register_ax_base_Material(tolua_S);
	lua_register_ax_base_Pass(tolua_S);
	lua_register_ax_base_Renderer(tolua_S);
	lua_register_ax_base_TextureCache(tolua_S);
	lua_register_ax_base_Device(tolua_S);
	lua_register_ax_base_Application(tolua_S);
	lua_register_ax_base_GLViewImpl(tolua_S);
	lua_register_ax_base_AnimationCache(tolua_S);
	lua_register_ax_base_SpriteBatchNode(tolua_S);
	lua_register_ax_base_ParallaxNode(tolua_S);
	lua_register_ax_base_TMXObjectGroup(tolua_S);
	lua_register_ax_base_TMXLayerInfo(tolua_S);
	lua_register_ax_base_TMXTilesetInfo(tolua_S);
	lua_register_ax_base_TMXMapInfo(tolua_S);
	lua_register_ax_base_TileMapAtlas(tolua_S);
	lua_register_ax_base_FastTMXLayer(tolua_S);
	lua_register_ax_base_TMXTileAnimTask(tolua_S);
	lua_register_ax_base_TMXTileAnimManager(tolua_S);
	lua_register_ax_base_FastTMXTiledMap(tolua_S);
	lua_register_ax_base_MotionStreak3D(tolua_S);
	lua_register_ax_base_ComponentLua(tolua_S);

	tolua_endmodule(tolua_S);
	return 1;
}

