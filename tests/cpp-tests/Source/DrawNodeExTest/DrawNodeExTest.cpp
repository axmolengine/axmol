/****************************************************************************
Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd..
Copyright (c) 2019-present Axmol Engine contributors (see AUTHORS.md).

https://axmol.dev/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do size., subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/

#include "DrawNodeExTest.h"

#if defined(_WIN32)
#    pragma push_macro("TRANSPARENT")
#    undef TRANSPARENT
#endif

using namespace ax;
USING_NS_AX_EXT;

using namespace std;



Vec2 vertices1[] = {
    {45.750000f, 144.375000f},  {75.500000f, 136.875000f},  {75.500000f, 159.125000f},  {100.250000f, 161.375000f},
    {65.500000f, 181.375000f},  {102.250000f, 179.125000f}, {95.000000f, 215.125000f},  {129.331467f, 189.926208f},
    {131.371460f, 206.366196f}, {139.651474f, 192.446198f}, {161.851471f, 200.606201f}, {151.000000f, 220.375000f},
    {110.500000f, 244.375000f}, {153.750000f, 238.125000f}, {142.500000f, 253.875000f}, {220.750000f, 259.375000f},
    {250.500000f, 244.375000f}, {168.750000f, 241.875000f}, {182.250000f, 154.125000f}, {190.250000f, 227.375000f},
    {196.500000f, 197.375000f}, {208.750000f, 210.625000f}, {220.750000f, 194.375000f}, {208.750000f, 176.375000f},
    {253.250000f, 173.875000f}, {243.750000f, 154.125000f}, {213.750000f, 161.375000f}, {202.250000f, 139.875000f},
    {236.000000f, 131.875000f}, {218.500000f, 120.875000f}, {206.500000f, 125.625000f}, {184.500000f, 110.375000f},
    {157.000000f, 108.625000f}, {147.500000f, 96.625000f},  {153.750000f, 85.125000f},  {147.500000f, 75.375000f},
    {126.500000f, 74.125000f},  {110.500000f, 86.625000f},  {127.750000f, 85.125000f},  {135.250000f, 91.125000f},
    {135.250000f, 97.875000f},  {124.000000f, 93.875000f},  {115.500000f, 100.875000f}, {115.500000f, 111.875000f},
    {135.250000f, 108.625000f}, {151.000000f, 124.125000f}, {90.500000f, 131.875000f},  {113.250000f, 120.875000f},
    {88.000000f, 116.875000f},  {106.000000f, 103.875000f}, {88.000000f, 97.875000f} };

Vec2 vertices2[] = {
    {290.250000f, 98.1250000f}, {235.000000f, 90.8750000f}, {270.500000f, 109.875000f}, {235.000000f, 119.125000f},
    {275.250000f, 145.875000f}, {249.500000f, 145.875000f}, {249.500000f, 178.125000f}, {275.250000f, 187.375015f},
    {294.750488f, 168.333344f}, {311.250000f, 181.125000f}, {257.000000f, 213.625015f}, {338.500000f, 193.125000f},
    {300.000000f, 211.125015f}, {333.750000f, 211.125015f}, {368.250000f, 206.625000f}, {377.000000f, 178.125000f},
    {421.750000f, 170.125000f}, {416.250000f, 115.375000f}, {391.250000f, 157.875000f}, {338.500000f, 131.625000f},
    {362.750000f, 131.625000f}, {362.750000f, 106.875000f}, {306.500000f, 119.125000f}, {324.250000f, 85.1250000f},
    {227.500000f, 61.8750000} };

Vec2 vertices21[] = {
    {290.250000f, 98.1250000f}, {235.000000f, 90.8750000f}, {270.500000f, 109.875000f}, {235.000000f, 119.125000f},
    {275.250000f, 145.875000f}, {249.500000f, 145.875000f}, {249.500000f, 178.125000f}, {275.250000f, 187.375015f},
    {294.750488f, 168.333344f}, {311.250000f, 181.125000f}, {257.000000f, 213.625015f}, {338.500000f, 193.125000f},
    {300.000000f, 211.125015f}, {333.750000f, 211.125015f}, {368.250000f, 206.625000f}, {377.000000f, 178.125000f},
    {421.750000f, 170.125000f}, {416.250000f, 115.375000f}, {391.250000f, 157.875000f}, {338.500000f, 131.625000f},
    {362.750000f, 131.625000f}, {362.750000f, 106.875000f}, {306.500000f, 119.125000f}, {324.250000f, 85.1250000f},
    {227.500000f, 61.8750000} };

Vec2 vertices24[] = {
    {45.750000f, 144.375000f},  {75.500000f, 136.875000f},  {75.500000f, 159.125000f},  {100.250000f, 161.375000f},
    {65.500000f, 181.375000f},  {102.250000f, 179.125000f}, {95.000000f, 215.125000f},  {129.331467f, 189.926208f},
    {131.371460f, 206.366196f}, {139.651474f, 192.446198f}, {161.851471f, 200.606201f}, {151.000000f, 220.375000f},
    {110.500000f, 244.375000f}, {153.750000f, 238.125000f}, {142.500000f, 253.875000f}, {220.750000f, 259.375000f},
    {250.500000f, 244.375000f}, {168.750000f, 241.875000f}, {182.250000f, 154.125000f}, {190.250000f, 227.375000f},
    {196.500000f, 197.375000f}, {208.750000f, 210.625000f}, {220.750000f, 194.375000f}, {208.750000f, 176.375000f},
    {253.250000f, 173.875000f}, {243.750000f, 154.125000f}, {213.750000f, 161.375000f}, {202.250000f, 139.875000f},
    {236.000000f, 131.875000f}, {218.500000f, 120.875000f}, {206.500000f, 125.625000f}, {184.500000f, 110.375000f},
    {157.000000f, 108.625000f}, {147.500000f, 96.625000f},  {153.750000f, 85.125000f},  {147.500000f, 75.375000f},
    {126.500000f, 74.125000f},  {110.500000f, 86.625000f},  {127.750000f, 85.125000f},  {135.250000f, 91.125000f},
    {135.250000f, 97.875000f},  {124.000000f, 93.875000f},  {115.500000f, 100.875000f}, {115.500000f, 111.875000f},
    {135.250000f, 108.625000f}, {151.000000f, 124.125000f}, {90.500000f, 131.875000f},  {113.250000f, 120.875000f},
    {88.000000f, 116.875000f},  {106.000000f, 103.875000f}, {88.000000f, 97.875000f},
};

// Original https :  // www.purebasic.fr/english/viewtopic.php?t=82915
float verticesHead[] = { 107.f, 9.f, 0.3333333433f, 0.3411764801f, 0.3686274588f, 255.f, 81.f, 599.f, 116.f, 571.f, 180.f, 562.f, 255.f, 559.f, 213.f, 586.f, 199.f, 599.f, 0.f,  7.f, 0.3333333433f, 0.3411764801f, 0.3686274588f, 255.f, 765.f, 584.f, 782.f, 590.f, 794.f, 599.f, 772.f, 599.f, 0.f,  13.f, 0.4156862795f, 0.4313725531f, 0.4549019635f, 255.f, 278.f, 573.f, 287.f, 599.f, 199.f, 599.f, 217.f, 582.f, 256.f, 557.f, 313.f, 532.f, 352.f, 508.f, 366.f, 512.f, 368.f, 545.f, 285.f, 598.f, 0.f,  8.f, 0.4156862795f, 0.4313725531f, 0.4549019635f, 255.f, 760.f, 591.f, 754.f, 579.f, 766.f, 584.f, 773.f, 599.f, 751.f, 599.f, 0.f,  12.f, 0.400000006f, 0.4117647111f, 0.4196078479f, 255.f, 701.f, 563.f, 615.f, 599.f, 652.f, 558.f, 705.f, 507.f, 716.f, 534.f, 753.f, 577.f, 760.f, 591.f, 752.f, 599.f, 613.f, 599.f, 0.f,  10.f, 0.400000006f, 0.4117647111f, 0.4196078479f, 255.f, 704.f, 506.f, 701.f, 493.f, 686.f, 488.f, 688.f, 503.f, 692.f, 514.f, 691.f, 528.f, 708.f, 518.f, 0.f,  8.f, 0.4784313738f, 0.3647058904f, 0.2156862766f, 255.f, 285.f, 599.f, 309.f, 579.f, 365.f, 546.f, 375.f, 578.f, 378.f, 599.f, 0.f,  16.f, 0.4784313738f, 0.3647058904f, 0.2156862766f, 255.f, 471.f, 599.f, 377.f, 599.f, 365.f, 546.f, 360.f, 511.f, 394.f, 515.f, 428.f, 507.f, 492.f, 471.f, 553.f, 417.f, 568.f, 397.f, 562.f, 422.f, 552.f, 462.f, 547.f, 487.f, 524.f, 529.f, 0.f,  19.f, 0.5921568871f, 0.4980392158f, 0.3647058904f, 255.f, 614.f, 599.f, 683.f, 531.f, 690.f, 512.f, 686.f, 493.f, 684.f, 429.f, 656.f, 245.f, 654.f, 242.f, 644.f, 273.f, 628.f, 288.f, 621.f, 288.f, 592.f, 308.f, 571.f, 378.f, 554.f, 454.f, 543.f, 494.f, 514.f, 542.f, 469.f, 599.f, 0.f,  12.f, 0.5921568871f, 0.4980392158f, 0.3647058904f, 255.f, 598.f, 259.f, 602.f, 233.f, 619.f, 236.f, 624.f, 250.f, 630.f, 257.f, 629.f, 269.f, 623.f, 291.f, 603.f, 312.f, 589.f, 311.f, 0.f,  15.f, 0.4784313738f, 0.3647058904f, 0.2156862766f, 255.f, 642.f, 211.f, 606.f, 197.f, 609.f, 236.f, 621.f, 236.f, 621.f, 246.f, 630.f, 256.f, 627.f, 279.f, 626.f, 286.f, 636.f, 282.f, 641.f, 274.f, 649.f, 250.f, 656.f, 221.f, 0.f,  24.f, 0.4784313738f, 0.3647058904f, 0.2156862766f, 255.f, 309.f, 333.f, 334.f, 269.f, 346.f, 207.f, 347.f, 169.f, 323.f, 42.f, 265.f, 39.f, 256.f, 156.f, 272.f, 212.f, 276.f, 302.f, 292.f, 372.f, 323.f, 469.f, 334.f, 500.f, 350.f, 509.f, 365.f, 511.f, 358.f, 472.f, 370.f, 451.f, 382.f, 438.f, 382.f, 433.f, 389.f, 392.f, 382.f, 309.f, 315.f, 291.f, 0.f,  35.f, 0.5921568871f, 0.4980392158f, 0.3647058904f, 255.f, 439.f, 399.f, 384.f, 393.f, 354.f, 396.f, 349.f, 395.f, 348.f, 405.f, 349.f, 421.f, 352.f, 428.f, 363.f, 434.f, 383.f, 435.f, 364.f, 458.f, 358.f, 473.f, 360.f, 499.f, 364.f, 512.f, 382.f, 516.f, 407.f, 514.f, 437.f, 506.f, 476.f, 482.f, 534.f, 437.f, 562.f, 408.f, 571.f, 382.f, 581.f, 346.f, 598.f, 0.f, 333.f, 0.f, 345.f, 190.f, 336.f, 249.f, 379.f, 333.f, 373.f, 347.f, 347.f, 353.f, 347.f, 371.f, 354.f, 377.f, 387.f, 384.f, 389.f, 396.f, 0.f,  7.f, 0.5921568871f, 0.4980392158f, 0.3647058904f, 255.f, 370.f, 309.f, 322.f, 296.f, 333.f, 268.f, 339.f, 238.f, 0.f,  10.f, 0.5921568871f, 0.4980392158f, 0.3647058904f, 255.f, 341.f, 289.f, 323.f, 293.f, 314.f, 317.f, 324.f, 328.f, 352.f, 326.f, 390.f, 332.f, 388.f, 288.f, 0.f,  12.f, 0.4784313738f, 0.3647058904f, 0.2156862766f, 255.f, 440.f, 145.f, 520.f, 146.f, 464.f, 167.f, 429.f, 220.f, 422.f, 222.f, 400.f, 206.f, 392.f, 188.f, 390.f, 173.f, 393.f, 160.f, 0.f,  15.f, 0.7960784435f, 0.7490196228f, 0.6705882549f, 255.f, 460.f, 194.f, 489.f, 189.f, 500.f, 199.f, 499.f, 211.f, 489.f, 217.f, 467.f, 223.f, 445.f, 224.f, 431.f, 217.f, 422.f, 209.f, 420.f, 200.f, 436.f, 181.f, 491.f, 189.f, 0.f,  12.f, 0.7960784435f, 0.7490196228f, 0.6705882549f, 255.f, 342.f, 199.f, 343.f, 211.f, 337.f, 218.f, 322.f, 222.f, 306.f, 221.f, 292.f, 212.f, 288.f, 197.f, 297.f, 186.f, 332.f, 189.f, 0.f,  13.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 461.f, 182.f, 445.f, 184.f, 442.f, 196.f, 446.f, 210.f, 454.f, 218.f, 462.f, 219.f, 472.f, 217.f, 480.f, 207.f, 480.f, 196.f, 477.f, 185.f, 0.f,  11.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 309.f, 186.f, 306.f, 192.f, 307.f, 204.f, 313.f, 213.f, 325.f, 216.f, 334.f, 210.f, 336.f, 197.f, 332.f, 189.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 433.f, 186.f, 422.f, 199.f, 416.f, 199.f, 432.f, 179.f, 475.f, 183.f, 470.f, 185.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 470.f, 183.f, 491.f, 187.f, 497.f, 194.f, 482.f, 188.f, 433.f, 184.f, 436.f, 181.f, 0.f,  10.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 331.f, 190.f, 340.f, 199.f, 342.f, 197.f, 333.f, 188.f, 296.f, 184.f, 292.f, 186.f, 296.f, 186.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 299.f, 187.f, 291.f, 198.f, 287.f, 198.f, 296.f, 185.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 312.f, 176.f, 297.f, 178.f, 297.f, 181.f, 312.f, 177.f, 326.f, 181.f, 326.f, 179.f, 0.f,  11.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 439.f, 172.f, 470.f, 174.f, 488.f, 180.f, 457.f, 176.f, 432.f, 176.f, 423.f, 180.f, 423.f, 178.f, 431.f, 173.f, 0.f,  10.f, 0.7843137383f, 0.7254902124f, 0.6078431606f, 255.f, 467.f, 186.f, 464.f, 189.f, 464.f, 194.f, 467.f, 199.f, 473.f, 198.f, 477.f, 193.f, 477.f, 188.f, 0.f,  10.f, 0.7843137383f, 0.7254902124f, 0.6078431606f, 255.f, 332.f, 191.f, 334.f, 194.f, 332.f, 198.f, 327.f, 198.f, 323.f, 196.f, 322.f, 192.f, 324.f, 188.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 398.f, 195.f, 399.f, 204.f, 401.f, 208.f, 400.f, 198.f, 400.f, 194.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 365.f, 434.f, 350.f, 427.f, 350.f, 427.f, 356.f, 433.f, 372.f, 437.f, 382.f, 434.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 389.f, 393.f, 418.f, 401.f, 420.f, 403.f, 390.f, 396.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 391.f, 397.f, 355.f, 397.f, 356.f, 396.f, 388.f, 393.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 354.f, 397.f, 344.f, 393.f, 343.f, 390.f, 355.f, 396.f, 358.f, 396.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 343.f, 392.f, 335.f, 393.f, 337.f, 391.f, 344.f, 389.f, 346.f, 392.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 354.f, 379.f, 345.f, 372.f, 346.f, 370.f, 355.f, 377.f, 361.f, 373.f, 361.f, 377.f, 0.f,  11.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 368.f, 336.f, 375.f, 337.f, 373.f, 340.f, 367.f, 337.f, 360.f, 340.f, 356.f, 346.f, 356.f, 342.f, 363.f, 336.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 338.f, 337.f, 348.f, 351.f, 345.f, 351.f, 336.f, 339.f, 324.f, 327.f, 329.f, 328.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 367.f, 325.f, 326.f, 327.f, 330.f, 330.f, 367.f, 327.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 367.f, 326.f, 378.f, 331.f, 378.f, 328.f, 367.f, 325.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 325.f, 327.f, 316.f, 317.f, 315.f, 319.f, 322.f, 328.f, 329.f, 332.f, 329.f, 329.f, 0.f,  10.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 336.f, 256.f, 329.f, 284.f, 315.f, 312.f, 316.f, 312.f, 331.f, 267.f, 343.f, 213.f, 345.f, 214.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 654.f, 243.f, 644.f, 272.f, 635.f, 283.f, 647.f, 261.f, 651.f, 238.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 634.f, 282.f, 617.f, 290.f, 608.f, 301.f, 625.f, 287.f, 634.f, 286.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 605.f, 310.f, 609.f, 302.f, 616.f, 294.f, 610.f, 295.f, 605.f, 307.f, 0.f,  10.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 556.f, 578.f, 569.f, 550.f, 569.f, 544.f, 556.f, 576.f, 539.f, 599.f, 543.f, 599.f, 559.f, 576.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 572.f, 548.f, 582.f, 507.f, 582.f, 496.f, 583.f, 496.f, 577.f, 537.f, 575.f, 552.f, 0.f,  10.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 588.f, 497.f, 589.f, 474.f, 590.f, 468.f, 592.f, 467.f, 589.f, 499.f, 582.f, 527.f, 581.f, 521.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 572.f, 376.f, 574.f, 376.f, 563.f, 411.f, 560.f, 411.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 562.f, 406.f, 540.f, 432.f, 552.f, 422.f, 564.f, 409.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 547.f, 425.f, 504.f, 463.f, 501.f, 463.f, 530.f, 443.f, 551.f, 424.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 503.f, 462.f, 467.f, 488.f, 468.f, 489.f, 502.f, 465.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 464.f, 489.f, 438.f, 504.f, 438.f, 506.f, 452.f, 501.f, 470.f, 490.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 441.f, 503.f, 406.f, 513.f, 406.f, 515.f, 431.f, 509.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 409.f, 513.f, 377.f, 513.f, 377.f, 516.f, 397.f, 516.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 378.f, 514.f, 357.f, 510.f, 358.f, 513.f, 383.f, 517.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 622.f, 282.f, 623.f, 289.f, 625.f, 288.f, 625.f, 281.f, 632.f, 269.f, 631.f, 264.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 631.f, 267.f, 630.f, 257.f, 627.f, 247.f, 629.f, 266.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 628.f, 251.f, 621.f, 239.f, 618.f, 239.f, 624.f, 250.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 620.f, 241.f, 621.f, 231.f, 619.f, 229.f, 617.f, 241.f, 0.f,  10.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 620.f, 231.f, 627.f, 226.f, 633.f, 218.f, 633.f, 215.f, 624.f, 226.f, 619.f, 229.f, 617.f, 237.f, 0.f,  8.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 636.f, 274.f, 638.f, 260.f, 635.f, 252.f, 638.f, 267.f, 635.f, 275.f, 0.f,  11.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 631.f, 251.f, 636.f, 257.f, 636.f, 259.f, 639.f, 257.f, 634.f, 250.f, 625.f, 249.f, 628.f, 253.f, 634.f, 253.f, 0.f,  11.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 598.f, 339.f, 595.f, 334.f, 594.f, 328.f, 597.f, 328.f, 601.f, 337.f, 611.f, 339.f, 611.f, 341.f, 602.f, 342.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 341.f, 198.f, 339.f, 187.f, 337.f, 187.f, 338.f, 197.f, 0.f,  9.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 360.f, 512.f, 364.f, 546.f, 378.f, 599.f, 379.f, 599.f, 374.f, 572.f, 366.f, 547.f, 0.f,  7.f, 0.4470588267f, 0.3764705956f, 0.2666666806f, 255.f, 373.f, 583.f, 370.f, 599.f, 378.f, 599.f, 374.f, 577.f, 0.f,  19.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 684.f, 453.f, 685.f, 478.f, 691.f, 473.f, 701.f, 460.f, 717.f, 414.f, 713.f, 382.f, 709.f, 374.f, 724.f, 312.f, 718.f, 299.f, 758.f, 118.f, 754.f, 83.f, 685.f, 48.f, 657.f, 247.f, 654.f, 281.f, 652.f, 289.f, 621.f, 328.f, 0.f,  10.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 710.f, 443.f, 708.f, 402.f, 718.f, 405.f, 713.f, 443.f, 708.f, 460.f, 706.f, 460.f, 710.f, 438.f, 0.f,  11.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 726.f, 378.f, 732.f, 402.f, 734.f, 419.f, 732.f, 420.f, 727.f, 392.f, 720.f, 381.f, 702.f, 371.f, 698.f, 344.f, 0.f,  14.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 722.f, 308.f, 730.f, 328.f, 728.f, 354.f, 725.f, 365.f, 726.f, 348.f, 722.f, 359.f, 721.f, 361.f, 717.f, 339.f, 716.f, 357.f, 712.f, 359.f, 706.f, 282.f, 0.f,  10.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 730.f, 292.f, 742.f, 281.f, 744.f, 275.f, 740.f, 278.f, 727.f, 287.f, 706.f, 292.f, 712.f, 301.f, 0.f,  11.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 719.f, 284.f, 729.f, 274.f, 748.f, 237.f, 758.f, 208.f, 761.f, 182.f, 761.f, 142.f, 757.f, 110.f, 691.f, 262.f, 0.f,  10.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 661.f, 433.f, 666.f, 445.f, 672.f, 456.f, 671.f, 453.f, 668.f, 433.f, 674.f, 424.f, 643.f, 349.f, 0.f,  10.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 646.f, 432.f, 662.f, 407.f, 655.f, 356.f, 649.f, 412.f, 642.f, 431.f, 634.f, 443.f, 636.f, 444.f, 0.f,  14.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 643.f, 413.f, 647.f, 404.f, 658.f, 389.f, 644.f, 314.f, 637.f, 328.f, 641.f, 402.f, 636.f, 422.f, 633.f, 427.f, 634.f, 428.f, 642.f, 417.f, 650.f, 401.f, 0.f,  8.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 642.f, 385.f, 634.f, 377.f, 619.f, 329.f, 627.f, 322.f, 652.f, 323.f, 0.f,  16.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 622.f, 373.f, 632.f, 383.f, 636.f, 385.f, 636.f, 382.f, 627.f, 374.f, 626.f, 367.f, 633.f, 364.f, 622.f, 326.f, 609.f, 340.f, 610.f, 348.f, 612.f, 359.f, 623.f, 376.f, 631.f, 382.f, 0.f,  21.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 682.f, 97.f, 660.f, 248.f, 652.f, 242.f, 648.f, 234.f, 647.f, 227.f, 641.f, 223.f, 633.f, 216.f, 624.f, 206.f, 580.f, 194.f, 579.f, 179.f, 565.f, 159.f, 558.f, 133.f, 560.f, 123.f, 539.f, 93.f, 529.f, 68.f, 521.f, 16.f, 529.f, 0.f, 698.f, 0.f, 0.f,  13.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 514.f, 48.f, 517.f, 92.f, 519.f, 106.f, 521.f, 106.f, 519.f, 81.f, 521.f, 59.f, 527.f, 39.f, 526.f, 7.f, 520.f, 16.f, 516.f, 32.f, 0.f,  8.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 449.f, 59.f, 464.f, 36.f, 471.f, 16.f, 472.f, 1.f, 466.f, 13.f, 0.f,  8.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 472.f, 0.f, 468.f, 21.f, 460.f, 31.f, 461.f, 6.f, 458.f, 0.f, 0.f,  20.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 458.f, 0.f, 451.f, 26.f, 441.f, 52.f, 428.f, 76.f, 414.f, 92.f, 399.f, 103.f, 387.f, 116.f, 389.f, 113.f, 411.f, 75.f, 418.f, 45.f, 399.f, 76.f, 319.f, 131.f, 315.f, 112.f, 309.f, 98.f, 316.f, 83.f, 323.f, 51.f, 246.f, 0.f, 0.f,  12.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 327.f, 149.f, 339.f, 172.f, 349.f, 189.f, 354.f, 194.f, 352.f, 188.f, 347.f, 167.f, 350.f, 123.f, 353.f, 114.f, 318.f, 128.f, 0.f,  8.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 396.f, 77.f, 377.f, 96.f, 348.f, 121.f, 321.f, 131.f, 318.f, 116.f, 0.f,  15.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 299.f, 59.f, 305.f, 88.f, 312.f, 105.f, 312.f, 84.f, 315.f, 62.f, 327.f, 44.f, 326.f, 23.f, 121.f, 0.f, 287.f, 56.f, 290.f, 78.f, 299.f, 101.f, 302.f, 107.f, 0.f,  14.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 207.f, 0.f, 286.f, 50.f, 270.f, 86.f, 257.f, 144.f, 256.f, 244.f, 237.f, 220.f, 227.f, 206.f, 211.f, 191.f, 197.f, 161.f, 128.f, 56.f, 142.f, 0.f, 0.f,  12.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 179.f, 168.f, 196.f, 198.f, 210.f, 221.f, 212.f, 219.f, 201.f, 200.f, 196.f, 174.f, 202.f, 148.f, 169.f, 96.f, 171.f, 141.f, 0.f,  16.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 152.f, 157.f, 158.f, 178.f, 168.f, 198.f, 172.f, 206.f, 172.f, 202.f, 165.f, 178.f, 164.f, 154.f, 173.f, 121.f, 129.f, 48.f, 126.f, 78.f, 130.f, 108.f, 133.f, 121.f, 144.f, 146.f, 0.f,  10.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 254.f, 155.f, 269.f, 202.f, 272.f, 221.f, 273.f, 258.f, 262.f, 243.f, 259.f, 248.f, 240.f, 222.f, 0.f,  14.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 112.f, 33.f, 121.f, 12.f, 124.f, 0.f, 145.f, 0.f, 134.f, 34.f, 127.f, 38.f, 118.f, 58.f, 112.f, 92.f, 108.f, 100.f, 107.f, 86.f, 106.f, 63.f, 0.f,  24.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 298.f, 146.f, 293.f, 134.f, 284.f, 132.f, 272.f, 136.f, 272.f, 138.f, 267.f, 140.f, 264.f, 149.f, 266.f, 158.f, 272.f, 157.f, 274.f, 159.f, 289.f, 154.f, 303.f, 157.f, 324.f, 171.f, 334.f, 176.f, 340.f, 181.f, 332.f, 171.f, 330.f, 162.f, 328.f, 153.f, 311.f, 146.f, 298.f, 136.f, 290.f, 133.f, 0.f,  22.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 485.f, 139.f, 487.f, 130.f, 509.f, 129.f, 532.f, 137.f, 544.f, 152.f, 549.f, 168.f, 543.f, 164.f, 543.f, 168.f, 522.f, 159.f, 496.f, 155.f, 470.f, 156.f, 435.f, 164.f, 407.f, 173.f, 391.f, 171.f, 384.f, 168.f, 379.f, 156.f, 413.f, 151.f, 414.f, 148.f, 489.f, 129.f, 0.f,  16.f, 0.1882352978f, 0.1686274558f, 0.0862745121f, 255.f, 607.f, 191.f, 606.f, 241.f, 606.f, 275.f, 596.f, 314.f, 592.f, 314.f, 581.f, 350.f, 574.f, 364.f, 574.f, 364.f, 580.f, 328.f, 577.f, 326.f, 577.f, 312.f, 583.f, 247.f, 579.f, 164.f, 0.f,  13.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 756.f, 68.f, 754.f, 97.f, 749.f, 104.f, 734.f, 107.f, 715.f, 100.f, 701.f, 102.f, 696.f, 97.f, 682.f, 26.f, 661.f, 0.f, 736.f, 0.f, 0.f,  11.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 689.f, 76.f, 687.f, 88.f, 683.f, 99.f, 676.f, 99.f, 674.f, 78.f, 669.f, 39.f, 659.f, 0.f, 705.f, 0.f, 0.f,  9.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 652.f, 0.f, 651.f, 16.f, 646.f, 29.f, 642.f, 31.f, 638.f, 24.f, 631.f, 0.f, 0.f,  9.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 628.f, 0.f, 628.f, 20.f, 625.f, 27.f, 619.f, 29.f, 616.f, 19.f, 616.f, 0.f, 0.f,  12.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 415.f, 0.f, 403.f, 31.f, 392.f, 54.f, 376.f, 68.f, 364.f, 74.f, 362.f, 70.f, 365.f, 61.f, 390.f, 25.f, 400.f, 0.f, 0.f,  12.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 352.f, 42.f, 341.f, 66.f, 339.f, 82.f, 344.f, 81.f, 350.f, 70.f, 364.f, 44.f, 381.f, 21.f, 380.f, 16.f, 368.f, 19.f, 0.f,  11.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 344.f, 0.f, 365.f, 0.f, 353.f, 21.f, 341.f, 49.f, 332.f, 62.f, 329.f, 58.f, 329.f, 51.f, 344.f, 0.f, 0.f,  10.f, 0.1568627506f, 0.1686274558f, 0.2352941185f, 255.f, 333.f, 2.f, 329.f, 17.f, 323.f, 23.f, 318.f, 18.f, 319.f, 6.f, 320.f, 0.f, 331.f, 0.f, 0.f,  11.f, 0.1764705926f, 0.1960784346f, 0.2666666806f, 255.f, 760.f, 0.f, 761.f, 39.f, 757.f, 80.f, 750.f, 86.f, 709.f, 69.f, 692.f, 47.f, 692.f, 26.f, 696.f, 0.f, 0.f,  7.f, 0.160784319f, 0.1764705926f, 0.1882352978f, 255.f, 278.f, 599.f, 324.f, 554.f, 322.f, 557.f, 283.f, 599.f, 0.f,  9.f, 0.160784319f, 0.1764705926f, 0.1882352978f, 255.f, 758.f, 589.f, 753.f, 577.f, 755.f, 577.f, 762.f, 591.f, 756.f, 599.f, 754.f, 599.f, 0.f,  7.f, 0.160784319f, 0.1764705926f, 0.1882352978f, 255.f, 773.f, 599.f, 765.f, 583.f, 763.f, 583.f, 770.f, 599.f, 0.f,  10.f, 0.160784319f, 0.1764705926f, 0.1882352978f, 255.f, 694.f, 507.f, 694.f, 498.f, 691.f, 498.f, 694.f, 509.f, 690.f, 519.f, 693.f, 521.f, 696.f, 507.f, 0.f,  9.f, 0.160784319f, 0.1764705926f, 0.1882352978f, 255.f, 215.f, 583.f, 256.f, 556.f, 253.f, 556.f, 216.f, 579.f, 198.f, 599.f, 200.f, 599.f, 0.f,  0.f };


float verticesFB[] = { {0.842}, {1.052}, {0.842}, {1.649}, {5.296}, {1.649}, {5.595}, {1.855},
    {5.913}, {2.028}, {6.233}, {2.194}, {6.541}, {2.384}, {6.733}, {2.576}, {6.906}, {2.851},
    {7.060}, {3.190}, {7.197}, {3.573}, {7.317}, {3.981}, {7.423}, {4.397}, {7.516}, {4.800},
    {7.597}, {5.173}, {7.668}, {5.496}, {7.729}, {5.751}, {7.782}, {5.918}, {7.815}, {5.974},
    {7.876}, {6.075}, {7.981}, {6.274}, {8.143}, {6.622}, {8.373}, {7.172}, {8.686}, {7.976},
    {8.960}, {8.571}, {9.034}, {8.733}, {8.830}, {8.824}, {8.392}, {8.659}, {7.954}, {8.508},
    {7.784}, {8.487}, {7.601}, {8.471}, {7.395}, {8.460}, {7.153}, {8.453}, {6.867}, {8.449},
    {6.116}, {8.449}, {5.630}, {8.451}, {5.057}, {8.452}, {4.384}, {8.453}, {4.144}, {8.119},
    {3.980}, {7.715}, {4.065}, {7.361}, {4.215}, {7.044}, {4.420}, {6.761}, {4.668}, {6.505},
    {4.948}, {6.271}, {5.250}, {6.055}, {5.562}, {5.850}, {5.778}, {5.645}, {6.015}, {5.478},
    {6.421}, {5.367}, {6.742}, {5.271}, {6.921}, {5.178}, {7.105}, {4.836}, {7.123}, {4.472},
    {7.005}, {4.183}, {6.803}, {3.964}, {6.641}, {3.871}, {6.487}, {3.890}, {6.309}, {4.005},
    {6.077}, {4.200}, {5.758}, {4.459}, {5.321}, {4.768}, {4.735}, {5.110}, {4.641}, {5.211},
    {4.445}, {5.452}, {4.177}, {5.794}, {3.868}, {6.198}, {3.548}, {6.624}, {3.246}, {7.033},
    {2.993}, {7.387}, {2.819}, {7.644}, {2.753}, {7.767}, {2.774}, {8.165}, {2.859}, {8.538},
    {3.020}, {8.867}, {3.272}, {9.131}, {3.625}, {9.311}, {4.420}, {9.563}, {5.023}, {9.750},
    {5.461}, {9.885}, {5.756}, {9.979}, {5.933}, {10.040}, {6.017}, {10.090}, {6.032}, {10.140},
    {5.946}, {10.470}, {5.873}, {10.810}, {5.830}, {11.140}, {5.835}, {11.460}, {5.904}, {11.790},
    {6.054}, {12.120}, {6.226}, {12.400}, {6.409}, {12.670}, {6.591}, {12.950}, {6.763}, {13.240},
    {6.912}, {13.530}, {7.030}, {13.850}, {7.101}, {14.260}, {7.094}, {14.700}, {7.023}, {15.130},
    {6.902}, {15.510}, {6.747}, {15.810}, {6.570}, {15.970}, {6.403}, {15.930}, {6.092}, {15.770},
    {5.735}, {15.550}, {5.431}, {15.310}, {5.277}, {15.100}, {5.174}, {14.540}, {5.157}, {14.260},
    {5.122}, {14.130}, {4.885}, {13.950}, {4.557}, {13.890}, {4.191}, {13.920}, {3.841}, {14.020},
    {3.559}, {14.170}, {3.428}, {14.300}, {3.353}, {14.480}, {3.322}, {14.740}, {3.318}, {15.080},
    {3.326}, {15.520}, {3.332}, {16.100}, {3.530}, {16.370}, {3.655}, {16.700}, {3.728}, {17.090},
    {3.771}, {17.500}, {3.805}, {17.900}, {3.853}, {18.270}, {3.934}, {18.590}, {4.072}, {18.810},
    {4.357}, {19.060}, {4.706}, {19.310}, {5.085}, {19.520}, {5.459}, {19.680}, {5.794}, {19.750},
    {6.056}, {19.710}, {6.208}, {19.540}, {6.733}, {19.540}, {7.059}, {19.540}, {7.265}, {19.540},
    {7.431}, {19.540}, {7.637}, {19.540}, {7.963}, {19.540}, {8.488}, {19.540}, {8.782}, {19.390},
    {9.234}, {19.250}, {9.553}, {19.080}, {9.893}, {18.880}, {10.230}, {18.650}, {10.560}, {18.420},
    {10.840}, {18.190}, {11.070}, {17.990}, {11.230}, {17.820}, {11.700}, {17.160}, {11.970}, {16.690},
    {12.110}, {16.370}, {12.150}, {16.170}, {12.150}, {16.050}, {12.170}, {15.980}, {12.350}, {15.740},
    {12.570}, {15.550}, {12.820}, {15.420}, {13.100}, {15.330}, {13.400}, {15.280}, {13.730}, {15.270},
    {14.070}, {15.280}, {14.430}, {15.330}, {14.800}, {15.390}, {15.180}, {15.470}, {15.560}, {15.560},
    {15.950}, {15.650}, {16.330}, {15.750}, {16.710}, {15.840}, {17.080}, {15.920}, {17.450}, {15.990},
    {17.790}, {16.030}, {18.040}, {16.040}, {18.310}, {16.040}, {18.630}, {16.010}, {18.980}, {15.960},
    {19.390}, {15.890}, {19.860}, {15.800}, {20.180}, {15.740}, {20.450}, {15.700}, {20.700}, {15.690},
    {20.940}, {15.720}, {21.190}, {15.800}, {21.470}, {15.930}, {21.810}, {16.130}, {22.210}, {16.410},
    {22.700}, {16.770}, {23.010}, {16.960}, {23.330}, {17.080}, {23.660}, {17.150}, {23.990}, {17.170},
    {24.330}, {17.130}, {24.660}, {17.040}, {24.980}, {16.910}, {25.280}, {16.730}, {25.560}, {16.510},
    {25.800}, {16.300}, {25.950}, {16.120}, {26.040}, {15.890}, {26.120}, {15.490}, {26.210}, {14.830},
    {26.270}, {14.420}, {26.320}, {14.030}, {26.370}, {13.660}, {26.390}, {13.300}, {26.380}, {12.940},
    {26.330}, {12.580}, {26.290}, {12.470}, {26.200}, {12.280}, {26.080}, {12.030}, {25.930}, {11.740},
    {25.750}, {11.400}, {25.550}, {11.030}, {25.340}, {10.650}, {25.120}, {10.270}, {24.900}, {9.897},
    {24.680}, {9.544}, {24.480}, {9.224}, {24.300}, {8.949}, {24.140}, {8.731}, {23.850}, {8.298},
    {23.660}, {7.941}, {23.530}, {7.660}, {23.420}, {7.457}, {23.290}, {7.331}, {23.290}, {6.946},
    {23.300}, {6.569}, {23.310}, {6.198}, {23.340}, {5.830}, {23.380}, {5.501}, {23.300}, {5.389},
    {23.050}, {5.526}, {22.840}, {5.731}, {22.680}, {5.993}, {22.560}, {6.302}, {22.480}, {6.647},
    {22.430}, {7.017}, {22.410}, {7.401}, {22.410}, {7.788}, {22.440}, {8.166}, {22.480}, {8.526},
    {22.540}, {8.856}, {22.600}, {9.146}, {22.700}, {9.459}, {22.830}, {9.787}, {22.990}, {10.120},
    {23.160}, {10.460}, {23.330}, {10.790}, {23.480}, {11.110}, {23.620}, {11.400}, {23.730}, {11.660},
    {23.800}, {11.890}, {23.850}, {12.260}, {23.880}, {12.640}, {23.860}, {13.020}, {23.810}, {13.390},
    {23.720}, {13.730}, {23.590}, {14.050}, {23.410}, {14.320}, {23.190}, {14.540}, {22.920}, {14.690},
    {22.620}, {14.790}, {22.300}, {14.850}, {21.970}, {14.880}, {21.640}, {14.880}, {21.310}, {14.880},
    {20.980}, {14.870}, {21.110}, {14.550}, {21.250}, {14.230}, {21.390}, {13.900}, {21.520}, {13.580},
    {21.640}, {13.250}, {21.740}, {12.920}, {21.810}, {12.590}, {21.850}, {12.260}, {21.850}, {11.920},
    {21.810}, {11.580}, {21.710}, {11.240}, {21.550}, {10.880}, {21.320}, {10.540}, {21.040}, {10.220},
    {20.740}, {9.924}, {20.430}, {9.648}, {20.130}, {9.397}, {19.860}, {9.172}, {19.650}, {8.976},
    {19.500}, {8.811}, {19.440}, {8.678}, {19.450}, {8.382}, {19.640}, {7.984}, {19.840}, {7.710},
    {20.060}, {7.419}, {20.270}, {7.119}, {20.440}, {6.816}, {20.520}, {6.520}, {20.480}, {6.237},
    {20.350}, {5.983}, {20.160}, {5.736}, {19.930}, {5.491}, {19.670}, {5.243}, {19.400}, {4.989},
    {19.110}, {4.724}, {18.830}, {4.442}, {18.560}, {4.139}, {18.410}, {3.906}, {18.220}, {3.581},
    {18.010}, {3.235}, {17.790}, {2.940}, {17.590}, {2.767}, {17.040}, {2.553}, {16.920}, {2.444},
    {16.820}, {2.143}, {16.630}, {1.806}, {16.420}, {1.766}, {16.020}, {1.824}, {15.580}, {1.951},
    {15.220}, {2.118}, {15.260}, {2.258}, {15.450}, {2.568}, {15.710}, {2.802}, {16.020}, {2.986},
    {16.360}, {3.150}, {16.680}, {3.320}, {16.970}, {3.524}, {17.060}, {3.622}, {17.240}, {3.838},
    {17.490}, {4.138}, {17.780}, {4.490}, {18.080}, {4.859}, {18.370}, {5.213}, {18.610}, {5.518},
    {18.770}, {5.741}, {18.840}, {5.849}, {18.890}, {6.150}, {18.880}, {6.406}, {18.780}, {6.694},
    {18.570}, {7.094}, {18.260}, {7.045}, {18.290}, {6.817}, {18.130}, {6.445}, {17.970}, {6.185},
    {17.750}, {5.942}, {17.500}, {5.701}, {17.220}, {5.447}, {16.940}, {5.167}, {16.670}, {4.846},
    {16.510}, {4.623}, {16.340}, {4.356}, {16.170}, {4.058}, {15.980}, {3.741}, {15.780}, {3.416},
    {15.560}, {3.096}, {15.330}, {2.794}, {15.080}, {2.520}, {14.800}, {2.287}, {14.510}, {2.107},
    {14.300}, {1.982}, {14.240}, {1.649}, {27.220}, {1.649}, {27.220}, {1.052}, {0.842}, {1.052},
    {0.842}, {1.649}, {7.541}, {1.649}, {7.700}, {1.941}, {7.767}, {2.217}, {7.837}, {2.566},
    {7.918}, {2.911}, {8.010}, {3.251}, {8.111}, {3.587}, {8.222}, {3.919}, {8.342}, {4.246},
    {8.472}, {4.570}, {8.610}, {4.890}, {8.756}, {5.205}, {8.910}, {5.518}, {9.071}, {5.826},
    {9.240}, {6.131}, {9.415}, {6.432}, {9.597}, {6.730}, {9.785}, {7.025}, {9.979}, {7.317},
    {10.180}, {7.605}, {10.380}, {7.891}, {10.590}, {8.173}, {10.800}, {8.453}, {11.990}, {8.453},
    {12.400}, {8.456}, {12.720}, {8.465}, {12.970}, {8.481}, {13.180}, {8.508}, {13.370}, {8.548},
    {13.570}, {8.602}, {13.800}, {8.674}, {14.090}, {8.765}, {14.460}, {8.878}, {14.780}, {8.817},
    {15.180}, {8.588}, {15.470}, {8.326}, {15.600}, {8.139}, {15.850}, {7.769}, {16.140}, {7.335},
    {16.380}, {6.959}, {16.490}, {6.761}, {16.530}, {6.380}, {16.470}, {6.004}, {16.340}, {5.647},
    {16.170}, {5.322}, {16.050}, {5.134}, {15.880}, {4.893}, {15.670}, {4.617}, {15.430}, {4.323},
    {15.200}, {4.030}, {14.970}, {3.755}, {14.760}, {3.515}, {14.690}, {3.464}, {14.540}, {3.373},
    {14.330}, {3.236}, {14.050}, {3.047}, {13.730}, {2.800}, {13.360}, {2.489}, {12.950}, {2.107},
    {12.520}, {1.649}, {0.842}, {1.649}, {27.220}, {1.649}, {27.220}, {1.052} };



DrawNodeExTests::DrawNodeExTests()
{
    ADD_TEST_CASE(DrawNodeSpLinesTest);
    ADD_TEST_CASE(DrawNodeMethodsTest);
    ADD_TEST_CASE(DrawNodeAxmolTest2);
    ADD_TEST_CASE(CandyMixEeffect);
    ADD_TEST_CASE(DrawNodePictureTest);


    ADD_TEST_CASE(DrawNodeMorphTest_Polygon);
    ADD_TEST_CASE(DrawNodeMorphTest_SolidPolygon);

    ADD_TEST_CASE(DrawNodePieTest);

    ADD_TEST_CASE(DrawNodeDrawInWrongOrder_Issue1888);
    ADD_TEST_CASE(DrawNodeDrawOrderTest);

    //  ADD_TEST_CASE(DrawNodePerformaneTest);
    ADD_TEST_CASE(DrawNodeThicknessTest);


    ADD_TEST_CASE(DrawNodeCocos2dxBackwardsAPITest);
    ADD_TEST_CASE(DrawNodeIssueTester);
}

DrawNodeExBaseTest::DrawNodeExBaseTest()
{
    auto director = Director::getInstance();
    director->setClearColor(Color(0, 0, 0, 0));

    origin = director->getVisibleOrigin();
    size = director->getVisibleSize();
    center = Vec2(origin.x + size.width / 2, origin.y + size.height / 2);

    screen = Director::getInstance()->getVisibleSize();
    sixth = Vec2(screen.width / 6, screen.height / 6); sixth.y;

    defY = (int)(center.y + sixth.y);
    defY2 = (int)(center.y - sixth.y);
    dev = sixth.y;

    pts = PointArray::create(n);
    pts2 = PointArray::create(n);
    pts->retain();
    pts2->retain();
    for (int i = 0; i < n; ++i) {
        pts->insertControlPoint(Vec2(0, 0), i);
        pts2->insertControlPoint(Vec2(0, 0), i);
    }

    generateDataPoints();

    if (!drawNodeEx)
    {
        drawNodeEx = DrawNodeEx::create();
        addChild(drawNodeEx);
    }
    menuItemDrawOrder->setFontSize(10);
    menuItemTransform->setFontSize(10);
    menuItemDrawOrder = MenuItemFont::create("drawOrder: false", AX_CALLBACK_1(DrawNodeExBaseTest::setDrawOrder, this));
    menuItemTransform = MenuItemFont::create("transform: true", AX_CALLBACK_1(DrawNodeExBaseTest::setTransform, this));

    auto menu = Menu::create(menuItemDrawOrder, menuItemTransform, nullptr);
    menu->alignItemsVerticallyWithPadding(4);
    menu->setPosition(Vec2(size.x-50,size.y/2-20));
    addChild(menu, 1000);
}


void DrawNodeExBaseTest::generateDataPoints() {
    for (int i = 0; i < n; ++i)
    {
        float yy1 = RandomHelper::random_real<float>(defY - dev, defY + dev);
        float yy2 = RandomHelper::random_real<float>(defY2 - dev, defY2 + dev);
        pts->replaceControlPoint(Vec2(margin + i * (screen.width - 3 * margin) / n, yy1), i);
        pts2->replaceControlPoint(Vec2(margin + i * (screen.width - 3 * margin) / n, yy2), i);
    }
}

void DrawNodeExBaseTest::setDrawOrder(Object* sender)
{
    bool ret = drawNodeEx->swapDNDrawOrder();
    if (ret) menuItemDrawOrder->setString("drawOrder: true");
    else     menuItemDrawOrder->setString("drawOrder: false");
}

void DrawNodeExBaseTest::setTransform(Object* sender)
{
    bool ret = drawNodeEx->swapDNTransform();
    if (ret) menuItemTransform->setString("transform: true");
    else     menuItemTransform->setString("transform: false");
}

void DrawNodeExBaseTest::listviewCallback(ax::Object* sender, ax::ui::ListView::EventType type)
{
    // clear all text to white
    auto listview = static_cast<ax::ui::ListView*>(sender);
    for (auto&& item : listview->getItems())
    {
        static_cast<ax::ui::Text*>(item)->setColor(ax::Color3B::WHITE);
    }
    _currentSeletedItemIndex = (int)listview->getCurSelectedIndex();
    listview->getItem(_currentSeletedItemIndex)->setColor(ax::Color3B::RED);
}

void DrawNodeExBaseTest::onChangedRadioButtonSelect(ui::RadioButton* radioButton, ui::RadioButton::EventType type)
{
    if (radioButton == nullptr) return;

    switch (type)
    {
    case ui::RadioButton::EventType::SELECTED:
    {
        selectedRadioButton = radioButton->getTag();
        break;
    }

    case ui::RadioButton::EventType::UNSELECTED:
    {
        break;
    }
    default:
        break;
    }
}

void DrawNodeExBaseTest::update(float dt)
{
    drawNodeEx->clear();
}

string DrawNodeExBaseTest::title() const
{
    return "";
}

void DrawNodeExBaseTest::drawDirection(const Vec2* vec, const int size, Vec2 offset)
{
    for (size_t i = 0; i < size; i++)
    {
        auto label = Label::createWithTTF(std::to_string(i).c_str(), "fonts/Marker Felt.ttf", 10);
        addChild(label);
        label->setPosition(vec[i] + offset);
    }
}


void DrawNodeExBaseTest::changeEndAngle(ax::Object* pSender, ax::ui::Slider::EventType type)
{
    if (type == ax::ui::Slider::EventType::ON_PERCENTAGE_CHANGED)
    {
        slider[sliderType::AngleEnd] = dynamic_cast<ax::ui::Slider*>(pSender);
        sliderValue[sliderType::AngleEnd] = slider[sliderType::AngleEnd]->getPercent() * 3.6;
        sliderLabel[sliderType::AngleEnd]->setString("endAngle: (" + Value(sliderValue[sliderType::AngleEnd]).asString() + ")");
    }
}

void DrawNodeExBaseTest::changeStartAngle(ax::Object* pSender, ax::ui::Slider::EventType type)
{
    if (type == ax::ui::Slider::EventType::ON_PERCENTAGE_CHANGED)
    {
        slider[sliderType::AngleStart] = dynamic_cast<ax::ui::Slider*>(pSender);
        sliderValue[sliderType::AngleStart] = slider[sliderType::AngleStart]->getPercent() * 3.6;
        sliderLabel[sliderType::AngleStart]->setString("startAngle: (" + Value(sliderValue[sliderType::AngleStart]).asString() + ")");
    }
}

void DrawNodeExBaseTest::changeRotation(ax::Object* pSender, ax::ui::Slider::EventType type)
{
    if (type == ax::ui::Slider::EventType::ON_PERCENTAGE_CHANGED)
    {
        slider[sliderType::Rotation] = dynamic_cast<ax::ui::Slider*>(pSender);
        sliderValue[sliderType::Rotation] = slider[sliderType::Rotation]->getPercent() * 3.6;
        sliderLabel[sliderType::Rotation]->setString("Rotation: (" + Value(sliderValue[sliderType::Rotation]).asString() + ")");
    }
}

void DrawNodeExBaseTest::changeThickness(ax::Object* pSender, ax::ui::Slider::EventType type)
{
    if (type == ax::ui::Slider::EventType::ON_PERCENTAGE_CHANGED)
    {
        slider[sliderType::Thickness] = dynamic_cast<ax::ui::Slider*>(pSender);
        sliderValue[sliderType::Thickness] = slider[sliderType::Thickness]->getPercent() * 0.1;
        sliderLabel[sliderType::Thickness]->setString("Thickness: (" + Value(sliderValue[sliderType::Thickness]).asString() + ")");
    }
}

void DrawNodeExBaseTest::initSliders()
{
    _currentSeletedItemIndex = 0;

    std::string text[sliderType::sliderTypeLast] = { "AngleStart", "AngleEnd", "Rotation", "Thickness" };

    auto ttfConfig = TTFConfig("fonts/arial.ttf", 5);
    for (int i = 0; i < (sliderType::sliderTypeLast); i++)
    {
        slider[i] = ax::ui::Slider::create();
        slider[i]->setAnchorPoint(Vec2::ANCHOR_MIDDLE_LEFT);
        slider[i]->loadBarTexture("cocosui/sliderTrack.png");
        slider[i]->loadSlidBallTextures("ccs-res/cocosui/sliderballnormal.png", "ccs-res/cocosui/sliderballpressed.png", "");
        slider[i]->loadProgressBarTexture("cocosui/sliderProgress.png");
        slider[i]->setPosition(Vec2(size.width - slider[i]->getContentSize().x / 2 - 10, size.height / 6 + i * 16));
        slider[i]->setPercent(sliderValue[i]);

        slider[i]->setEnabled(false);
        slider[i]->setScale(0.5f);
        addChild(slider[i], 20);

        sliderLabel[i] = Label::createWithTTF(ttfConfig, text[i] + ": (" + Value(sliderValue[i]).asString() + ")");
        sliderLabel[i]->setAnchorPoint(Vec2::ANCHOR_MIDDLE_LEFT);
        sliderLabel[i]->setPosition(slider[i]->getPosition() + Vec2(0, 8));
        addChild(sliderLabel[i], 20);
    }

    slider[sliderType::AngleStart]->addEventListener(AX_CALLBACK_2(DrawNodeExBaseTest::changeStartAngle, this));
    slider[sliderType::AngleEnd]->addEventListener(AX_CALLBACK_2(DrawNodeExBaseTest::changeEndAngle, this));
    slider[sliderType::Rotation]->addEventListener(AX_CALLBACK_2(DrawNodeExBaseTest::changeRotation, this));
    slider[sliderType::Thickness]->addEventListener(AX_CALLBACK_2(DrawNodeExBaseTest::changeThickness, this));
}

void DrawNodeExBaseTest::initRadioButtuns()
{
    return;
    selectedRadioButton = 0;

    _radioButtonGroup = ui::RadioButtonGroup::create();
    addChild(_radioButtonGroup, 50);

    static const float BUTTON_WIDTH = 20;
    static float startPosX = 0;

    // Create the radio buttons
    static const int NUMBER_OF_BUTTONS = 4;
    startPosX = size.width - (NUMBER_OF_BUTTONS)*BUTTON_WIDTH;
    for (int i = 0; i < NUMBER_OF_BUTTONS; ++i)
    {
        ui::RadioButton* radioButton =
            ui::RadioButton::create("cocosui/radio_button_off.png", "cocosui/radio_button_on.png");
        float posX = startPosX + BUTTON_WIDTH * i;
        radioButton->setPosition(Vec2(posX, size.height / 6 + 5 * 16));
        radioButton->setScale(1.2f);
        radioButton->setTag(i);
        _radioButtonGroup->addRadioButton(radioButton);
        addChild(radioButton, 50);
        radioButton->addEventListener(
            AX_CALLBACK_2(DrawNodeExBaseTest::onChangedRadioButtonSelect, this));
    }
}


DrawNodeMorphTest_SolidPolygon::DrawNodeMorphTest_SolidPolygon()
{
    const float coef = 2.0f * (float)M_PI / segments;
    float scaleX = 1.0f;
    float scaleY = 1.0f;

    const float angle = 360 / segments;

    for (size_t n = 0; n < 10; n++)
    {

        drawNodeExArray[n] = DrawNodeEx::create();
        addChild(drawNodeExArray[n]);
        drawNodeExArray[n]->setPosition(Vec2(AXRANDOM_MINUS1_1() * size.width / 4, AXRANDOM_MINUS1_1() * size.height / 4) + Vec2(100, 100));
        color[n] = Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f);
        rad[n] = 90 + AXRANDOM_0_1() * 10;
        state[n] = (AXRANDOM_0_1() > 0.5f) ? false : true;

        verticesObj1[n] = new Vec2[segments];  //circle
        verticesObj2[n] = new Vec2[segments];  //square
        verticesObjMorph[n] = new Vec2[segments];

        for (unsigned int i = 0; i < segments; i++) //
        {
            float rads = i * coef + angle;
            int radius = 150 + AXRANDOM_MINUS1_1() * 50;
            if (n > 2)
            {
                verticesObj1[n][i].x = radius * cosf(rads) * scaleX + center.x + AXRANDOM_0_1() * 30;
                verticesObj1[n][i].y = radius * sinf(rads) * scaleY + center.y + AXRANDOM_0_1() * 30;
            }
            else
            {
                verticesObj1[n][i].x = radius * cosf(rads) * scaleX + center.x;
                verticesObj1[n][i].y = radius * sinf(rads) * scaleY + center.y;
            }
            verticesObjMorph[n][i] = verticesObj1[n][i];
        }

        // A verticesObj2 is a bunch of vertices along straight lines
        int i = 0;
        float delta = segments / 4;
        // Left side of verticesObj2
        for (float y = 50; y > -50; y -= delta) {
            verticesObj2[n][i++] = center + Vec2(-50, y);
        }
        //top
        for (float x = -50; x < 50; x += delta) {
            verticesObj2[n][i++] = center + Vec2(x, -50);
        }
        // Right side
        for (float y = -50; y < 50; y += delta) {
            verticesObj2[n][i++] = center + Vec2(50, y);
        }
        // Bottom
        for (float x = 50; x > -50; x -= delta) {
            verticesObj2[n][i++] = center + Vec2(x, 50);
        }
    }

    initSliders();
    slider[sliderType::Thickness]->setEnabled(true);

    scheduleUpdate();
}
void DrawNodeMorphTest_SolidPolygon::update(float dt)
{
    for (int n = 0; n < 10; n++)
    {
        drawNodeExArray[n]->clear();

        Vec2 v1, v2;
        float totalDistance = 0;
        for (int i = 0; i < segments; i++) {
            if (state[n]) {
                v1 = verticesObj1[n][i];
                v2 = verticesObj2[n][i];
            }
            else {
                v2 = verticesObj1[n][i];
                v1 = verticesObj2[n][i];
            }
            v2 = verticesObjMorph[n][i];
            verticesObjMorph[n][i] = v2.lerp(v1, 0.05f);
            totalDistance += v1.distance(v2);
        }
        // If all the vertices are close, switch shape
        if (totalDistance < 300.0) {
            state[n] = !state[n];
        }

        drawNodeExArray[n]->setDNScale(Vec2(0.5f, 0.5f));
        drawNodeExArray[n]->setIsConvex(false);
        drawNodeExArray[n]->drawSolidPolygon(verticesObjMorph[n], segments, color[n], sliderValue[sliderType::Thickness], Color4B::YELLOW);
        drawNodeExArray[n]->setIsConvex(false);
    }
}

void DrawNodeMorphTest_SolidPolygon::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }

    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);

    DrawNodeExBaseTest::onEnter();
}

string DrawNodeMorphTest_SolidPolygon::title() const
{
    return "Morphing";
}

string DrawNodeMorphTest_SolidPolygon::subtitle() const
{
    return "Solid Polygons";
}

DrawNodeMorphTest_Polygon::DrawNodeMorphTest_Polygon()
{
    const float coef = 2.0f * (float)M_PI / segments;
    float scaleX = 1.0f;
    float scaleY = 1.0f;

    const float angle = 360 / segments;

    for (size_t n = 0; n < 10; n++)
    {
        drawNodeExArray[n] = DrawNodeEx::create();
        addChild(drawNodeExArray[n]);
        drawNodeExArray[n]->setPosition(Vec2(AXRANDOM_MINUS1_1() * size.width / 4, AXRANDOM_MINUS1_1() * size.height / 4) + Vec2(100, 100));
        color[n] = Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f);
        rad[n] = 90 + AXRANDOM_0_1() * 10;
        state[n] = (AXRANDOM_0_1() > 0.5f) ? false : true;


        verticesObj1[n] = new Vec2[segments];  //circle
        verticesObj2[n] = new Vec2[segments];  //square
        verticesObjMorph[n] = new Vec2[segments];

        for (unsigned int i = 0; i < segments; i++) //
        {
            float rads = i * coef + angle;
            int radius = 150 + AXRANDOM_MINUS1_1() * 50;
            if (n > 2)
            {
                verticesObj1[n][i].x = radius * cosf(rads) * scaleX + center.x + AXRANDOM_0_1() * 30;
                verticesObj1[n][i].y = radius * sinf(rads) * scaleY + center.y + AXRANDOM_0_1() * 30;
            }
            else
            {
                verticesObj1[n][i].x = radius * cosf(rads) * scaleX + center.x;
                verticesObj1[n][i].y = radius * sinf(rads) * scaleY + center.y;
            }
            verticesObjMorph[n][i] = verticesObj1[n][i];
        }

        // A verticesObj2 is a bunch of vertices along straight lines
        int i = 0;
        float delta = segments / 4;
        // Left side of verticesObj2
        for (float y = 50; y > -50; y -= delta) {
            verticesObj2[n][i++] = center + Vec2(-50, y);
        }
        //top
        for (float x = -50; x < 50; x += delta) {
            verticesObj2[n][i++] = center + Vec2(x, -50);
        }
        // Right side
        for (float y = -50; y < 50; y += delta) {
            verticesObj2[n][i++] = center + Vec2(50, y);
        }
        // Bottom
        for (float x = 50; x > -50; x -= delta) {
            verticesObj2[n][i++] = center + Vec2(x, 50);
        }
    }

    initSliders();
    slider[sliderType::Thickness]->setEnabled(true);

    scheduleUpdate();
}
void DrawNodeMorphTest_Polygon::update(float dt)
{
    for (int n = 0; n < 10; n++)
    {
        drawNodeExArray[n]->clear();

        Vec2 v1, v2;
        float totalDistance = 0;
        for (int i = 0; i < segments; i++) {
            if (state[n]) {
                v1 = verticesObj1[n][i];
                v2 = verticesObj2[n][i];
            }
            else {
                v2 = verticesObj1[n][i];
                v1 = verticesObj2[n][i];
            }
            v2 = verticesObjMorph[n][i];
            verticesObjMorph[n][i] = v2.lerp(v1, 0.05f);
            totalDistance += v1.distance(v2);
        }
        // If all the vertices are close, switch shape
        if (totalDistance < 300.0) {
            state[n] = !state[n];
        }

        drawNodeExArray[n]->setDNScale(Vec2(0.5f, 0.5f));
        drawNodeExArray[n]->setIsConvex(false);
        drawNodeExArray[n]->drawPolygon(verticesObjMorph[n], segments, sliderValue[sliderType::Thickness], color[n]);
        drawNodeExArray[n]->setIsConvex(false);
    }
}

void DrawNodeMorphTest_Polygon::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }

    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);

    DrawNodeExBaseTest::onEnter();
}

string DrawNodeMorphTest_Polygon::title() const
{
    return "Morphing";
}

string DrawNodeMorphTest_Polygon::subtitle() const
{
    return "Polygons";
}

DrawNodePictureTest::DrawNodePictureTest()
{
    //initSliders();
    //initRadioButtuns();

    drawNodeEx->runAction(RepeatForever::create(Sequence::create(FadeIn::create(1.2f), FadeOut::create(1.2f), NULL)));

    scheduleUpdate();
}

void DrawNodePictureTest::update(float dt)
{
    //DrawNodeExBaseTest::update(dt);

    static float rot = 0.1f;
    static int count = 0;
    static bool wait = false;

    drawNodeEx->clear();

    if (!wait)
    {
        rot += 0.05;
        if (rot >= 6)
        {
            rot = count = 0;
            wait = true;
        }
    }
    else if (count++ > 30)
        wait = false;

    float sph_xx[2326];
    float sph_yy[2326];
    int n = 0;
    for (int i = 0; i < 2326;)  // read data
    {
        sph_xx[n] = verticesHead[i++];
        sph_yy[n] = verticesHead[i++];
        n++;
    }

    float sph_cmb = sph_yy[0];
    int sph_la = 0;
    do
    {
        Color color = Color(sph_xx[sph_la + 1], sph_yy[sph_la + 1], sph_xx[sph_la + 2], sph_yy[sph_la + 2] * 255);
        // color = Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1);
        Vec2* vertices = new Vec2[(int)(sph_cmb - 3)];
        for (int n = 3; n < sph_cmb; n++)
        {
            vertices[n - 3] = Vec2(sph_xx[sph_la + n], sph_yy[sph_la + n]);
        }
        drawNodeEx->setPosition(Vec2(420, 280));
        //  drawNodeEx->setPosition(Vec2(0, 0));
        drawNodeEx->setScale(0.4);
        drawNodeEx->setAnchorPoint(Vec2::ANCHOR_MIDDLE);
        drawNodeEx->setRotation(180);
        drawNodeEx->setDNCenter(vertices[0]);
        drawNodeEx->setDNRotation(rot);
        drawNodeEx->setIsConvex(true);
        drawNodeEx->drawPolygon(vertices, sph_cmb - 3, color, /*rot*/0.f, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));
        drawNodeEx->setIsConvex(false);

        sph_la += sph_cmb;
        sph_cmb = sph_yy[sph_la];
    } while (sph_yy[sph_la] != 0);
}

string DrawNodePictureTest::title() const
{
    return "Example: Picture";
}

string DrawNodePictureTest::subtitle() const
{
    return "Actions Test";
}

DrawNodeDrawOrderTest::DrawNodeDrawOrderTest()
{
    drawNodeEx->clear();

    auto draw = DrawNodeEx::create();
    addChild(draw, 10);

    draw->drawPoint(Vec2(size.width / 2 - 120, size.height / 2 - 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    draw->drawPoint(Vec2(size.width / 2 + 120, size.height / 2 + 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // draw 4 small points
    Vec2 position[] = { Vec2(60, 60), Vec2(70, 70), Vec2(60, 70), Vec2(70, 60) };
    draw->drawPoints(position, 4, 5, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // draw a line
    draw->drawLine(Vec2(0, 0), Vec2(size.width, size.height), Color(1.0f, 0.0f, 0.0f, 1.0f));

    // draw a rectangle
    draw->drawRect(Vec2(23, 23), Vec2(7, 7), Color(1, 1, 0, 1.0f));

    draw->drawRect(Vec2(15, 30), Vec2(30, 15), Vec2(15, 0), Vec2(0, 15),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // draw a circle
    draw->drawCircle(VisibleRect::center() + Vec2(140, 0), 100, AX_DEGREES_TO_RADIANS(90), 50, true, 1.0f, 2.0f,
        Color(1.0f, 0.0f, 0.0f, 0.5f));

    draw->drawCircle(VisibleRect::center() - Vec2(140, 0), 50, AX_DEGREES_TO_RADIANS(90), 30, false,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // Draw some beziers
    draw->drawQuadBezier(Vec2(size.width - 150, size.height - 150), Vec2(size.width - 70, size.height - 10),
        Vec2(size.width - 10, size.height - 10), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    draw->drawQuadBezier(Vec2(0.0f, size.height), Vec2(size.width / 2, size.height / 2), Vec2(size.width, size.height), 50,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    draw->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
        Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(), 100,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    draw->drawCubicBezier(Vec2(size.width - 250, 40.0f), Vec2(size.width - 70, 100.0f), Vec2(size.width - 30, 250.0f),
        Vec2(size.width - 10, size.height - 50), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    auto array = PointArray::create(20);
    array->addControlPoint(Vec2(0.0f, 0.0f));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array->addControlPoint(Vec2(80.0f, size.height - 80));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width / 2, size.height / 2));
    draw->drawCardinalSpline(array, 0.5f, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    auto array2 = PointArray::create(20);
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    draw->drawCatmullRom(array2, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // open random color poly
    Vec2 vertices[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f),
        Vec2(50.0f, 100.0f) };
    draw->drawPoly(vertices, 5, false, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // closed random color poly
    Vec2 vertices2[] = { Vec2(30.0f, 130.0f), Vec2(30.0f, 230.0f), Vec2(50.0f, 200.0f) };
    draw->drawPoly(vertices2, 3, true, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // Draw 10 circles
    for (int i = 0; i < 10; i++)
    {
        draw->drawDot(Vec2(size.width / 2, size.height / 2), 10.f * (10 - i),
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    // Draw polygons
    Vec2 points[] = { Vec2(size.height / 4, 0.0f), Vec2(size.width, size.height / 5), Vec2(size.width / 3 * 2, size.height) };
    draw->drawPolygon(points, sizeof(points) / sizeof(points[0]), Color(1.0f, 0.0f, 0.0f, 1.0f), 4,
        Color(0.0f, 0.0f, 1.0f, 1.0f));

    // star poly (triggers buggs)
    {
        const float o = 80;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o + w, o - h), Vec2(o + w * 2, o),                  // lower spike
            Vec2(o + w * 2 + h, o + w), Vec2(o + w * 2, o + w * 2),  // right spike
            //              {o +w, o+w*2+h}, {o,o+w*2},                 // top spike
            //              {o -h, o+w}, {o,o},                         // left spike
        };

        draw->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 1.0f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // star poly (doesn't trigger bug... order is important un tesselation is supported.
    {
        const float o = 180;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o, o),
            Vec2(o + w, o - h),
            Vec2(o + w * 2, o),  // lower spike
            Vec2(o + w * 2 + h, o + w),
            Vec2(o + w * 2, o + w * 2),  // right spike
            Vec2(o + w, o + w * 2 + h),
            Vec2(o, o + w * 2),  // top spike
            Vec2(o - h, o + w),  // left spike
        };

        draw->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 1.0f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // draw a solid polygon
    Vec2 vertices3[] = { Vec2(60.0f, 160.0f), Vec2(70.0f, 190.0f), Vec2(100.0f, 190.0f), Vec2(90.0f, 160.0f) };
    draw->drawSolidPoly(vertices3, 4, Color(1.0f, 1.0f, 0.0f, 1.0f));

    // draw a solid rectangle
    draw->drawSolidRect(Vec2(10.0f, 10.0f), Vec2(20.0f, 20.0f), Color(1.0f, 1.0f, 0.0f, 1.0f));

    // draw a solid circle
    draw->drawSolidCircle(VisibleRect::center() + Vec2(140.0f, 0.0f), 40, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
        Color(0.0f, 1.0f, 0.0f, 1.0f));

    // Draw segment
    draw->drawSegment(Vec2(20.0f, size.height), Vec2(20.0f, size.height / 2), 10, Color(0.0f, 1.0f, 0.0f, 1.0f));

    draw->drawSegment(Vec2(10.0f, size.height / 2), Vec2(size.width / 2, size.height / 2), 40, Color(1.0f, 0.0f, 1.0f, 1.0f));

    // Draw triangle
    draw->drawTriangle(Vec2(10.0f, 10.0f), Vec2(70.0f, 30.0f), Vec2(100.0f, 140.0f),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    for (int i = 0; i < 100; i++)
    {
        draw->drawPoint(Vec2(i * 7.0f, 5.0f), (float)i / 5 + 1,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    auto draw1 = DrawNodeEx::create();
    this->addChild(draw1, 10);
    draw1->setLineWidth(4);
    draw1->drawLine(Vec2(0.0f, size.height), Vec2(size.width, size.height - 20), Color::YELLOW);
    draw1->drawLine(Vec2(0.0f, 0.0f), Vec2(size.width, size.height - 20), Color::YELLOW);


    Vec2 startPos = Vec2(0.0f, 0.0f);
    Vec2 destination = Vec2(100.f + AXRANDOM_0_1() * VisibleRect::rightTop().x,
        100.f + AXRANDOM_0_1() * VisibleRect::rightTop().y);
    // Lines
    drawNodeEx->drawLine(startPos, destination, Color::YELLOW, 200);


    // Points
    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(120.0f, i * 7.0f), (float)i / 5 + 1,
            Color::BLUE);
    }



    // Polygons

    drawNodeEx->drawSolidRect(Vec2(50, 80), Vec2(400, 220), Color4B::GREEN);



    // Lines

    drawNodeEx->drawLine(Vec2(0.0f, 0.0f), destination, Color::RED, 200);

    // Points

    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(80.0f, i * 7.0f), (float)i / 5 + 1,
            Color::MAGENTA);
    }

    // Polygons

    drawNodeEx->drawSolidRect(Vec2(30, 80), Vec2(500, 180), Color4B::GRAY);

    initSliders();
    initRadioButtuns();

    scheduleUpdate();
}

void DrawNodeDrawOrderTest::update(float dt)
{
    DrawNodeExBaseTest::update(dt);
}

string DrawNodeDrawOrderTest::title() const
{
    return "DrawNode Order Test";
}

string DrawNodeDrawOrderTest::subtitle() const
{
    return "";
}

DrawNodeThicknessTest::DrawNodeThicknessTest()
{
    initSliders();
    initRadioButtuns();
    slider[sliderType::Thickness]->setEnabled(true);

    scheduleUpdate();
}

void DrawNodeThicknessTest::update(float dt)
{
    DrawNodeExBaseTest::update(dt);

    drawNodeEx->clear();

    drawNodeEx->drawCircle(VisibleRect::center(), 60, AX_DEGREES_TO_RADIANS(77), 30, false,
        Color::GREEN, sliderValue[sliderType::Thickness]);

    drawNodeEx->drawLine(Vec2(0.0f, size.height), Vec2(size.width, size.height - 20), Color::YELLOW, sliderValue[sliderType::Thickness]);
    drawNodeEx->drawLine(Vec2(0.0f, 0.0f), Vec2(size.width, size.height - 20), Color::YELLOW, sliderValue[sliderType::Thickness]);

    // drawNodeEx a rectangles
    drawNodeEx->drawRect(Vec2(123, 123), Vec2(227, 227), Color(1, 1, 0, 1), sliderValue[sliderType::Thickness]);
    drawNodeEx->drawRect(Vec2(115, 130), Vec2(130, 115), Vec2(115, 100), Vec2(100, 115), Color::MAGENTA, sliderValue[sliderType::Thickness]);

    drawNodeEx->drawLine(Vec2(200.0f, size.height - 20), Vec2(size.width - 100, size.height - 20), Color::YELLOW, sliderValue[sliderType::Thickness]);
    drawNodeEx->drawLine(Vec2(300.0f, 100.0f), Vec2(size.width - 200, size.height - 120), Color::GREEN, sliderValue[sliderType::Thickness]);

    Vec2 vertices24[] = {
        {45.750000f, 144.375000f},  {75.500000f, 136.875000f},  {75.500000f, 159.125000f},  {100.250000f, 161.375000f},
        {65.500000f, 181.375000f},  {102.250000f, 179.125000f}, {95.000000f, 215.125000f},  {129.331467f, 189.926208f},
        {131.371460f, 206.366196f}, {139.651474f, 192.446198f}, {161.851471f, 200.606201f}, {151.000000f, 220.375000f},
        {110.500000f, 244.375000f}, {153.750000f, 238.125000f}, {142.500000f, 253.875000f}, {220.750000f, 259.375000f},
        {250.500000f, 244.375000f}, {168.750000f, 241.875000f}, {182.250000f, 154.125000f}, {190.250000f, 227.375000f},
        {196.500000f, 197.375000f}, {208.750000f, 210.625000f}, {220.750000f, 194.375000f}, {208.750000f, 176.375000f},
        {253.250000f, 173.875000f}, {243.750000f, 154.125000f}, {213.750000f, 161.375000f}, {202.250000f, 139.875000f},
        {236.000000f, 131.875000f}, {218.500000f, 120.875000f}, {206.500000f, 125.625000f}, {184.500000f, 110.375000f},
        {157.000000f, 108.625000f}, {147.500000f, 96.625000f},  {153.750000f, 85.125000f},  {147.500000f, 75.375000f},
        {126.500000f, 74.125000f},  {110.500000f, 86.625000f},  {127.750000f, 85.125000f},  {135.250000f, 91.125000f},
        {135.250000f, 97.875000f},  {124.000000f, 93.875000f},  {115.500000f, 100.875000f}, {115.500000f, 111.875000f},
        {135.250000f, 108.625000f}, {151.000000f, 124.125000f}, {90.500000f, 131.875000f},  {113.250000f, 120.875000f},
        {88.000000f, 116.875000f},  {106.000000f, 103.875000f}, {88.000000f, 97.875000f},
    };
    drawNodeEx->drawPolygon(vertices24, sizeof(vertices24) / sizeof(vertices24[0]), Color4B::TRANSPARENT, sliderValue[sliderType::Thickness] / 2,
        Color::RED);

    // open random color poly
    Vec2 vertices[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f),
        Vec2(50.0f, 100.0f) };
    drawNodeEx->drawPoly(vertices, 5, false, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);

    // closed random color poly
    Vec2 vertices2[] = { Vec2(30.0f, 130.0f), Vec2(30.0f, 230.0f), Vec2(50.0f, 200.0f) };
    drawNodeEx->drawPoly(vertices2, 3, true, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);

    // drawNodeEx some beziers
    drawNodeEx->drawQuadBezier(Vec2(size.width - 150, size.height - 150), Vec2(size.width - 70, size.height - 10),
        Vec2(size.width - 10, size.height - 10), 10, Color::BLUE, sliderValue[sliderType::Thickness]);

    drawNodeEx->drawQuadBezier(Vec2(0.0f + 100, size.height - 100), Vec2(size.width / 2, size.height / 2),
        Vec2(size.width - 100, size.height - 100), 50, Color::RED, sliderValue[sliderType::Thickness]);

    drawNodeEx->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
        Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(),
        100, Color::WHITE, sliderValue[sliderType::Thickness]);

    drawNodeEx->drawCubicBezier(Vec2(size.width - 250, 40.0f), Vec2(size.width - 70, 100.0f), Vec2(size.width - 30, 250.0f),
        Vec2(size.width - 10, size.height - 50), 10, Color::GRAY, sliderValue[sliderType::Thickness]);

    auto array = ax::PointArray::create(20);
    array->addControlPoint(Vec2(0.0f, 0.0f));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array->addControlPoint(Vec2(80.0f, size.height - 80));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width / 2, size.height / 2));
    drawNodeEx->drawCardinalSpline(array, 0.5f, 50, Color::MAGENTA, sliderValue[sliderType::Thickness]);

    auto array2 = ax::PointArray::create(20);
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    drawNodeEx->drawCatmullRom(array2, 50, Color::ORANGE, sliderValue[sliderType::Thickness]);


    auto s = Director::getInstance()->getWinSize();


    drawNodeEx->drawPoint(Vec2(s.width / 2 - 120, s.height / 2 - 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    drawNodeEx->drawPoint(Vec2(s.width / 2 + 120, s.height / 2 + 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx 4 small points
    Vec2 position[] = { Vec2(60, 60), Vec2(70, 70), Vec2(60, 70), Vec2(70, 60) };
    drawNodeEx->drawPoints(position, 4, 5, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a line
    drawNodeEx->drawLine(Vec2(0, 0), Vec2(s.width, s.height), Color(1.0, 0.0, 0.0, 0.5));

    // drawNodeEx a rectangle
    drawNodeEx->drawRect(Vec2(23, 23), Vec2(7, 7), Color(1, 1, 0, 1));

    drawNodeEx->drawRect(Vec2(15, 30), Vec2(30, 15), Vec2(15, 0), Vec2(0, 15),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a circle
    drawNodeEx->drawCircle(VisibleRect::center() + Vec2(140, 0), 100, AX_DEGREES_TO_RADIANS(90), 50, true, 1.0f, 2.0f,
        Color(1.0f, 0.0f, 0.0f, 0.5f));

    drawNodeEx->drawCircle(VisibleRect::center() - Vec2(140, 0), 50, AX_DEGREES_TO_RADIANS(90), 30, false,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx some beziers
    drawNodeEx->drawQuadBezier(Vec2(s.width - 150, s.height - 150), Vec2(s.width - 70, s.height - 10),
        Vec2(s.width - 10, s.height - 10), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawQuadBezier(Vec2(0.0f, s.height), Vec2(s.width / 2, s.height / 2), Vec2(s.width, s.height), 50,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
        Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(), 100,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(Vec2(s.width - 250, 40.0f), Vec2(s.width - 70, 100.0f), Vec2(s.width - 30, 250.0f),
        Vec2(s.width - 10, s.height - 50), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array3 = PointArray::create(20);
    array3->addControlPoint(Vec2(0.0f, 0.0f));
    array3->addControlPoint(Vec2(80.0f, 80.0f));
    array3->addControlPoint(Vec2(s.width - 80, 80.0f));
    array3->addControlPoint(Vec2(s.width - 80, s.height - 80));
    array3->addControlPoint(Vec2(80.0f, s.height - 80));
    array3->addControlPoint(Vec2(80.0f, 80.0f));
    array3->addControlPoint(Vec2(s.width / 2, s.height / 2));
    drawNodeEx->drawCardinalSpline(array3, 0.5f, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array4 = PointArray::create(20);
    array4->addControlPoint(Vec2(s.width / 2, 30.0f));
    array4->addControlPoint(Vec2(s.width - 80, 30.0f));
    array4->addControlPoint(Vec2(s.width - 80, s.height - 80));
    array4->addControlPoint(Vec2(s.width / 2, s.height - 80));
    array4->addControlPoint(Vec2(s.width / 2, 30.0f));
    drawNodeEx->drawCatmullRom(array4, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    // open random color poly
    Vec2 verticesA[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f),
        Vec2(50.0f, 100.0f) };
    drawNodeEx->drawPoly(verticesA, 5, false, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // closed random color poly
    Vec2 verticesB[] = { Vec2(30.0f, 130.0f), Vec2(30.0f, 230.0f), Vec2(50.0f, 200.0f) };
    drawNodeEx->drawPoly(verticesB, 3, true, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx 10 circles
    for (int i = 0; i < 10; i++)
    {
        drawNodeEx->drawDot(Vec2(s.width / 2, s.height / 2), 10.f * (10 - i),
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    // drawNodeEx polygons
    Vec2 points[] = { Vec2(s.height / 4, 0.0f), Vec2(s.width, s.height / 5), Vec2(s.width / 3 * 2, s.height) };
    drawNodeEx->drawPolygon(points, sizeof(points) / sizeof(points[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 4,
        Color(0.0f, 0.0f, 1.0f, 0.5f));

    // star poly (triggers buggs)
    {
        const float o = 80;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o + w, o - h), Vec2(o + w * 2, o),                  // lower spike
            Vec2(o + w * 2 + h, o + w), Vec2(o + w * 2, o + w * 2),  // right spike
            //              {o +w, o+w*2+h}, {o,o+w*2},                 // top spike
            //              {o -h, o+w}, {o,o},                         // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // star poly (doesn't trigger bug... order is important un tesselation is supported.
    {
        const float o = 180;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o, o),
            Vec2(o + w, o - h),
            Vec2(o + w * 2, o),  // lower spike
            Vec2(o + w * 2 + h, o + w),
            Vec2(o + w * 2, o + w * 2),  // right spike
            Vec2(o + w, o + w * 2 + h),
            Vec2(o, o + w * 2),  // top spike
            Vec2(o - h, o + w),  // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // drawNodeEx a solid polygon
    Vec2 vertices3[] = { Vec2(60.0f, 160.0f), Vec2(70.0f, 190.0f), Vec2(100.0f, 190.0f), Vec2(90.0f, 160.0f) };
    drawNodeEx->drawSolidPoly(vertices3, 4, Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid rectangle
    drawNodeEx->drawSolidRect(Vec2(10.0f, 10.0f), Vec2(20.0f, 20.0f), Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid circle
    drawNodeEx->drawSolidCircle(VisibleRect::center() + Vec2(140.0f, 0.0f), 40, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
        Color(0.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx segment
    drawNodeEx->drawSegment(Vec2(20.0f, s.height), Vec2(20.0f, s.height / 2), 10, Color(0.0f, 1.0f, 0.0f, 1.0f));

    drawNodeEx->drawSegment(Vec2(10.0f, s.height / 2), Vec2(s.width / 2, s.height / 2), 40, Color(1.0f, 0.0f, 1.0f, 0.5f));

    // drawNodeEx triangle
    drawNodeEx->drawTriangle(Vec2(10.0f, 10.0f), Vec2(70.0f, 30.0f), Vec2(100.0f, 140.0f),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(i * 7.0f, 5.0f), (float)i / 5 + 1,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }


    drawNodeEx->setLineWidth(4);
    drawNodeEx->drawLine(Vec2(0.0f, s.height), Vec2(s.width, s.height - 20), Color::YELLOW);
    drawNodeEx->drawLine(Vec2(0.0f, 0.0f), Vec2(s.width, s.height - 20), Color::YELLOW);

    drawNodeEx->runAction(RepeatForever::create(Sequence::create(FadeIn::create(1.2f), FadeOut::create(1.2f), NULL)));
}

void DrawNodeThicknessTest::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }
    //sliderValue[sliderType::Counter] = 100;
    //slider[sliderType::Counter]->setPercent(sliderValue[sliderType::Counter]);
    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);

    DrawNodeExBaseTest::onEnter();
}

string DrawNodeThicknessTest::title() const
{
    return "Thickness Test";
}

string DrawNodeThicknessTest::subtitle() const
{
    return "";
}

DrawNodePieTest::DrawNodePieTest()
{
    initSliders();
    initRadioButtuns();
    slider[sliderType::AngleStart]->setEnabled(true);
    slider[sliderType::AngleEnd]->setEnabled(true);
    slider[sliderType::Rotation]->setEnabled(true);
    slider[sliderType::Thickness]->setEnabled(true);

    scheduleUpdate();
}

void DrawNodePieTest::update(float dt)
{
    DrawNodeExBaseTest::update(dt);

    drawNodeEx->clear();

    // Filled
    drawNodeEx->drawPie(VisibleRect::center() - Vec2(190.0f, -35.0f), 40, sliderValue[sliderType::Rotation], sliderValue[sliderType::AngleStart], sliderValue[sliderType::AngleEnd], 1.0f, 1.0f,
        Color::RED, Color::BLUE, drawNodeEx->DrawMode::Fill, sliderValue[sliderType::Thickness]);

    // Outlined
    drawNodeEx->drawPie(VisibleRect::center() - Vec2(95.0f, -35.0f), 40, sliderValue[sliderType::Rotation], sliderValue[sliderType::AngleStart], sliderValue[sliderType::AngleEnd], 1.0f, 1.0f,
        Color::TRANSPARENT, Color::BLUE, drawNodeEx->DrawMode::Outline, sliderValue[sliderType::Thickness]);

    // Line
    drawNodeEx->drawPie(VisibleRect::center() + Vec2(0.0f, 35.0f), 40, sliderValue[sliderType::Rotation], sliderValue[sliderType::AngleStart], sliderValue[sliderType::AngleEnd], 1.0f, 1.0f,
        Color::TRANSPARENT, Color::BLUE, drawNodeEx->DrawMode::Line, sliderValue[sliderType::Thickness]);

    //  Semi
    drawNodeEx->drawPie(VisibleRect::center() + Vec2(95.0f, 35.0f), 40, sliderValue[sliderType::Rotation], sliderValue[sliderType::AngleStart], sliderValue[sliderType::AngleEnd], 1.0f, 1.0f,
        Color::TRANSPARENT, Color::BLUE, drawNodeEx->DrawMode::Semi, sliderValue[sliderType::Thickness]);

    // Semi (Filled)
    drawNodeEx->drawPie(VisibleRect::center() + Vec2(190.0f, 35.0f), 40, sliderValue[sliderType::Rotation], sliderValue[sliderType::AngleStart], sliderValue[sliderType::AngleEnd], 1.0f, 1.0f,
        Color::RED, Color::BLUE, drawNodeEx->DrawMode::Semi, sliderValue[sliderType::Thickness]);
}

void DrawNodePieTest::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }

    sliderValue[sliderType::AngleStart] = 10;
    slider[sliderType::AngleStart]->setPercent(sliderValue[sliderType::AngleStart]);

    sliderValue[sliderType::AngleEnd] = 100;
    slider[sliderType::AngleEnd]->setPercent(sliderValue[sliderType::AngleEnd]);

    sliderValue[sliderType::Rotation] = 10;
    slider[sliderType::Rotation]->setPercent(sliderValue[sliderType::Rotation]);

    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);

    DrawNodeExBaseTest::onEnter();
}

string DrawNodePieTest::title() const
{
    return "drawPie";
}

string DrawNodePieTest::subtitle() const
{
    return "Filled, Outlined, Line, Semi, Semi (Filled)";
}

DrawNodeMethodsTest::DrawNodeMethodsTest()
{
    static const float BUTTON_WIDTH = 30;
    static float startPosX = 0;

    auto listview = createListView();
    listview->setPosition(Vec2(0.0f, 40.0f));
    addChild(listview);

    drawNodeEx->setScale(0.5);
    drawNodeEx->setPosition(center);

    initSliders();
    //  initRadioButtuns();
    slider[sliderType::Thickness]->setEnabled(true);
    slider[sliderType::Rotation]->setEnabled(true);


    labelRound = Label::createWithTTF("DrawNodeEx::Round", "fonts/Arial.ttf", 12);
    addChild(labelRound, 1);
    labelRound->setVisible(false);
    labelSquare = Label::createWithTTF("DrawNodeEx::Square", "fonts/Arial.ttf", 12);
    addChild(labelSquare, 1);
    labelSquare->setVisible(false);
    labelButt = Label::createWithTTF("DrawNodeEx::Butt", "fonts/Arial.ttf", 12);
    addChild(labelButt, 1);
    labelButt->setVisible(false);

    scheduleUpdate();
}

ax::ui::ListView* DrawNodeMethodsTest::createListView()
{
    auto listview = ax::ui::ListView::create();
    Vec2 contentSize = { 0,0 };
    for (size_t i = 0; i < (drawMethodes::LAST); i++)
    {
        auto ui = ax::ui::Text::create();
        ui->setString(drawMethods[i].c_str());
        contentSize.x = MAX(ui->getContentSize().x, contentSize.x);
        contentSize.y = MAX(ui->getContentSize().y, contentSize.y);
        ui->setTouchEnabled(true);
        listview->pushBackCustomItem(ui);
    }

    listview->setContentSize(contentSize * (drawMethodes::LAST));
    listview->setCurSelectedIndex(0);
    listview->setTouchEnabled(true);
    listview->addEventListener(
        (ui::ListView::ccListViewCallback)AX_CALLBACK_2(DrawNodeExBaseTest::listviewCallback, this));
    listview->setTag(100);

    listview->getItem(_currentSeletedItemIndex)->setColor(Color3B::RED);

    return listview;
}

void DrawNodeMethodsTest::update(float dt)
{
    drawAll();
}

void DrawNodeMethodsTest::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }
    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);
    sliderValue[sliderType::Rotation] = 0;
    slider[sliderType::Rotation]->setPercent(sliderValue[sliderType::Rotation]);

    DrawNodeExBaseTest::onEnter();
}

std::string DrawNodeMethodsTest::title() const
{
    return "DrawNode Methods Test";
}

string DrawNodeMethodsTest::subtitle() const
{
    return "";
}

void DrawNodeMethodsTest::drawAll()
{
    static float rotation = 0.1f;
    rotation += 0.1;
    if (rotation > 62.8f)
    {
        rotation = 0.0f;
    }

    drawNodeEx->clear();
    drawNodeEx->resetDNValues();

    labelRound->setVisible(false);
    labelSquare->setVisible(false);
    labelButt->setVisible(false);

    switch (_currentSeletedItemIndex)
    {
    case drawMethodes::Line:
    {
        for (int i = 0; i < 100; i++)
        {
            drawNodeEx->drawLine(Vec2(-size.x / 2, -size.y / 2 + i * 4), Vec2(size.x - 50, -size.y / 2 + i * 4), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
            drawNodeEx->drawLine(Vec2(-size.x + 50, -size.y + AXRANDOM_0_1() * 2 * size.y), Vec2(size.x - 50, -size.y + AXRANDOM_0_1() * 2 * size.y), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case drawMethodes::Rect:
    {
        Vec2 rec;
        for (int i = 0; i < 100; i++)
        {
            rec = Vec2(i * 3, i * 3);
            drawNodeEx->drawRect(center / 2 - rec, center / 2 + rec, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
            drawNodeEx->drawRect(Vec2(AXRANDOM_MINUS1_1() * 300, AXRANDOM_MINUS1_1() * 300), Vec2(AXRANDOM_MINUS1_1() * 400, AXRANDOM_MINUS1_1() * 400), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case drawMethodes::Circle:
    {
        for (int i = 0; i < 100; i++)
        {
            drawNodeEx->drawCircle(VisibleRect::center(), 3 * i, AX_DEGREES_TO_RADIANS(90), i, false, 1.0f, 1.0f,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);

            Vec2 pos = Vec2(-100, -100) + Vec2(AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y);
            drawNodeEx->drawCircle(VisibleRect::center() + pos, AXRANDOM_0_1() * 200, AX_DEGREES_TO_RADIANS(AXRANDOM_MINUS1_1() * 90), 30, true,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case drawMethodes::QuadBezier:
    {
        drawNodeEx->drawQuadBezier(Vec2(size.width - 150, size.height - 150), Vec2(size.width - 70, size.height - 10),
            Vec2(size.width - 10, size.height - 10), 10, Color::BLUE, sliderValue[sliderType::Thickness]);
        drawNodeEx->drawQuadBezier(Vec2(0.0f + 100, size.height - 100), Vec2(size.width / 2, size.height / 2),
            Vec2(size.width - 100, size.height - 100), 50, Color::RED, sliderValue[sliderType::Thickness]);


        for (int i = 0; i < 360;)
        {
            Vec2 p1 = pts->getControlPointAtIndex(i);
            Vec2 p2 = pts->getControlPointAtIndex(i++);
            Vec2 p3 = pts->getControlPointAtIndex(i);

            drawNodeEx->setDNPosition(Vec2(-100, -100));
            drawNodeEx->drawQuadBezier(p1, p2, p3, 30, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
        }

        for (int i = 0; i < 360;)
        {
            Vec2 p1 = pts2->getControlPointAtIndex(i);
            Vec2 p2 = pts2->getControlPointAtIndex(i++);
            Vec2 p3 = pts2->getControlPointAtIndex(i);

            drawNodeEx->setDNPosition(Vec2(-100, -100));
            drawNodeEx->drawQuadBezier(p1, p2, p3, 30, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case drawMethodes::CubicBezier:
    {
        drawNodeEx->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
            Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(),
            20, Color::WHITE, sliderValue[sliderType::Thickness]);
        drawNodeEx->drawCubicBezier(Vec2(size.width - 250, 40.0f), Vec2(size.width - 70, 100.0f), Vec2(size.width - 30, 250.0f),
            Vec2(size.width - 10, size.height - 50), 20, Color::GRAY, sliderValue[sliderType::Thickness]);



        for (int i = 0; i < 360;)
        {
            Vec2 p1 = pts->getControlPointAtIndex(i);
            Vec2 p2 = pts->getControlPointAtIndex(i++);
            Vec2 p3 = pts->getControlPointAtIndex(i++);
            Vec2 p4 = pts->getControlPointAtIndex(i);
            drawNodeEx->setDNPosition(Vec2(-100, -100));
            drawNodeEx->drawCubicBezier(p1, p2, p3, p4, 120, Color::ORANGE, sliderValue[sliderType::Thickness]);
        }

        for (int i = 0; i < 360;)
        {
            Vec2 p1 = pts2->getControlPointAtIndex(i);
            Vec2 p2 = pts2->getControlPointAtIndex(i++);
            Vec2 p3 = pts2->getControlPointAtIndex(i++);
            Vec2 p4 = pts2->getControlPointAtIndex(i);
            drawNodeEx->setDNPosition(Vec2(-100, -100));
            drawNodeEx->drawCubicBezier(p1, p2, p3, p4, 120, Color::ORANGE, sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case drawMethodes::CardinalSpline:
    {
        auto array = ax::PointArray::create(7);
        array->addControlPoint(Vec2(0.0f, 0.0f));
        array->addControlPoint(Vec2(80.0f, 80.0f));
        array->addControlPoint(Vec2(size.width - 80, 80.0f));
        array->addControlPoint(Vec2(size.width - 80, size.height - 80));
        array->addControlPoint(Vec2(80.0f, size.height - 80));
        array->addControlPoint(Vec2(80.0f, 80.0f));
        array->addControlPoint(Vec2(size.width / 2, size.height / 2));
        drawNodeEx->drawCardinalSpline(array, 0.5f, 120, Color::MAGENTA, sliderValue[sliderType::Thickness]);

        auto array2 = ax::PointArray::create(5);
        array2->addControlPoint(Vec2(size.width / 2, 80.0f));
        array2->addControlPoint(Vec2(size.width - 80, 80.0f));
        array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
        array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
        array2->addControlPoint(Vec2(size.width / 2, 80.0f));
        drawNodeEx->drawCardinalSpline(array2, 5.0f, 120, Color::ORANGE, sliderValue[sliderType::Thickness]);


        drawNodeEx->drawCardinalSpline(pts, 0.1f, 360, Color::RED, 5.0f);
        drawNodeEx->drawCardinalSpline(pts2, 0.1f, 360, Color::GREEN, 2.0f);

        break;
    }
    case drawMethodes::CatmullRom:
    {
        auto array2 = ax::PointArray::create(5);
        array2->addControlPoint(Vec2(size.width / 2, 80.0f));
        array2->addControlPoint(Vec2(size.width - 80, 80.0f));
        array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
        array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
        array2->addControlPoint(Vec2(size.width / 2, 80.0f));
        drawNodeEx->drawCatmullRom(array2, 20, Color::ORANGE, sliderValue[sliderType::Thickness]);

        auto array = ax::PointArray::create(7);
        array->addControlPoint(Vec2(0.0f, 0.0f));
        array->addControlPoint(Vec2(80.0f, 80.0f));
        array->addControlPoint(Vec2(size.width - 80, 80.0f));
        array->addControlPoint(Vec2(size.width - 80, size.height - 80));
        array->addControlPoint(Vec2(80.0f, size.height - 80));
        array->addControlPoint(Vec2(80.0f, 80.0f));
        array->addControlPoint(Vec2(size.width / 2, size.height / 2));
        drawNodeEx->drawCatmullRom(array, 20, Color::MAGENTA, sliderValue[sliderType::Thickness]);


        drawNodeEx->drawCatmullRom(pts, 360, Color::RED, 5.0f);
        drawNodeEx->drawCatmullRom(pts2, 360, Color::GREEN, 2.0f);

        break;
    }
    case  drawMethodes::Poly:
    {
        Vec2 vertices[5] = { {0.0f, 0.0f }, { 50.0f, 50.0f }, { 100.0f, 50.0f }, { 100.0f, 100.0f }, { 50.0f, 100.0f } };
        drawNodeEx->setDNPosition(Vec2(-200, -300));
        drawNodeEx->drawPoly(vertices, 5, false, Color4B::BLUE, sliderValue[sliderType::Thickness]);

        Vec2 vertices2[3] = { {30.0f, 130.0f}, {30.0f, 230.0f}, {50.0f, 200.0f} };
        drawNodeEx->drawPoly(vertices2, 3, true, Color4B::GREEN, sliderValue[sliderType::Thickness]);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color4B::RED, sliderValue[sliderType::Thickness]);

        drawNodeEx->setDNPosition(Vec2(0, -300));
        drawNodeEx->setDNRotation(sliderValue[sliderType::Rotation]);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::GREEN, sliderValue[sliderType::Thickness]);
        drawNodeEx->setDNPosition(Vec2(-100, -300));
        drawNodeEx->setDNRotation(sliderValue[sliderType::Rotation]);
        drawNodeEx->setDNCenter(vertices1[0]);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::MAGENTA, sliderValue[sliderType::Thickness]);
        drawNodeEx->setDNPosition(Vec2(200, 0));
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::RED, sliderValue[sliderType::Thickness]);
        drawNodeEx->setDNPosition(Vec2(0.0f, -300.0f));
        drawNodeEx->setDNRotation(rotation / 10.0f);
        drawNodeEx->setDNScale(Vec2(2.0f, 2.0f));
        drawNodeEx->setDNCenter(vertices1[4]);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::BLUE, sliderValue[sliderType::Thickness]);
        drawNodeEx->setDNRotation(rotation);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::YELLOW, sliderValue[sliderType::Thickness]);
        drawNodeEx->setDNRotation(-rotation / 5);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::WHITE, sliderValue[sliderType::Thickness]);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::GREEN, sliderValue[sliderType::Thickness]);
        break;
    }
    case  drawMethodes::Polygon:
    {
        drawNodeEx->setDNPosition(Vec2(0, -300));
        drawNodeEx->setDNRotation(sliderValue[sliderType::Rotation]);
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::GREEN, sliderValue[sliderType::Thickness],
            Color::YELLOW);
        drawNodeEx->setDNPosition(Vec2(-100, -300));
        drawNodeEx->setDNRotation(sliderValue[sliderType::Rotation]);
        drawNodeEx->setDNCenter(vertices1[0]);
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::MAGENTA, sliderValue[sliderType::Thickness],
            Color::GRAY);
        drawNodeEx->setDNPosition(Vec2(200, 0));
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::RED, sliderValue[sliderType::Thickness],
            Color::YELLOW);


        drawNodeEx->setDNPosition(Vec2(0.0f, -300.0f));
        drawNodeEx->setDNRotation(rotation / 10.0f);
        drawNodeEx->setDNScale(Vec2(2.0f, 2.0f));
        drawNodeEx->setDNCenter(vertices1[4]);
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::BLUE, sliderValue[sliderType::Thickness],
            Color::WHITE);
        drawNodeEx->setDNRotation(rotation);
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::YELLOW, sliderValue[sliderType::Thickness],
            Color::GREEN);;
        drawNodeEx->setDNRotation(-rotation / 5);
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::WHITE, sliderValue[sliderType::Thickness],
            Color::YELLOW);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawPolygon(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::GREEN, sliderValue[sliderType::Thickness],
            Color::BLUE);

        break;
    }
    case  drawMethodes::Dot:
    {
        for (int i = 0; i < 100; i++)
        {
            drawNodeEx->drawDot(Vec2(AXRANDOM_MINUS1_1() * 400 + 200, AXRANDOM_MINUS1_1() * 400), 20 + sliderValue[sliderType::Thickness], Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }

        break;
    }
    case  drawMethodes::Point:
    {
        for (int i = 0; i < 100; i++)
        {
            drawNodeEx->drawPoint(Vec2(AXRANDOM_MINUS1_1() * 400 + 200, AXRANDOM_MINUS1_1() * 400), 30 + sliderValue[sliderType::Thickness], Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }
        break;
    }
    case  drawMethodes::Points:
    {
        for (int i = 0; i < 100; i++)
        {
            Vec2 pos = Vec2(-100, -100) + Vec2(AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y);
            Vec2 position[] = {
                {60 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y / 2},
                {70 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y / 2},
                {60 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y / 2},
                {70 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y / 2} };
            drawNodeEx->drawPoints(position, 4, 10 + 2 * sliderValue[sliderType::Thickness], Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));
        }
        break;
    }
    case  drawMethodes::Triangle:
    {
        drawNodeEx->setDNScale(Vec2(3, 3));
        for (int i = 0; i < 10; i++)
        {
            drawNodeEx->drawTriangle(Vec2(AXRANDOM_0_1() * 50 + 100, AXRANDOM_0_1() * 50 + 100),
                Vec2(AXRANDOM_MINUS1_1() * 50, AXRANDOM_MINUS1_1() * 50),
                Vec2(AXRANDOM_0_1() * 50 + 100, AXRANDOM_0_1() * 50 + 100),
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }
        break;
    }
    case  drawMethodes::Segment:
    {
        labelRound->setVisible(true);
        labelSquare->setVisible(true);
        labelButt->setVisible(true);

        int yy1 = 150;
        int yy = 0;
        drawNodeEx->drawSegment(Vec2(-150.0f, yy - yy1), Vec2(200, yy - yy1), 20 + 5 * sliderValue[sliderType::Thickness],
            Color::GREEN, DrawNodeEx::Round, DrawNodeEx::Round);
        labelRound->setPosition(Vec2(250.0f, 85));


        yy += 170;
        drawNodeEx->drawSegment(Vec2(-150.0f, yy - yy1), Vec2(200, yy - yy1), 20 + 5 * sliderValue[sliderType::Thickness],
            Color::BLUE, DrawNodeEx::Square, DrawNodeEx::Square);
        labelSquare->setPosition(Vec2(250.0f, 170));


        yy += 170;
        drawNodeEx->drawSegment(Vec2(-150.0f, yy - yy1), Vec2(200, yy - yy1), 20 + 5 * sliderValue[sliderType::Thickness],
            Color::RED, DrawNodeEx::Butt, DrawNodeEx::Butt);
        labelButt->setPosition(Vec2(250.0f, 255));

        break;
    }
    case  drawMethodes::SolidCircle:
    {
        for (int i = 100; i > 1; i--)
        {
            drawNodeEx->drawSolidCircle(VisibleRect::center(), 3 * i, AX_DEGREES_TO_RADIANS(90), AXRANDOM_0_1() * 20.f + 20.f, 1.0f, 1.0f,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness], Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

            Vec2 pos = Vec2(-100, -100) + Vec2(AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y);
            drawNodeEx->drawSolidCircle(VisibleRect::center() + pos, AXRANDOM_0_1() * 200, AX_DEGREES_TO_RADIANS(AXRANDOM_MINUS1_1() * 90), 10, 1.0f, 1.0f,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), sliderValue[sliderType::Thickness], Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }


        /*     for (int i = 0; i < 100; i++)
             {
                 drawNodeEx->drawSolidCircle(
                     Vec2(AXRANDOM_0_1() * -VisibleRect::rightTop().x, -AXRANDOM_0_1() * VisibleRect::rightTop().y),
                     AXRANDOM_0_1() * 40.f + 40.f, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
                     Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f),);
             }*/
        break;
    }
    case  drawMethodes::SolidPoly:
    {
        Vec2 ppp = Vec2(AXRANDOM_MINUS1_1() * size.x / 2, AXRANDOM_MINUS1_1() * size.y / 2);
        drawNodeEx->setDNPosition(Vec2(ppp));


        drawNodeEx->setDNPosition(Vec2(0.0f, -300.0f));
        drawNodeEx->setDNRotation(rotation / 10.0f);
        drawNodeEx->setDNScale(Vec2(2.0f, 2.0f));
        drawNodeEx->setDNCenter(vertices1[4]);
        drawNodeEx->drawSolidPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::BLUE);
        drawNodeEx->setDNRotation(rotation);
        drawNodeEx->drawSolidPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::YELLOW);
        drawNodeEx->setDNRotation(-rotation / 5);
        drawNodeEx->drawSolidPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::WHITE);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawSolidPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), Color::GREEN);

        break;
    }
    case  drawMethodes::SolidRect:
    {
        for (int i = 0; i < 100; i++)
        {
            Vec2 pos = Vec2(-100, -100) + Vec2(AXRANDOM_MINUS1_1() * VisibleRect::rightTop().x, AXRANDOM_MINUS1_1() * VisibleRect::rightTop().y);
            drawNodeEx->drawSolidRect(pos, pos + Vec2(20.0f * sliderValue[sliderType::Thickness], 20.0f * sliderValue[sliderType::Thickness]), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f), sliderValue[sliderType::Thickness]);
        }

        break;
    }
    case  drawMethodes::Star:
    {

        Vec2 gear1 = { 270.f, 320.f };
        Vec2 gear2 = { 160.f, 320.f };
        Vec2 gear3 = { 200.f, 200.f };
        Vec2 gear4 = { size.width - 200, size.height - 200 };

        drawNodeEx->setDNRotation(rotation + 45);
        drawNodeEx->setDNCenter(gear1);
        drawNodeEx->drawStar(Vec2(gear1), 30, 60, 8, Color::BLUE, 4.0);
        drawNodeEx->setDNRotation(-rotation);
        drawNodeEx->setDNCenter(gear2);
        drawNodeEx->drawStar(gear2, 30, 60, 8, Color::GREEN, 4.0);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawLine(gear2, gear1, Color::RED, sliderValue[sliderType::Thickness]);  // line
        drawNodeEx->setDNCenter(gear4);
        drawNodeEx->setDNRotation(rotation + 45);
        drawNodeEx->drawStar(gear3, 30, 60, 18, Color::RED, 1.0);
        drawNodeEx->drawLine(gear3, gear4, Color::YELLOW, sliderValue[sliderType::Thickness]);  // line
        // drawNodeEx->resetDNValues();
        drawNodeEx->setDNRotation(rotation - 45);
        drawNodeEx->setDNCenter(gear4);
        drawNodeEx->drawStar(gear4, 40, 60, 60, Color::GREEN, 1.0);


        drawNodeEx->setDNRotation(rotation);
        drawNodeEx->setDNCenter(Vec2(-110, 250));
        drawNodeEx->drawStar(Vec2(-110, 250), 30, 70, 5, Color::GREEN, 1.0);
        drawNodeEx->setDNCenter(Vec2(-150, 100));
        drawNodeEx->drawStar(Vec2(-150, 100), 80, 100, 40, Color::GREEN, 1.0);
        drawNodeEx->setDNCenter(Vec2(-150, -100));
        drawNodeEx->drawStar(Vec2(-150, -100), 5, 70, 3, Color::GREEN, 1.0);

        drawNodeEx->setDNRotation(0);
        //for (int i = 0; i < 10; i++)
        //{
        //    Vec2 pos = Vec2(AXRANDOM_0_1() * VisibleRect::rightTop().x - 100, AXRANDOM_0_1() * VisibleRect::rightTop().y - 300);
        //    drawNodeEx->drawStar(pos, 40, 60, AXRANDOM_0_1() * 60 + 3, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), sliderValue[sliderType::Thickness]));
        //}

        drawNodeEx->setDNRotation(0);
        for (int i = 0; i < 10; i++)
        {
            Vec2 ppp = Vec2(AXRANDOM_MINUS1_1() * size.x / 2, AXRANDOM_MINUS1_1() * size.y / 2);
            drawNodeEx->setDNPosition(Vec2(ppp));
            drawNodeEx->drawStar(Vec2::ZERO, 40, 60, AXRANDOM_0_1() * 60 + 3, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), sliderValue[sliderType::Thickness]));
            // drawNodeEx->drawSolidStar(Vec2::ZERO, 40, 60, AXRANDOM_0_1() * 60 + 3, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }
        break;
    }
    case  drawMethodes::SolidStar:
    {
        Vec2 gear1 = { 270.f, 320.f };
        Vec2 gear2 = { 160.f, 320.f };
        Vec2 gear3 = { 200.f, 200.f };
        Vec2 gear4 = { size.width - 200, size.height - 200 };

        drawNodeEx->setDNRotation(rotation + 45);
        drawNodeEx->setDNCenter(gear1);
        drawNodeEx->drawSolidStar(Vec2(gear1), 30, 60, 8, Color::BLUE, Color::YELLOW, 4.0);
        drawNodeEx->setDNRotation(-rotation);
        drawNodeEx->setDNCenter(gear2);
        drawNodeEx->drawSolidStar(gear2, 30, 60, 8, Color::GREEN, Color::YELLOW, 4.0);

        drawNodeEx->resetDNValues();
        drawNodeEx->drawLine(gear2, gear1, Color::RED, sliderValue[sliderType::Thickness]);  // line
        drawNodeEx->setDNCenter(gear4);
        drawNodeEx->setDNRotation(rotation + 45);
        drawNodeEx->drawSolidStar(gear3, 30, 60, 18, Color::RED, Color::YELLOW, 1.0);
        drawNodeEx->drawLine(gear3, gear4, Color::YELLOW, sliderValue[sliderType::Thickness]);  // line
        drawNodeEx->resetDNValues();
        drawNodeEx->setDNRotation(rotation - 45);
        drawNodeEx->setDNCenter(gear4);
        drawNodeEx->drawSolidStar(gear4, 40, 60, 60, Color::GREEN, Color::YELLOW, 1.0);


        drawNodeEx->setDNRotation(rotation);
        drawNodeEx->setDNCenter(Vec2(-110, 250));
        drawNodeEx->drawSolidStar(Vec2(-110, 250), 30, 70, 5, Color::GREEN, Color::YELLOW, 1.0);
        drawNodeEx->setDNCenter(Vec2(-150, 100));
        drawNodeEx->drawSolidStar(Vec2(-150, 100), 80, 100, 40, Color::GREEN, Color::YELLOW, 1.0);
        drawNodeEx->setDNCenter(Vec2(-150, -100));
        drawNodeEx->drawSolidStar(Vec2(-150, -100), 5, 70, 3, Color::GREEN, Color::YELLOW, 1.0);

        drawNodeEx->setDNRotation(0);
        for (int i = 0; i < 10; i++)
        {
            Vec2 ppp = Vec2(AXRANDOM_MINUS1_1() * size.x / 2, AXRANDOM_MINUS1_1() * size.y / 2);
            drawNodeEx->setDNPosition(Vec2(ppp));
            drawNodeEx->drawSolidStar(Vec2::ZERO, 40, 60, AXRANDOM_0_1() * 60 + 3, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }

        break;
    }

    default:
        break;
    }
}

DrawNodePerformaneTest::DrawNodePerformaneTest()
{
    auto listview = createListView();
    listview->setPosition(Vec2(0.0f, 90.0f));
    addChild(listview);

    drawNodeEx->setScale(0.5);
    drawNodeEx->setPosition(size / 4);

    initSliders();
    initRadioButtuns();

    label = Label::createWithTTF("Count: ", "fonts/Marker Felt.ttf", 10);
    label->setPosition(Vec2(Vec2(center.x, 80.0f)));
    this->addChild(label, 1);

    label1 = Label::createWithTTF("DrawNodeEx::Round", "fonts/Arial.ttf", 12);
    addChild(label1, 1);
    label2 = Label::createWithTTF("DrawNodeEx::Square", "fonts/Arial.ttf", 12);
    addChild(label2, 1);
    label3 = Label::createWithTTF("DrawNodeEx::Butt", "fonts/Arial.ttf", 12);
    addChild(label3, 1);

    scheduleUpdate();
}

std::string DrawNodePerformaneTest::title() const
{
    return "DrawNode Performance Test";
}

string DrawNodePerformaneTest::subtitle() const
{
    return "";
}

ax::ui::ListView* DrawNodePerformaneTest::createListView()
{
    auto listview = ax::ui::ListView::create();

    auto drawLine = ax::ui::Text::create();
    drawLine->setString("drawDot");
    drawLine->setTouchEnabled(true);
    listview->pushBackCustomItem(drawLine);

    auto drawSegment = ax::ui::Text::create();
    drawSegment->setString("drawPoint");
    drawSegment->setTouchEnabled(true);
    listview->pushBackCustomItem(drawSegment);

    auto drawTriangle = ax::ui::Text::create();
    drawTriangle->setString("drawPoints");
    drawTriangle->setTouchEnabled(true);
    listview->pushBackCustomItem(drawTriangle);

    auto drawRect = ax::ui::Text::create();
    drawRect->setString("drawTriangle");
    drawRect->setTouchEnabled(true);
    listview->pushBackCustomItem(drawRect);

    auto drawCircle = ax::ui::Text::create();
    drawCircle->setString("drawSegment");
    drawCircle->setTouchEnabled(true);
    listview->pushBackCustomItem(drawCircle);

    auto drawQuadBezier = ax::ui::Text::create();
    drawQuadBezier->setString("drawSolidCircle");
    drawQuadBezier->setTouchEnabled(true);
    listview->pushBackCustomItem(drawQuadBezier);

    auto drawCubicBezier = ax::ui::Text::create();
    drawCubicBezier->setString("drawSolidPoly");
    drawCubicBezier->setTouchEnabled(true);
    listview->pushBackCustomItem(drawCubicBezier);

    auto drawCardinalSpline = ax::ui::Text::create();
    drawCardinalSpline->setString("drawSolidRect");
    drawCardinalSpline->setTouchEnabled(true);
    listview->pushBackCustomItem(drawCardinalSpline);

    listview->setContentSize(drawLine->getContentSize() * 8);
    listview->setCurSelectedIndex(0);
    listview->setTouchEnabled(true);
    listview->addEventListener(
        (ui::ListView::ccListViewCallback)AX_CALLBACK_2(DrawNodeExBaseTest::listviewCallback, this));
    listview->setTag(100);

    listview->getItem(_currentSeletedItemIndex)->setColor(Color3B::RED);

    return listview;
}

void DrawNodePerformaneTest::update(float dt)
{
    DrawNodeExBaseTest::update(dt);

    drawNodeEx->clear();

    label1->setVisible(false);
    label2->setVisible(false);
    label3->setVisible(false);


    label->setString("Count: (" + Value(count).asString() + ")");
    switch (_currentSeletedItemIndex)
    {
    case 0:
    {
        // Draw 10 circles/dots
        for (int i = 0; i < count / 100; i++)
        {
            drawNodeEx->drawDot(Vec2(100.f + AXRANDOM_0_1() * VisibleRect::rightTop().x,
                100.f + AXRANDOM_0_1() * VisibleRect::rightTop().y),
                AXRANDOM_0_1() * 20 + 20, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }
        break;
    }
    case 1:
    {
        for (int i = 0; i < 100; i++)
        {
            drawNodeEx->drawPoint(Vec2(i * 7.0f, 50.0f), (float)i / 5 + 1,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
        }
        break;
    }
    case 2:
    {
        // drawPoints
        for (int i = 0; i < count; i++)
        {
            Vec2 position[] = {
                {60 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
                {70 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
                {60 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
                {70 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_0_1() * VisibleRect::rightTop().y} };
            drawNodeEx->drawPoints(position, 4, 5, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));
        }

        break;
    }
    case 3:
    {
        // drawTriangle
        for (int i = 0; i < count; i++)
        {
            Vec2 pos = Vec2(AXRANDOM_0_1() * VisibleRect::rightTop().x, AXRANDOM_0_1() * VisibleRect::rightTop().y);
            drawNodeEx->drawTriangle(pos + Vec2(10.0f, 10.0f), pos + Vec2(70.0f, 30.0f), pos + Vec2(100.0f, 140.0f),
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));
        }
        break;
    }
    case 4:
    {
        // Draw segment
        label1->setVisible(true);
        label2->setVisible(true);
        label3->setVisible(true);

        int yy1 = 0;
        int yy = 50;
        drawNodeEx->drawSegment(Vec2(50.0f, yy), Vec2(400, yy - yy1), count / 20,
            Color::GREEN, DrawNodeEx::Round, DrawNodeEx::Round);

        label1->setPosition(Vec2(410.0f, yy + 55));


        yy += 110;
        drawNodeEx->drawSegment(Vec2(50.0f, yy), Vec2(400, yy - yy1), count / 20,
            Color::BLUE, DrawNodeEx::Round, DrawNodeEx::Square);
        label2->setPosition(Vec2(410.0f, yy));


        yy += 110;
        drawNodeEx->drawSegment(Vec2(50.0f, yy), Vec2(400, yy - yy1), count / 20,
            Color::RED, DrawNodeEx::Round, DrawNodeEx::Butt);
        label3->setPosition(Vec2(410.0f, yy - 55));

        break;
    }
    case 5:
    {
        // draw a solid circle
        for (int i = 0; i < count; i++)
        {
            drawNodeEx->drawSolidCircle(
                Vec2(AXRANDOM_0_1() * VisibleRect::rightTop().x, AXRANDOM_0_1() * VisibleRect::rightTop().y),
                AXRANDOM_0_1() * 40.f + 40.f, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));
        }
        break;
    }
    case 6:
    {
        // draw a solid poly
        drawNodeEx->resetDNValues();
        drawNodeEx->setDNPosition(vertices1[0]);
        drawNodeEx->setDNRotation(count);
        //    draw->setDNScale(Vec2(count, count));
        drawNodeEx->setDNCenter(vertices1[0]);
        drawNodeEx->drawPoly(vertices1, sizeof(vertices1) / sizeof(vertices1[0]), true, Color::GREEN, count);
        drawNodeEx->resetDNValues();
        break;
    }
    case 7:
    {
        // draw a solid rectangle
        for (int i = 0; i < count; i++)
        {
            Vec2 pos = Vec2(AXRANDOM_0_1() * VisibleRect::rightTop().x, AXRANDOM_0_1() * VisibleRect::rightTop().y);
            drawNodeEx->drawSolidRect(pos, pos + Vec2(20.0f, 20.0f),
                Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));
        }
        break;
    }
    default:
        break;
    }
}

void DrawNodePerformaneTest::onEnter()
{
    for (int i = 0; i < sliderType::sliderTypeLast; i++)
    {
        sliderValue[i] = 1;
        slider[i]->setPercent(sliderValue[i]);
    }

    sliderValue[sliderType::Thickness] = 10;
    slider[sliderType::Thickness]->setPercent(sliderValue[sliderType::Thickness]);

    DrawNodeExBaseTest::onEnter();
}

DrawNodeDrawInWrongOrder_Issue1888::DrawNodeDrawInWrongOrder_Issue1888()
{

    heart = new Vec2[totalFrames];

    for (int i = 0; i < totalFrames; i++)
    {
        float a = AXRANDOM_0_1() * M_PI * 4;
        float r = AXRANDOM_0_1() * sin(a);
        heart[i] = { r * 100, r * 100 };
        heart[i] = { size.width / 2,size.height / 2 };
    }

    initSliders();
    initRadioButtuns();

    scheduleUpdate();
}

std::string DrawNodeDrawInWrongOrder_Issue1888::title() const
{
    return "Issue #1888: Drawing order";
}

std::string DrawNodeDrawInWrongOrder_Issue1888::subtitle() const
{
    return "Red behind all. Green behind the blue.\nRandom Points behind the square. Blue is top.";
}

void DrawNodeDrawInWrongOrder_Issue1888::update(float dt)
{
    DrawNodeExBaseTest::update(dt);

    drawNodeEx->clear();

    drawNodeEx->drawLine(Vec2(20, 140), Vec2(450, 110), Color4B::RED, 20.0f);

    Vec2 position1[] = {
        {60 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
        {70 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
        {60 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 60 + AXRANDOM_0_1() * VisibleRect::rightTop().y},
        {70 + AXRANDOM_0_1() * VisibleRect::rightTop().x, 70 + AXRANDOM_0_1() * VisibleRect::rightTop().y} };
    drawNodeEx->drawPoints(position1, 4, 10, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    drawNodeEx->drawSolidRect(Vec2(250, 80), Vec2(400, 220), Color4B::YELLOW);
    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(i * 7.0f, 120.0f), (float)i / 5 + 1,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }
    drawNodeEx->drawLine(Vec2(20, 100), Vec2(450, 220), Color4B::GREEN, 8.0f);
    drawNodeEx->drawLine(Vec2(200, 100), Vec2(450, 250), Color4B::BLUE, 6.0f);

#if defined(DRAWNODE_DRAW_LINE_POINT)
    drawNodeEx->_drawOrder = true;
#endif
}


DrawNodeAxmolTest2::DrawNodeAxmolTest2()
{
    selectedRadioButton = 0;

    _radioButtonGroup = ui::RadioButtonGroup::create();
    addChild(_radioButtonGroup, 50);

    static const float BUTTON_WIDTH = 30;
    static float startPosX = 0;

    // Create the radio buttons
    static const int NUMBER_OF_BUTTONS = 3;
    startPosX = size.width / 2.0f - ((NUMBER_OF_BUTTONS - 1) / 2.0f) * BUTTON_WIDTH;
    for (int i = 0; i < NUMBER_OF_BUTTONS; ++i)
    {
        ui::RadioButton* radioButton =
            ui::RadioButton::create("cocosui/radio_button_off.png", "cocosui/radio_button_on.png");
        float posX = startPosX + BUTTON_WIDTH * i;
        radioButton->setPosition(Vec2(posX, size.height - 80));
        radioButton->setScale(1.2f);
        radioButton->setTag(i);
        _radioButtonGroup->addRadioButton(radioButton);
        addChild(radioButton, 50);
        radioButton->addEventListener(
            AX_CALLBACK_2(DrawNodeAxmolTest2::onChangedRadioButtonSelect, this));
    }


    drawNode = DrawNode::create();
    addChild(drawNode, 10);

    //initSliders();
    //initRadioButtuns();
    scheduleUpdate();
}

void DrawNodeAxmolTest2::onChangedRadioButtonSelect(ui::RadioButton* radioButton, ui::RadioButton::EventType type)
{
    if (radioButton == nullptr)
    {
        return;
    }
    switch (type)
    {
    case ui::RadioButton::EventType::SELECTED:
    {
        selectedRadioButton = radioButton->getTag();
        break;
    }

    case ui::RadioButton::EventType::UNSELECTED:
    {
        break;
    }
    default:
        break;
    }
}

void DrawNodeAxmolTest2::update(float dt)
{
    DrawNodeExBaseTest::update(dt);


    if (!drawNode || !drawNodeEx)
    {
        return;
    }

    drawNode->clear();
    drawNodeEx->clear();

    switch (selectedRadioButton)
    {
    case 0:
        setSubtitleLabel("Axmol v2 drawOrder ON (T)");
        drawAllv2(drawNodeEx, true);
        break;
    case 1:
        setSubtitleLabel("Axmol v2 drawOrder OFF (T,P,L)");
        drawAllv2(drawNodeEx, false);
        break;
    case 2:
        setSubtitleLabel("Axmol v1");
        drawAllv1(drawNode);
        break;

    default:
        break;
    }

}
void DrawNodeAxmolTest2::drawAllv1(ax::DrawNode* drawNodeEx)
{
    drawNodeEx->drawPoint(Vec2(size.width / 2 - 120, size.height / 2 - 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    drawNodeEx->drawPoint(Vec2(size.width / 2 + 120, size.height / 2 + 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx 4 small points
    Vec2 position[] = { Vec2(60, 60), Vec2(70, 70), Vec2(60, 70), Vec2(70, 60) };
    drawNodeEx->drawPoints(position, 4, 5, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a line
    drawNodeEx->drawLine(Vec2(0, 0), Vec2(size.width, size.height), Color(1.0, 0.0, 0.0, 0.5));

    // drawNodeEx a rectangle
    drawNodeEx->drawRect(Vec2(23, 23), Vec2(7, 7), Color(1, 1, 0, 1));

    drawNodeEx->drawRect(Vec2(15, 30), Vec2(30, 15), Vec2(15, 0), Vec2(0, 15),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a circle
    drawNodeEx->drawCircle(VisibleRect::center() + Vec2(140, 0), 100, AX_DEGREES_TO_RADIANS(90), 50, true, 1.0f, 2.0f,
        Color(1.0f, 0.0f, 0.0f, 0.5f));

    drawNodeEx->drawCircle(VisibleRect::center() - Vec2(140, 0), 50, AX_DEGREES_TO_RADIANS(90), 30, false,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx some beziers
    drawNodeEx->drawQuadBezier(Vec2(size.width - 150, size.height - 150), Vec2(size.width - 70, size.height - 10),
        Vec2(size.width - 10, size.height - 10), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawQuadBezier(Vec2(0.0f, size.height), Vec2(size.width / 2, size.height / 2), Vec2(size.width, size.height), 50,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
        Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(), 100,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(Vec2(size.width - 250, 40.0f), Vec2(size.width - 70, 100.0f), Vec2(size.width - 30, 250.0f),
        Vec2(size.width - 10, size.height - 50), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array = PointArray::create(20);
    array->addControlPoint(Vec2(0.0f, 0.0f));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array->addControlPoint(Vec2(80.0f, size.height - 80));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width / 2, size.height / 2));
    drawNodeEx->drawCardinalSpline(array, 0.5f, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array2 = PointArray::create(20);
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    drawNodeEx->drawCatmullRom(array2, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    // open random color poly
    Vec2 vertices[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f),
        Vec2(50.0f, 100.0f) };
    drawNodeEx->drawPoly(vertices, 5, false, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // closed random color poly
    Vec2 vertices2[] = { Vec2(30.0f, 130.0f), Vec2(30.0f, 230.0f), Vec2(50.0f, 200.0f) };
    drawNodeEx->drawPoly(vertices2, 3, true, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx 10 circles
    for (int i = 0; i < 10; i++)
    {
        drawNodeEx->drawDot(Vec2(size.width / 2, size.height / 2), 10.f * (10 - i),
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    // drawNodeEx polygons
    Vec2 points[] = { Vec2(size.height / 4, 0.0f), Vec2(size.width, size.height / 5), Vec2(size.width / 3 * 2, size.height) };
    drawNodeEx->drawPolygon(points, sizeof(points) / sizeof(points[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 4,
        Color(0.0f, 0.0f, 1.0f, 0.5f));

    // star poly (triggers buggs)
    {
        const float o = 80;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o + w, o - h), Vec2(o + w * 2, o),                  // lower spike
            Vec2(o + w * 2 + h, o + w), Vec2(o + w * 2, o + w * 2),  // right spike
            //              {o +w, o+w*2+h}, {o,o+w*2},                 // top spike
            //              {o -h, o+w}, {o,o},                         // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // star poly (doesn't trigger bug... order is important un tesselation is supported.
    {
        const float o = 180;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o, o),
            Vec2(o + w, o - h),
            Vec2(o + w * 2, o),  // lower spike
            Vec2(o + w * 2 + h, o + w),
            Vec2(o + w * 2, o + w * 2),  // right spike
            Vec2(o + w, o + w * 2 + h),
            Vec2(o, o + w * 2),  // top spike
            Vec2(o - h, o + w),  // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // drawNodeEx a solid polygon
    Vec2 vertices3[] = { Vec2(60.0f, 160.0f), Vec2(70.0f, 190.0f), Vec2(100.0f, 190.0f), Vec2(90.0f, 160.0f) };
    drawNodeEx->drawSolidPoly(vertices3, 4, Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid rectangle
    drawNodeEx->drawSolidRect(Vec2(10.0f, 10.0f), Vec2(20.0f, 20.0f), Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid circle
    drawNodeEx->drawSolidCircle(VisibleRect::center() + Vec2(140.0f, 0.0f), 40, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
        Color(0.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx segment
    drawNodeEx->drawSegment(Vec2(20.0f, size.height), Vec2(20.0f, size.height / 2), 10, Color(0.0f, 1.0f, 0.0f, 1.0f));

    drawNodeEx->drawSegment(Vec2(10.0f, size.height / 2), Vec2(size.width / 2, size.height / 2), 40, Color(1.0f, 0.0f, 1.0f, 0.5f));

    // drawNodeEx triangle
    drawNodeEx->drawTriangle(Vec2(10.0f, 10.0f), Vec2(70.0f, 30.0f), Vec2(100.0f, 140.0f),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(i * 7.0f, 5.0f), (float)i / 5 + 1,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    drawNodeEx->setLineWidth(4);
    drawNodeEx->drawLine(Vec2(0.0f, size.height), Vec2(size.width, size.height - 20), Color::YELLOW);
    drawNodeEx->drawLine(Vec2(0.0f, 0.0f), Vec2(size.width, size.height - 20), Color::YELLOW);
}


void DrawNodeAxmolTest2::drawAllv2(ax::extension::DrawNodeEx* drawNodeEx, bool drawOrder)
{
    drawNodeEx->setDNDrawOrder(drawOrder);


    drawNodeEx->drawPoint(Vec2(size.width / 2 - 120, size.height / 2 - 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    drawNodeEx->drawPoint(Vec2(size.width / 2 + 120, size.height / 2 + 120), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx 4 small points
    Vec2 position[] = { Vec2(60, 60), Vec2(70, 70), Vec2(60, 70), Vec2(70, 60) };
    drawNodeEx->drawPoints(position, 4, 5, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a line
    drawNodeEx->drawLine(Vec2(0, 0), Vec2(size.width, size.height), Color(1.0, 0.0, 0.0, 0.5));

    // drawNodeEx a rectangle
    drawNodeEx->drawRect(Vec2(23, 23), Vec2(7, 7), Color::RED);

    drawNodeEx->drawRect(Vec2(15, 30), Vec2(30, 15), Vec2(15, 0), Vec2(0, 15),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1));

    // drawNodeEx a circle
    drawNodeEx->drawCircle(VisibleRect::center() + Vec2(140, 0), 100, AX_DEGREES_TO_RADIANS(90), 30, true, 1.0f, 2.0f,
        Color(1.0f, 0.0f, 0.0f, 0.5f));

    drawNodeEx->drawCircle(VisibleRect::center() - Vec2(140, 0), 50, AX_DEGREES_TO_RADIANS(90), 30, false,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx some beziers
    drawNodeEx->drawQuadBezier(Vec2(size.width - 150, size.height - 150), Vec2(size.width - 70, size.height - 10),
        Vec2(size.width - 10, size.height - 10), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawQuadBezier(Vec2(0.0f, size.height), Vec2(size.width / 2, size.height / 2), Vec2(size.width, size.height), 50,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(VisibleRect::center(), Vec2(VisibleRect::center().x + 30, VisibleRect::center().y + 50),
        Vec2(VisibleRect::center().x + 60, VisibleRect::center().y - 50), VisibleRect::right(), 100,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    drawNodeEx->drawCubicBezier(Vec2(size.width - 250, 40.0f), Vec2(size.width - 70, 100.0f), Vec2(size.width - 30, 250.0f),
        Vec2(size.width - 10, size.height - 50), 10,
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array = PointArray::create(20);
    array->addControlPoint(Vec2(0.0f, 0.0f));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, 80.0f));
    array->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array->addControlPoint(Vec2(80.0f, size.height - 80));
    array->addControlPoint(Vec2(80.0f, 80.0f));
    array->addControlPoint(Vec2(size.width / 2, size.height / 2));
    drawNodeEx->drawCardinalSpline(array, 0.5f, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    auto array2 = PointArray::create(20);
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, 30.0f));
    array2->addControlPoint(Vec2(size.width - 80, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, size.height - 80));
    array2->addControlPoint(Vec2(size.width / 2, 30.0f));
    drawNodeEx->drawCatmullRom(array2, 50, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    // open random color poly
    Vec2 vertices[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f),
        Vec2(50.0f, 100.0f) };
    drawNodeEx->drawPoly(vertices, 5, false, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // closed random color poly
    Vec2 vertices2[] = { Vec2(30.0f, 130.0f), Vec2(30.0f, 230.0f), Vec2(50.0f, 200.0f) };
    drawNodeEx->drawPoly(vertices2, 3, true, Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));

    // drawNodeEx 10 circles
    for (int i = 0; i < 10; i++)
    {
        drawNodeEx->drawDot(Vec2(size.width / 2, size.height / 2), 10.f * (10 - i),
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    // drawNodeEx polygons
    Vec2 points[] = { Vec2(size.height / 4, 0.0f), Vec2(size.width, size.height / 5), Vec2(size.width / 3 * 2, size.height) };
    drawNodeEx->drawPolygon(points, sizeof(points) / sizeof(points[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 4,
        Color(0.0f, 0.0f, 1.0f, 0.5f));

    // star poly (triggers buggs)
    {
        const float o = 80;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o + w, o - h), Vec2(o + w * 2, o),                  // lower spike
            Vec2(o + w * 2 + h, o + w), Vec2(o + w * 2, o + w * 2),  // right spike
            //{o +w, o+w*2+h}, {o,o+w*2},                 // top spike
            //{o -h, o+w}, {o,o},                         // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // star poly (doesn't trigger bug... order is important un tesselation is supported.
    {
        const float o = 180;
        const float w = 20;
        const float h = 50;
        Vec2 star[] = {
            Vec2(o, o),
            Vec2(o + w, o - h),
            Vec2(o + w * 2, o),  // lower spike
            Vec2(o + w * 2 + h, o + w),
            Vec2(o + w * 2, o + w * 2),  // right spike
            Vec2(o + w, o + w * 2 + h),
            Vec2(o, o + w * 2),  // top spike
            Vec2(o - h, o + w),  // left spike
            Vec2(o, o),  // left spike
        };

        drawNodeEx->drawPolygon(star, sizeof(star) / sizeof(star[0]), Color(1.0f, 0.0f, 0.0f, 0.5f), 1,
            Color(0.0f, 0.0f, 1.0f, 1.0f));
    }

    // drawNodeEx a solid polygon
    Vec2 vertices3[] = { Vec2(60.0f, 160.0f), Vec2(70.0f, 190.0f), Vec2(100.0f, 190.0f), Vec2(90.0f, 160.0f) };
    drawNodeEx->drawSolidPoly(vertices3, 4, Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid rectangle
    drawNodeEx->drawSolidRect(Vec2(10.0f, 10.0f), Vec2(20.0f, 20.0f), Color(1.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx a solid circle
    drawNodeEx->drawSolidCircle(VisibleRect::center() + Vec2(140.0f, 0.0f), 40, AX_DEGREES_TO_RADIANS(90), 50, 2.0f, 2.0f,
        Color(0.0f, 1.0f, 0.0f, 1.0f));

    // drawNodeEx segment
    drawNodeEx->drawSegment(Vec2(20.0f, size.height), Vec2(20.0f, size.height / 2), 10, Color(0.0f, 1.0f, 0.0f, 1.0f));

    drawNodeEx->drawSegment(Vec2(10.0f, size.height / 2), Vec2(size.width / 2, size.height / 2), 40, Color(1.0f, 0.0f, 1.0f, 0.5f));

    // drawNodeEx triangle
    drawNodeEx->drawTriangle(Vec2(10.0f, 10.0f), Vec2(70.0f, 30.0f), Vec2(100.0f, 140.0f),
        Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 0.5f));

    for (int i = 0; i < 100; i++)
    {
        drawNodeEx->drawPoint(Vec2(i * 7.0f, 5.0f), (float)i / 5 + 1,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f));
    }

    drawNodeEx->setLineWidth(4);
    drawNodeEx->drawLine(Vec2(0.0f, size.height), Vec2(size.width, size.height - 20), Color::YELLOW);
    drawNodeEx->drawLine(Vec2(0.0f, 0.0f), Vec2(size.width, size.height - 20), Color::YELLOW);
}

string DrawNodeAxmolTest2::title() const
{
    return "DrawNode.v1 vs DrawNode.v2";
}

string DrawNodeAxmolTest2::subtitle() const
{
    return "";
}

DrawNodeCocos2dxBackwardsAPITest::DrawNodeCocos2dxBackwardsAPITest()
{
    float o = 80;
    float w = 20;
    float h = 50;


    drawNodeEx->setPosition(-40, 20);

    int x = 0;
    int y = 0;
    Vec2 vertices[5];
    drawNodeEx->setScale(0.5);
    Color color;
    for (int iy = 0; iy < 5; iy++)
    {
        x = 0;
        for (int ix = 0; ix < 13; ix++)
        {
            vertices[0] = Vec2(x + o + w, y + o - h);
            vertices[1] = Vec2(x + o + w * 2, y + o);
            vertices[2] = Vec2(x + o + w * 2 + h, y + o + w);
            vertices[3] = Vec2(x + o + w * 2, y + o + w * 2);
            vertices[4] = vertices[0];

            if (AXRANDOM_0_1() > 0.5f)
            {
                drawNodeEx->setIsConvex(true);
                color = Color::YELLOW;
            }
            else
            {
                drawNodeEx->setIsConvex(false);  // default value!
                color = Color::ORANGE;
            }
            drawNodeEx->drawPolygon(vertices, 5, Color(0.7f, 0.7f, 0.7f, 0.5f), 1.0f, color);
            x += 70;
        }
        y += 80;
    }
}

string DrawNodeCocos2dxBackwardsAPITest::title() const
{
    return "API backwards compatible test";
}

string DrawNodeCocos2dxBackwardsAPITest::subtitle() const
{
    return "YELLOW=cocos2dx/axmol <=2.0 ORANGE=axmol >2.0";
}

DrawNodeIssueTester::DrawNodeIssueTester()
{
    static Vec2 vertices[] = { Vec2(0.0f, 0.0f), Vec2(50.0f, 50.0f), Vec2(100.0f, 50.0f), Vec2(100.0f, 100.0f), Vec2(50.0f, 100.0f) };
    int verticesCount = 5;

    drawNodeEx->setDNPosition(Vec2(5, 150));
    drawNodeEx->setLineWidth(1);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color::GREEN);

    auto draw = DrawNode::create();
    addChild(draw, 10);
    draw->setPosition(70, 150);
    draw->drawPoly(vertices, verticesCount, false, Color::BLUE);

    drawNodeEx->setDNPosition(Vec2(140, 150));
    drawNodeEx->setLineWidth(1);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color::RED);

    drawNodeEx->setDNPosition(Vec2(200, 150));
    drawNodeEx->setLineWidth(1);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color::RED, 3);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color::WHITE);

    drawNodeEx->setDNPosition(Vec2(270, 150));
    drawNodeEx->setLineWidth(1);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color(0.0f, 0.5f, 0.5f, 0.5f), 10);
    drawNodeEx->drawPoly(vertices, verticesCount, false, Color::BLACK);

    float thick = 0.0f;
    float y = -90.0f;
    drawNodeEx->setDNPosition(Vec2(270, 100));
    for (int i = 0; i < 32; i++)
    {
        thick += 0.5f;
        y += thick + 1;
        drawNodeEx->drawLine(Vec2(140, y), Vec2(180, y), Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), thick);
    }
    drawNodeEx->drawPie(Vec2(-220, 150), 20, 0, 100, 300, 1, 1, Color4B::TRANSPARENT, Color4B::BLUE, DrawNodeEx::DrawMode::Line, 10);

    drawNodeEx->setDNPosition(Vec2(50, -100));
    for (int i = 2; i < 30; i++)
    {
        drawNodeEx->drawCircle(center, 5 * i, AX_DEGREES_TO_RADIANS(90), i, false, 1.0f, 1.0f,
            Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f), 0.5f);
    }

    Vec2* fbHorse = new Vec2[856 / 2];
    int n = 0;
    Vec2 pos = { 100,210 };
    float scale = 3.0f;
    drawNodeEx->setDNPosition(Vec2(-90, -160));
    for (size_t i = 0; i < sizeof(verticesFB) / sizeof(verticesFB[0]); i += 4)
    {
        drawNodeEx->drawLine(Vec2(verticesFB[i] * scale, verticesFB[i + 1] * scale) + pos, Vec2(verticesFB[i + 2] * scale, verticesFB[i + 3] * scale) + pos, Color::RED, 0.5f);
    }

    initRadioButtuns();
    scheduleUpdate();
}

void DrawNodeIssueTester::onEnter()
{
    DrawNodeExBaseTest::onEnter();
}

void DrawNodeIssueTester::update(float dt)
{
    // DrawNodeExBaseTest::update(dt);
}

string DrawNodeIssueTester::title() const
{
    return "For issue tests (future)";
}

string DrawNodeIssueTester::subtitle() const
{
    return "setLineWidth()";
}

DrawNodeSpLinesTest::DrawNodeSpLinesTest()
{
    auto listener = EventListenerTouchAllAtOnce::create();
    listener->onTouchesEnded = AX_CALLBACK_2(DrawNodeSpLinesTest::onTouchesEnded, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);

    drawNodeExCP = DrawNodeEx::create();
    addChild(drawNodeExCP, 20);

    drawNode = DrawNode::create();
    addChild(drawNode, 30);

    screen = Director::getInstance()->getVisibleSize();
    origin = Director::getInstance()->getVisibleOrigin();
    center = Vec2(screen.width / 2, screen.height / 2);
    sixth = Vec2(screen.width / 6, screen.height / 6); sixth.y;

    defY = (int)(center.y + sixth.y);
    defY2 = (int)(center.y - sixth.y);
    dev = sixth.y;

    pts = PointArray::create(n);
    pts2 = PointArray::create(n);
    pts->retain();
    pts2->retain();
    for (int i = 0; i < n; ++i) {
        pts->insertControlPoint(Vec2(0, 0), i);
        pts2->insertControlPoint(Vec2(0, 0), i);
    }

    DrawNodeExBaseTest::generateDataPoints();

    addNewControlPoint(VisibleRect::center());

    scheduleUpdate();
}

void DrawNodeSpLinesTest::addNewControlPoint(Vec2 p)
{
    points.emplace_back(Vec2(p.x, p.y));
}

void DrawNodeSpLinesTest::onTouchesEnded(const std::vector<Touch*>& touches, Event* event)
{
    for (auto& touch : touches)
    {
        auto location = touch->getLocation();
        addNewControlPoint(location);
    }
}


std::string DrawNodeSpLinesTest::title() const
{
    return "Testing SpLines";
}

std::string DrawNodeSpLinesTest::subtitle() const
{
    return "Tap screen to add more (control) points";
}

void DrawNodeSpLinesTest::update(float dt)
{
    if (points.size() == 0) return;

    array = PointArray::create(points.size());

    drawNodeExCP->clear();

    drawNode->clear();
    drawNodeEx->clear();

    int boxSize = 3;
    for (auto&& p : points)
    {
        drawNodeExCP->drawRect(Vec2(p.x - boxSize, p.y - boxSize), Vec2(p.x + boxSize, p.y + boxSize), Color::BLUE);
        array->addControlPoint(Vec2(p.x, p.y));
    }

    drawNodeEx->drawCardinalSpline(array, 0.2f, points.size() * 8, Color::GREEN, 20.0f);
    drawNode->drawCardinalSpline(array, 0.2f, points.size() * 8, Color::BLUE);

    drawNodeEx->drawCardinalSpline(array, 0.2f, points.size() * 16, Color(1.0f, 1.0f, 0.5f, 1.0f), 10.0f);

    //  drawNodeEx->drawCatmullRom(array, points.size() * 8, Color::YELLOW,5);
    //if (points.size()>3)
    //{
    //    int step = points.size()/4;
    //    drawNodeEx->drawCubicBezier(points.at(0), points.at(step),points.at(step*2),points.at(points.size()-1), points.size(), Color::BLUE);
    //}



    drawNodeEx->drawCardinalSpline(pts, 0.5f, 360, Color::RED, 5.0f);
    drawNodeEx->drawCardinalSpline(pts2, 0.5f, 360, Color::GREEN, 2.0f);

    int i1 = RandomHelper::random_int(0, n - 1);
    int i2 = RandomHelper::random_int(0, n - 1);
    drawNodeEx->drawDot(pts->getControlPointAtIndex(i1), 7, Color(0, 1, 0, 0.3));
    drawNodeEx->drawDot(pts->getControlPointAtIndex(i1), 4, Color::GREEN);

    drawNodeEx->drawDot(pts2->getControlPointAtIndex(i2), 7, Color(0, 1, 0, 0.3));
    drawNodeEx->drawDot(pts2->getControlPointAtIndex(i2), 4, Color::GREEN);
}

CandyMixEeffect::CandyMixEeffect()
{
    static const float BUTTON_WIDTH = 30;
    static float startPosX = 0;

    initRadioButtuns();

    scheduleUpdate();
}

std::string CandyMixEeffect::title() const
{
    return "Performance: Candy Mix";
}

std::string CandyMixEeffect::subtitle() const
{
    return "";
}

void CandyMixEeffect::rotozoom()
{
    float centerX = 200, centerY = 200, angleSpeed = 0, zoomSpeed = 0, zoom = 0;
    static b2Timer timer;
    float angle = 0;
    int WIDTH = 800;
    int HEIGHT = 600;

    float cosAngle = cos(angle);
    float sinAngle = sin(angle);
    float t = timer.GetMilliseconds() * 0.001;

    int c = (1 + sin(t * 2)) * 127;
    Color4B cc = Color4B(c, 255 - c, 32, 32);

    Color4B color;

    int o = 0;
    for (int py = 0; py < HEIGHT; py++)
    {
        for (int px = 0; px < WIDTH; px++)
        {
            float x = (px - centerX) * zoom;
            float y = (py - centerY) * zoom;
            float u = (x * cosAngle - y * sinAngle) * 0.01;
            float v = (x * sinAngle + y * cosAngle) * 0.01;
            if ((int(u * v) & 1) == 0)
            {
                color = Color4B(255, 255, 255, 255);
            }
            else if ((int(u * v) & 25) == 0)
            {
                color = cc;

            }
            //     color = Color(AXRANDOM_0_1(), AXRANDOM_0_1(), AXRANDOM_0_1(), 1.0f);
            drawNodeEx->drawPoint(Vec2(px, py), 2, color);
            o++;
        }
    }

    angle += angleSpeed;
    angleSpeed = sin(t * 0.5) * 0.005;
    zoom = 2 - sin(t * 0.5) * 0.5;
    centerX = WIDTH * 0.5 + sin(angle) * zoom * 350;
    centerY = HEIGHT * 0.5 + cos(angle) * zoom * 350;
}

void CandyMixEeffect::renderLine(float x1, float x2, float y, ax::Color color, float angle)
{




    static float WID = 400;


    float xMid = /*AXRANDOM_0_1()*100 +*/ (x1 + x2) * 0.5f;
    float r = color.r;
    float g = color.g;
    float b = color.b;
    float rng = 1.0f / (x2 - xMid);
    x1 = MIN(MAX(0.0f, x1), WID - 1);
    x2 = MIN(MAX(0.0f, x2), WID - 1);

    float mm = 0.8f;

    for (size_t x = x1; x < x2; x++)
    {
        float pos = (x - xMid) * rng;
        float ang = (angle + asin(pos) + (cos((angle + pos * (float)M_PI) * 1.78f) * 0.3f)) + (float)M_PI * 0.5f;
        float sf = 0.2f + 0.8f * MAX(mm - 0.8, MIN(mm, cos(ang)));
        float sp = pow(MAX(0, cos(2 * ang)), 20);
        float rr = MIN(mm, r * sf + sp);
        float gg = MIN(mm, g * sf + sp);
        float bb = MIN(mm, b * sf + sp);
        drawNodeEx->drawPoint(Vec2(y, x - 50), 2.0f, Color(rr, gg, bb, 0.8f));
    }
}

void CandyMixEeffect::update(float dt)
{
    DrawNodeExBaseTest::update(dt);
    drawNodeEx->clear();
    //rotozoom();
    //return;

    static float WID = 400;
    static float HIG = 600;
    static b2Timer timer;

    float t = timer.GetMilliseconds() / 1000.0f;
    float ta = sin(t * cos(t) * 0.02f) + t;
    float tb = (1.0f + sin(t) * 1.0f) * 0.02f + 0.01f;
    float xa = WID * 0.5f;
    for (int y = 0; y < HIG; y++)
    {
        float ya = y * 0.01f;
        float rad = 60 + sin(ta + ya) * 30;
        float rot = t + sin(ya * 2) * 0.5f + cos(ta * 0.3f) * 0.3f;
        float x1 = xa + sin(rot) * rad;
        float x2 = xa + sin(rot + (float)M_PI * 0.5f) * rad;
        float x3 = xa + sin(rot + (float)M_PI) * rad;
        float x4 = xa + sin(rot + (float)M_PI * 1.5f) * rad;
        if (x1 < x2)
            renderLine(x1, x2, y, Color::RED, rot);
        if (x2 < x3)
            renderLine(x2, x3, y, Color::GREEN, rot + (float)M_PI * 0.5f);
        if (x3 < x4)
            renderLine(x3, x4, y, Color::BLUE, rot + (float)M_PI);
        if (x4 < x1)
            renderLine(x4, x1, y, Color::YELLOW, rot + (float)M_PI * 1.5f);
        t += sin(ta + ya) * tb;
        xa += sin(t + ta) * 0.1f;
    }
}

#if defined(_WIN32)
#    pragma pop_macro("TRANSPARENT")
#endif
